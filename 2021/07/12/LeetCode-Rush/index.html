<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;zh-HK&quot;,&quot;zh-TW&quot;,&quot;default&quot;]" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>LeetCode Rush | zsStrike</title><meta name="keywords" content="Algorithm"><meta name="author" content="zsStrike"><meta name="copyright" content="zsStrike"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本文用于记录在算法题目中使用的技巧或者方法，以备查阅。">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode Rush">
<meta property="og:url" content="http://zsstrike.github.io/2021/07/12/LeetCode-Rush/index.html">
<meta property="og:site_name" content="zsStrike">
<meta property="og:description" content="本文用于记录在算法题目中使用的技巧或者方法，以备查阅。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://zsstrike.github.io/assets/default_cover.png">
<meta property="article:published_time" content="2021-07-12T14:36:59.000Z">
<meta property="article:modified_time" content="2022-08-25T01:50:57.333Z">
<meta property="article:author" content="zsStrike">
<meta property="article:tag" content="Algorithm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://zsstrike.github.io/assets/default_cover.png"><link rel="shortcut icon" href="/assets/avatar.jpg"><link rel="canonical" href="http://zsstrike.github.io/2021/07/12/LeetCode-Rush/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":5000,"languages":{"author":"作者: zsStrike","link":"链接: ","source":"来源: zsStrike","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'LeetCode Rush',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-08-25 09:50:57'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/assets/avatar.jpg" onerror="onerror=null;src='/assets/default_cover.png'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">43</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/index"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">zsStrike</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/index"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">LeetCode Rush</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-12T14:36:59.000Z" title="发表于 2021-07-12 22:36:59">2021-07-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-08-25T01:50:57.333Z" title="更新于 2022-08-25 09:50:57">2022-08-25</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>24分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="LeetCode Rush"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"><p>本文用于记录在算法题目中使用的技巧或者方法，以备查阅。</p>
<span id="more"></span>

<h2 id="链表问题"><a href="#链表问题" class="headerlink" title="链表问题"></a>链表问题</h2><ul>
<li>使用双指针可以解决找固定位置相关问题，环形链表问题，相交链表问题，旋转链表问题</li>
<li>尝试设置 <code>dummyHead</code> 节点，用于处理特殊情况</li>
<li>只知道要删除的节点，实现该节点的删除</li>
<li>头插法和尾插法的不同点，可以使用头插法实现链表的反转，也可以直接使用迭代方法</li>
<li>链表反转问题：全部反转（迭代，递归，头插法），部分反转（递归，迭代），k 个一组翻转（递归，迭代）</li>
<li>合并链表问题：合并两个链表，合并 k 个链表</li>
<li>判断回文链表：使用额外数据结构，反转后半部分的链表再进行比较，使用后序遍历来比较（链表只存在前序和后序）</li>
</ul>
<h2 id="二叉树问题"><a href="#二叉树问题" class="headerlink" title="二叉树问题"></a>二叉树问题</h2><ul>
<li>二叉树遍历分为 BFS（层次遍历），DFS（前序，中序，后序遍历）</li>
<li>在解决二叉树的问题过程中，通常和其递归遍历框架存在关系，而在编写递归算法中，最关键的是要明确函数的定义是什么，然后使用这个递归推到最终结果，而不要跳入到递归的细节中去</li>
<li>递归解决二叉树问题：左右翻转二叉树，二叉树展开为链表（先序），填充每个节点的下一个右侧节点指针（注意不同父节点下的关系），将数组构建为最大二叉树，二叉树最大深度，判断是否存在根节点到叶节点路径总和等于目标值，统计二叉树中某条路径（不要求从根节点开始，到叶子节点结束）和为目标值的总的数目</li>
<li>使用前序－中序构造二叉树问题，使用后序－中序构造二叉树问题：关键点在于找到根结点，然后递归构建左右子树</li>
<li>二叉树的最近公共祖先：维护每个节点的父节点，或者是使用递归查找（注意结束条件）</li>
<li>二叉树的序列化和反序列化：使用前序遍历，后序遍历或者层次遍历，不过也需要记录空节点，不可仅仅使用中序遍历</li>
<li>寻找重复的子树：关键在于如何将二叉树序列化起来，然后和已经存在的二叉树进行比较，看看是否重复</li>
<li>二叉搜索树的中序遍历结果是有序的，可以解决：BST 第 K 小的元素，BST 转化为累加树</li>
<li>二叉搜索树的基本操作：删除，插入，搜索，验证 BST（记录当前树范围）</li>
<li>递归解决二叉搜索树问题：不同的二叉搜索树数量（节点值 1 到 n），不同的二叉搜索树所有种类（节点值 1 到 n）</li>
<li>二叉树中二叉搜索子树的最大键值和：使用后序遍历可以减少时间复杂度，因为当前节点所做的事情依赖于左右子树，涉及到 BST 的验证</li>
<li>扁平化嵌套列表迭代器：将其当做是一个多叉树进行遍历保存，使用懒加载模式</li>
<li>完全二叉树的节点数：考虑左右二叉树是否为满二叉树，分解问题，减少时间复杂度</li>
<li>恢复二叉搜索树：中序遍历有序性，找出两个交换的节点；使用莫里斯遍历</li>
<li>字典序的第 K 小数字：构建一个 10 叉树，根据 cur，next 变量统计当前统计过的数字，和 k 进行比较</li>
</ul>
<h2 id="图问题"><a href="#图问题" class="headerlink" title="图问题"></a>图问题</h2><ul>
<li>图中所有可能路径：涉及到图遍历框架，注意和回溯算法的区别，图遍历中 visited 不会重新被设置为 false</li>
<li>拓扑排序：使用 BFS 算法，构建入度数组，之后将入度为 0 的节点入队，使用 DFS 算法，后序遍历并且反转即为拓扑序</li>
<li>判断图中是否存在环：利用拓扑排序判断，或者是深度优先遍历，后者还可以获得当前的环节点</li>
<li>Dijkstra 算法：用于查找图中某个节点到其他所有节点的最短路径（不含有负权重），可使用优先队列实现贪心特性，实际上可以扩展成在图中求最值的算法，相关问题如网络延迟时间，概率最大的路径，最小体力消耗路径</li>
<li>找到最终的安全状态：找到所有路径通向终端节点的安全节点，可以使用深度优先搜索 + 三色标记法，也可以使用拓扑排序，先反转图，再使用入度统计信息</li>
</ul>
<h2 id="数组和字符串问题"><a href="#数组和字符串问题" class="headerlink" title="数组和字符串问题"></a>数组和字符串问题</h2><ul>
<li>田忌赛马算法决策：比不过的时候选择最差的元素进行比较，如优势洗牌</li>
<li>二分搜索模板：基本的二分搜索，寻找左侧边界的二分搜索，寻找右侧边界的二分搜索，使用闭区间需要注意索引溢出的问题</li>
<li>二分搜索推广：找到 x，f(x) 和 target，然后套用二分搜索模板即可，相关问题有珂珂吃香蕉，在 D 天内送达包裹的能力，分割数组的最大值，寻找两个正序数组的中位数</li>
<li>双指针技巧：快慢指针通常用于解决链表中的问题，如判定环形链表以及环的起始位置，寻找中点，倒数第 n 个元素；左右指针通常用于解决二分搜索，两数之和，反转数组，滑动窗口，寻找旋转排序数组中的最小值，通过删除字母匹配到字典里最长单词， 寻找峰值等算法</li>
<li>滑动窗口模板：维护一个窗口，不断滑动并且更新数据结构，相关问题如最小覆盖子串，字符串排列子串判定，找所有字母的异位词，最长无重复子串，长度最小的子数组，串联所有单词的子串（相同长度），最大连续 1 的个数，考试的最大困扰度</li>
<li>常数时间获取随机数问题：需要使用数组来存储数据，相关问题如常数时间插入、删除和获取随机元素，黑名单中的随机数等</li>
<li>单调栈使用技巧：不同字符的某个子序列，不同字符的最小子序列等</li>
<li>双指针技巧：删除排序数组中的重复项，删除排序链表中的重复元素，移除元素，移动零，合并区间，最长回文子串等</li>
<li>两数之和问题：借助哈希表或者排序实现，如找到和为 target 的两个数，TwoSum 数据结构设计，推广问题如三数之和，四数之和，以及 nSum 问题</li>
<li>数组前缀和技巧：寻找数组左右和相等的中心索引，杨辉三角II</li>
<li>二维数组相关：旋转矩阵，对角线遍历</li>
<li>整数转罗马数字：数组统计，再使用贪心算法</li>
<li>柱状图中最大的矩形：使用单调栈和哨兵，在弹出栈顶元素的时候已经可以得到左右边界，可以计算出来面积</li>
<li>最大矩形：先统计左边 1 的个数，再使用直方图面积法求解</li>
<li>课程表 III：给定 [dur, ddl]，求能修读的最大课程数目，使用贪心算法实现</li>
<li>最长重复子串：使用字符串哈希来检查相同的字符串是否存在，提高效率</li>
<li>寻找最近的回文数：给定一个数字，返回和其相差绝对值最小的回文数，附近回文数主要分为 5 类</li>
<li>最长连续序列：返回未排序数组中的最长连续序列的值，使用哈希表可以降低至 O(n)</li>
<li>下一个更大元素 III：给定一个数 n，返回其数字重排后下一个最小的大于 n 的数，通过逆序对解决</li>
<li>多数元素：给定数组，找出其中的出现次数超过 n &#x2F; k 的数目，可以使用投票法，分三类讨论</li>
<li>寻找重复数：在一个长度为 n + 1  的数组中，其元素都在 [1, n]，使用原地算法，可以通过索引负数标记</li>
<li>环形数组是否存在循环：在数组中判断是否存在循环，同样通过快慢指针解决</li>
<li>数组嵌套：在 [0..n-1] 中找到最大循环集合，注意只可能存在不相交的循环，因为每个元素都不相同</li>
<li>任务调度器：给定任务，在冷却期间不能运行相同任务，使用数学思想进行计算，关注最大执行次数的任务</li>
<li>在 LR 字符串中交换相邻字符：能否在 LR 规则下进行字符串转换，看源和目的字符串中 L 和 R 的位置即可</li>
<li>子数组按位或操作：返回可能或操作的结果数量，注意使用剪枝防止超时，整个数组或操作结果作为哨兵</li>
<li>漂亮数组：构造数组，使得不存在 num[j] * 2 &#x3D; num[i] + nums[k]，使用分治法</li>
<li>坏了的计算器：采用逆向思维，才能贪心地执行除法，从而得到最小的转移步数</li>
<li>优美的排列 II：n 个元素的数组，使得数组相邻元素之差只能存在 k 个不同值，考虑大小交错排列法</li>
<li>加油站：只需要从不能通过的地方重新开始测试即可</li>
<li>只出现一次的数字：其他数字重复出现多次，只有一个数字只出现一次，使用位统计方法</li>
<li>最大数：两个数据排序关系只需要看两个数组组成不同数字大小即可</li>
<li>Excel 表列名称：实际上是偏移为 [1..26] 的进制转换问题，每次取余前先自减取得偏移为 0 的数字即可</li>
<li>超级丑数：找到第 n 个丑数，丑数序列乘以质数列表还是丑数序列，可以采用多指针的方式解决</li>
<li>摆动排序 II：可以参考桶排序，来构造摆动数组</li>
<li>递增的三元子序列：通过记录最小和次小值，再判断是否存在数字大于次小值即可</li>
<li>水壶问题：可以使用模拟的方法来进行搜索，或者直接使用数学公式</li>
<li>消除游戏：可以考虑约瑟夫环例子推出最终结果</li>
<li>有序矩阵中第 K 小的元素：可以使用优先队列进行归并，也可以使用二分法</li>
<li>汉明距离总和：统计每个位上 1 的数目，再进行数学计算即可</li>
<li>日程表安排 II：可以使用差分数组，也可以使用线段树</li>
<li>132 模式：直接遍历会超时，可以考虑使用数据结构维护左右两边的数据信息，再进行一次遍历即可</li>
<li>替换后的最长重复字符：以每个字符作为结尾字符，满足最左边的索引，找到最大区间即可</li>
<li>重建序列：根据给定的子序列重新构建一个序列，使用拓扑排序即可</li>
<li>到达终点数字：问题可以转化为给定数字，添加正负号凑出目标值问题，根据差值进行判断</li>
</ul>
<h2 id="数据结构设计问题"><a href="#数据结构设计问题" class="headerlink" title="数据结构设计问题"></a>数据结构设计问题</h2><ul>
<li>并查集算法：解决图论中动态连通性的问题，优化技巧有增加秩，路径压缩，涉及到等价关系的算法可以考虑该数据结构，如等式方程的可满足性</li>
<li>LRU 缓存算法：按照访问顺序的淘汰策略，使用 LinkedHashMap 数据结构即可实现，注意其遍历顺序</li>
<li>LFU 缓存算法：按照访问频次的淘汰策略，如果最低访问频次有多个，淘汰最旧的数据，使用 HashMap，借助 LinkedHashSet 实现，注意其遍历顺序</li>
<li>最大频率栈：每次 pop 掉频率最大的数据，使用 HashMap 结构实现快速索引</li>
<li>数据流的中位数：使用两个优先级队列，并保持两个队列间数字的大小顺序</li>
<li>合并 k 个有序链表：使用优先级队列实现，如返回朋友圈前 10 条动态，第 K 个最小的素数分数</li>
<li>单调栈：指每次在 push 的时候，保持栈中的大小顺序，用于处理 Next Greater Element 问题，如下一个更大元素 I，下一个更大元素 II，每日温度等</li>
<li>单调队列：每次添加元素的时候，保持队列中的大小顺序，用于处理和滑动窗口相关的问题，如滑动窗口最大值</li>
<li>优先队列实现：使用二叉堆来实现，涉及到的操作主要有 sink，swim，offer 和 poll 方法，</li>
<li>栈实现队列和队列实现栈：双栈一个用于 offer，一个 用于 poll；队列将队头元素调整到队尾</li>
<li>找到处理最多请求的服务器：需要统计空闲服务器和处理器中的服务器，采用 TreeSet 和优先队列</li>
</ul>
<h2 id="动态规划问题"><a href="#动态规划问题" class="headerlink" title="动态规划问题"></a>动态规划问题</h2><ul>
<li>该类问题存在重叠子问题，具备最优子结构和状态转移方程，解决方案通常有带备忘录的递归（debug 时可以缩进查看调用栈），dp table 的迭代解法，注意迭代的方向需要根据已知的 dp 状态来确定，如零钱兑换 I，斐波拉契数列，下降路径最小和等</li>
<li>编辑距离：dp[m, n] 表示子串 s1[0..m] 和 s2[0..n] 的编辑距离，如果想要具体的编辑方案，可以加上对应的选择即可</li>
<li>最长递增子序列：dp[n]  表示将其当作最后一个数字时的最长递增子序列长度，使用 patience sorting 可以降低时间复杂度，推广问题有信封嵌套问题，需要注意其排序方法，最长等差子序列，需要注意超时</li>
<li>最大子序和：包含正负数，dp[n] 表示 num[n] 作为子序中的最后一个数，最大的子序和，而不是 nums[0..n] 中的最大子序和</li>
<li>最长公共子序列：使用 dp[m, n] 表示子串 s1[0..m] 和 s2[0..n] 中最长公共子序列的长度，相关问题有两个字符串的删除操作，两个字符串的最小 ASCII 删除和等</li>
<li>最长回文子序列：在子串 s[i..j] 中，最长回文子序列的长度为 dp[i, j]，然后迭代即可，由于回文子序列特殊性，也可以转化为最长公共子序列问题</li>
<li>0-1 背包问题：对于前 i 个物品，当前背包的容量为 w，这种情况下可以装的最大价值是  dp[i, w]，迭代即可，相关问题有分割等和子集</li>
<li>完全背包问题：物品的个数是无限的，通常涉及到将背包刚好填满的情况，相关问题如零钱兑换 II，注意其和爬楼梯算法的区别，前者求组合数，后者求排列数</li>
<li>区间调度问题：选择出来不重叠的区间的最大的个数，贪心算法需要选择 end 最小的，相关问题如无重叠区间，用最少数量的箭引爆气球</li>
<li>视频拼接问题：需要注意排序的方案，start 升序排列，start 相同则按照 end 降序排列</li>
<li>跳跃游戏：跳跃游戏 I 需要找到每次跳跃的最大距离，作为下一次的跳跃起点，跳跃游戏 II 同样道理，注意判定每次增加步数的逻辑，两者也可以使用动态规划来解决</li>
<li>最小路径和问题：dp[i, j] 表示 nums[i, j] 到 nums[0, 0] 的最小路径和</li>
<li>地下城游戏：dp[i, j] 表示从位置 [i, j] 出发，到达 [m, n] 的最少血量，注意其和最小路径和问题的对比</li>
<li>自由之路：dp[i, j] 表示指向 ring[i]，需要输入 key[j..n] 的最小的操作次数</li>
<li>K 站中转内最便宜的航班：dp[i, j] 表示经过最多 i 次中转，到达 j 的最便宜的航班</li>
<li>正则表达式匹配：dp(i, j) 表示 s[i..] 能否被 p[j..] 匹配，使用递归；或者 dp[i, j] 表示 s[0..i] 能否被 p[0..j] 匹配，使用迭代；简单的变体是通配符匹配问题</li>
<li>鸡蛋掉落：使用 dp(k, n) 表示从 n 层楼中，使用 k 个鸡蛋，确定 f 的最小确切尝试次数，或者可以使用 dp[k, m] 表示 k 个鸡蛋，最多 m 次操作可以确定 f 的最高的层数，使用迭代解决</li>
<li>戳气球：使用 dp[i, j] 表示开区间 (i, j) 内能得到的最大分数，通过最后一步思考状态转移方程</li>
<li>博弈问题：预测赢家问题中每个人从两端选择数字，最终数字和大的获胜，使用 dp[i, j] 表示从 nums[i, j] 中选择时的情况，dp[i, j, 0] 表示先手分数情况，dp[i, j, 1] 表示后手分数情况，相关问题有石子游戏</li>
<li>两键键盘：输出 n 个字符最少的操作次数，另外也可以考虑分解质因数方法</li>
<li>四键键盘：N 次操作输出 A 的最多的个数，考虑最后的一次操作，不是 A，就是 C-V，以此作为递推式</li>
<li>股票买卖问题：定义 dp[n, k, 0] 表示在第 n 天，最多 k 次交易，未持有股票的最大收益，而 dp[n, k, 1] 表示在第 n 天，最多 k 次交易，持有股票的最大收益，找到状态转换关系，使用迭代即可解决，注意一些问题也可以使用贪心算法解决</li>
<li>打家劫舍问题：dp[i] 表示 num[i..] 开始，能获得的最大价值，变体如增加首尾限制，二叉树限制等</li>
<li>字符匹配算法：使用 <code>dp[i, j] = next</code> 表示当前状态 i，遇到字符 j 后下一个状态是 next，以此为状态机，来进行匹配，第一次相当于 pat 与 pat[1..] 匹配，第二次相当于 pat 与 text[0..n] 匹配；也可以使用 KMP 算法，使用 next 数组表示最大相同真前后缀的前缀末尾索引</li>
<li>构造回文的最小插入次数：dp[i, j] 的表示对字符串 s[i..j]，最少需要进行 dp[i, j] 次插入才能变成回文串，注意状态转换关系</li>
<li>IPO：使用贪心算法，每次选择能投资项目中的最大利润</li>
<li>不含连续 1 的非负整数：定义 dp[i] 为长度为 i 的有效数字的个数，然后对每位进行操作统计</li>
<li>解码方法 II：定义 dp[i] 表示 str[i..n] 可被解码方法的数目，找到递推关系即可</li>
<li>超级洗衣机：使用贪心算法，考虑左右两组传递次数和某一个洗衣机最大传递次数</li>
<li>k 个逆序对数组个数：定义 dp[i, j] 为 1 - i 自然数中，j 个逆序对的个数，分析数字 i 的位置</li>
<li>恰有 K 根木棍可以看到的排列数目：定义 dp[i, j] 表示 i 根木棍中可以看到 j 个木棍，分析长度为 1 的木棍所在位置</li>
<li>猜数字大小 II：定义 dp[i, j] 表示从范围 [i, j] 猜数字的最小的代价，从而可构造转移方程</li>
<li>交错字符串：定义 dp[i, j] 表示 s1[0, i) 和 s2[0, j) 是否能构成 s3[0, i+j)，从而构建转移方程</li>
<li>三个无重叠子数组的最大和：定义 dp[i,k] 表示 nums[0..i] 构成 k 个不重叠子数组最大和值，考虑 nums[i] 是否在里面，从而构造转移方程</li>
<li>不同的子序列：定义 dp[i, j] 表示 s[i..] 中含有 t[j..] 子序列个数，构造对应的转移方程</li>
<li>最低加油次数：给定加油站和初始油量，判断最少需要加多少次油才能到达目的地，使用贪心</li>
<li>最后一块石头的重量 II：两块石头重量的差值当作新的石头放入其中，转换为 0-1 背包问题</li>
<li>一和零：使用背包问题，dp[i, j, k] 表示前 i 个字符串里面，最大 j 个 0，k 个 1 的子集长度</li>
<li>环绕字符串中唯一的子字符串：通过考虑以某字符结尾的最大长度，就可以计算出来不同子串的长度</li>
<li>我能赢吗：博奕类问题，每一步遍历当前所有选择看是否会导致赢的结果</li>
<li>设置交集大小至少为 2：区间排序，按照首点升序，尾点降序进行排列，每次贪心选择区间前两个元素</li>
<li>新 21 点：定义 dp[x] 为起始分数为 x 时获胜概率，得到转移方程</li>
</ul>
<h2 id="回溯算法（DFS-算法）"><a href="#回溯算法（DFS-算法）" class="headerlink" title="回溯算法（DFS 算法）"></a>回溯算法（DFS 算法）</h2><ul>
<li>回溯算法和动态规划递归算法类似，不过不同的是回溯算法不存在重叠子问题，回溯算法的核心就是做选择，回溯，撤销选择，相关问题如全排列，n 皇后，数独问题，全排列 II（重复数字）</li>
<li>集合划分：使用两种视角，桶的视角即为每次刚好填满一个桶，站在数字的视角，即为每次进入一个桶，两种算法通过剪枝可以减少运行时间</li>
<li>子集，组合和排列问题：子集和组合问题都是从当前位置的下个位置开始回溯，但是排列问题不同，另外可以考虑递归思路</li>
<li>括号生成：合法括号对性质，在回溯中添加左右括号剩余数量（有效信息）</li>
<li>单词搜索 II：在二维棋盘中找到某个单词是否存在，注意剪枝以防超时</li>
<li>祖玛游戏：为了提高效率，可以使用剪枝或者使用备忘录来检测已经判断过的字符串</li>
<li>字典序排序：使用 DFS 可以进行搜索排序，使用迭代可以得到 O(1) 空间复杂度</li>
<li>火柴拼正方形：每个位置可以选择放入四个边中之一，只要满足其边长不会超过总长度的四分之一即可</li>
</ul>
<h2 id="BFS-算法"><a href="#BFS-算法" class="headerlink" title="BFS 算法"></a>BFS 算法</h2><ul>
<li>BFS 用于找寻最短路径一类的问题，主要通过队列和设置 <code>visited</code> 集合来解决，可采取的优化如双向 BFS 搜索，相关问题如打开转盘锁，二叉树的最小深度等问题</li>
<li>滑动拼图：将二维数组变为字符串处理，同时利用已知信息建立邻居映射</li>
<li>单词接龙 II：使用 BFS 查找最短路径，可以采用双端 BFS 优化，使用 DFS 构造路径</li>
<li>最小高度树：使用拓扑排序思想，将入度为 1 的数字放到队列中去，然后进行 BFS 即可</li>
</ul>
<h2 id="并查集算法"><a href="#并查集算法" class="headerlink" title="并查集算法"></a>并查集算法</h2><ul>
<li>除法求值：给定一组除法式子，判断给定查询的结果，使用并查集可以让有倍数关系的变量在一起</li>
</ul>
<h2 id="数学运算技巧"><a href="#数学运算技巧" class="headerlink" title="数学运算技巧"></a>数学运算技巧</h2><ul>
<li>常用的位操作：使用异或判断两个数字是否异号，使用异或交换两个数字，使用 <code>n &amp; (n - 1)</code> 消除数字 n 的二进制表示中的最后一个 1，相关问题如汉明重量，判断是否为 2 的指数，查找只出现一次的元素，两数之和</li>
<li>阶乘算法题：阶乘后零的个数取决于因子 5 的个数，相关问题有阶乘后的零的个数，阶乘后 k 个零</li>
<li>高效寻找素数：在进行因子判断的时候，只需要遍历到  <code>sqrt(x)</code> 即可，相关问题如计算质数的个数，注意两层循环的起始和终止条件</li>
<li>高效模幂运算：使用递归处理数组指数，模运算的防溢出运算，高效求幂，相关问题如超级次方</li>
<li>寻找缺失元素：情况一是 [0, n] 的序列放到长度为 n 的数组中，情况二是 [1, n] 的序列放到长度为 n 的数组中</li>
<li>同时寻找缺失和重复的元素：使用映射来表示某个数字已经存在，通常这样的问题需要索引和数字一起使用</li>
<li>水塘抽样算法：对于第 i 个元素，应该有 <code>1/i</code> 的概率选择该元素，<code>1 - 1/i</code> 的概率保持原有的选择，可以推广到随即抽取 k 个元素，相关问题如链表随机节点，随机数索引</li>
<li>一行代码解决的问题：Nim 游戏，石子游戏，电灯开关问题（因数个数问题）</li>
<li>反直觉概率问题：男孩女孩问题，生日悖论，三门问题（概率浓缩）</li>
<li>洗牌算法：Fisher-Yates 算法每次迭代模拟了从剩余数字中选择一个放到对应位置上的过程，相关问题如打乱数组</li>
<li>随机数生成问题：基于 <code>(rand(X) - 1) * Y + rand(Y)</code>可以均匀生成 [1, XY] 之内的随机数，随后使用拒绝采样挑选随机数</li>
<li>可怜的小猪：小猪试毒问题改编而来，在给定 n 只小猪，m 次尝试时，每只猪提供的信息是 m + 1 次，整个的信息个数就是 pow(m + 1, n)</li>
<li>数组中两个数的最大异或值：从高位到低位依次选择，利用异或运算的特殊性，三数之间两数异或等于第三个数，一步步向下迭代求解</li>
<li>不可能得到的最短骰子序列：上一个出现的序列后面的子数组应包含所有的数字，否则不能构造对应的子序列</li>
</ul>
<h2 id="其他算法技巧"><a href="#其他算法技巧" class="headerlink" title="其他算法技巧"></a>其他算法技巧</h2><ul>
<li>前缀和数组：适用于原始数组不变，频繁查询某个区间的累加和，相关问题如和为 k 的连续子数组个数，使用前缀和与哈希表解决，思想和 twoSum 类似</li>
<li>差分数组：主要用于频繁对原始数组的某个区间的元素进行加减，对区间 [i, j] 的修改实际上只需要修改 diff 数组的两个元素即可，相关问题如航班预订统计，得分最高的最小轮调</li>
<li>快速选择算法：存在于快速排序算法中，每次 partition 都会使得左边的数字小，右边的数字大，相关问题如数组中的第 k 个最大元素</li>
<li>分治思路：归并排序，分而治之，相关问题如为运算表达式设计优先级</li>
<li>区间问题：关键在于排序，以及判断两个区间相交与否，相关问题如删除被覆盖区间，区间合并，区间列表的交集，两个矩形覆盖的面积</li>
<li>使用哈希表：使用哈希表可以快速统计相同位置上出现的次数，相关问题如回旋镖的数量，将数据流变为多个不相交的区间，随机翻转矩阵，缺失的第一个正整数（O(n)）</li>
<li>排除法：搜索名人</li>
</ul>
<h2 id="高频面试算法"><a href="#高频面试算法" class="headerlink" title="高频面试算法"></a>高频面试算法</h2><ul>
<li>分割数组为连续子序列：使用两个哈希表，分别统计出现次数和能在结尾放置的次数，优先放在上个序列的结尾</li>
<li>吃葡萄：将问题转化为三角形边长平分问题，并分析极端情况</li>
<li>烧饼排序算法：使用递归，首先让最大烧饼在最底层，类似于汉罗塔问题</li>
<li>字符串相乘：模拟乘法运算过程，注意参与乘法运算两个数的索引和结果索引间的关系</li>
<li>实现一个计算器：先解决加减，后解决乘除，最后考虑括号，使用单栈方法和双栈方法</li>
<li>接雨水问题：考虑当前节点能接的水是多少，从而解决问题，可以对状态进行优化，相关问题如一维数组接雨水，二维数组接雨水</li>
<li>寻找最长回文子串：关键在于奇数长度和偶数长度的回文子串的判定</li>
<li>括号相关问题：使用栈结构进行模拟，匹配问题则找到需要的右括号的数量，相关问题如判断合法括号串，使括号有效的最小插入及变体（一个左括号匹配两个右括号），有效的括号字符串（加入 <code>*</code>），最长有效括号</li>
<li>判定完美矩形：利用面积和顶点出现次数作为判别条件</li>
<li>考场就座：最大化学生之间的间隔，使用 TreeSet 作为数据结构，按照 distance 排序，需要处理边界情况</li>
<li>高效判定子序列：使用双指针可以解决该问题，但是如果需要匹配的子序列比较多的时候，可以结合二分查找提高效率</li>
</ul>
<h2 id="Java-编程知识点"><a href="#Java-编程知识点" class="headerlink" title="Java 编程知识点"></a>Java 编程知识点</h2><ul>
<li>IntegerCache：在自动装箱时，为了提高性能，Java 缓存了 [-128, 127] 的整形值引用，因此，当我们比较两个 Integer 的时候，应该使用 equals 方法，或者借助 intValue 方法，而不是 <code>==</code></li>
<li>random.nextInt() 和 nextInt(upperBound)：不加参数的话，int 类型 32 位都会随机 0 或者 1，可能会产生负数，使用取模可能会产生负数，加参数的话返回 [0, upperBound) 之间的整型</li>
<li>在 Java 中使用 int[] 作为 HashMap 的键并不会得到想要的结果，因为其会使用 int[] 的索引作为 hashcode，可以使用 <code>List&lt;Integer&gt;</code> 或者重写一个类，该类重新实现 hashcode 和 equals 算法，亦或直接使用 TreeMap</li>
<li>Object.hashCode 是一个实例方法，不允许 null；Objects.hashCode(obj) 是静态方法，允许 obj 为 null；Objects.hash(obj…) 也是静态方法，接受多个参数，返回所有参数的总的哈希值</li>
<li>Integer.valueOf() 和 Integer.parseInt() 两者都是对字符串进行解析，不过它们的返回值类型不同，前者是 Integer，后者是 int</li>
<li><code>List&lt;Integer&gt;</code> 到 <code>int[]</code> 类型的转换不能直接使用 toArray，可以借助流：<code>list.stream().mapToInt(Integer.intValue).toArray()</code></li>
<li>想要对自定义类实现排序，要么实现 <code>Comparable&lt;T&gt;</code> 接口，重写 <code>compareTo</code> 方法，或者是排序的时候传入一个 <code>Comparator&lt;T&gt;</code> 对象，重写 <code>compare</code> 方法</li>
<li>想要对 <code>int[]</code> 类型进行降序排序，不能直接用 <code>Arrays.sort</code>，其只对 <code>T[]</code> 提供自定义比较器，可以使用流操作来实现：<code>Arrays.stream(arr).boxed().sorted((a, b) -&gt; b - a).mapToInt(Integer::intValue).toArray()</code></li>
<li>在 Java 设计中 Stack 继承自 Vector，这是一种错误的设计，应该使用组合而不是继承关系。官方推荐写法：<code>Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;()</code></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://zsstrike.github.io">zsStrike</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://zsstrike.github.io/2021/07/12/LeetCode-Rush/">http://zsstrike.github.io/2021/07/12/LeetCode-Rush/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://zsstrike.github.io" target="_blank">zsStrike</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Algorithm/">Algorithm</a></div><div class="post_share"><div class="social-share" data-image="/assets/default_cover.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/assets/avatar.jpg" onerror="this.onerror=null;this.src='/assets/default_cover.png'" alt="avatar"/></div><div class="author-info__name">zsStrike</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">43</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zsStrike"><i class="fab fa-github"></i><span>Github</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E9%97%AE%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">链表问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%97%AE%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">二叉树问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E9%97%AE%E9%A2%98"><span class="toc-number">3.</span> <span class="toc-text">图问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%97%AE%E9%A2%98"><span class="toc-number">4.</span> <span class="toc-text">数组和字符串问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%97%AE%E9%A2%98"><span class="toc-number">5.</span> <span class="toc-text">数据结构设计问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98"><span class="toc-number">6.</span> <span class="toc-text">动态规划问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%EF%BC%88DFS-%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-number">7.</span> <span class="toc-text">回溯算法（DFS 算法）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BFS-%E7%AE%97%E6%B3%95"><span class="toc-number">8.</span> <span class="toc-text">BFS 算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-number">9.</span> <span class="toc-text">并查集算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7"><span class="toc-number">10.</span> <span class="toc-text">数学运算技巧</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A7"><span class="toc-number">11.</span> <span class="toc-text">其他算法技巧</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95"><span class="toc-number">12.</span> <span class="toc-text">高频面试算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E7%BC%96%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">13.</span> <span class="toc-text">Java 编程知识点</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2017 - 2022 By zsStrike</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5/instantpage.min.js" type="module"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>