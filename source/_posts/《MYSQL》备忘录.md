---
title: 《MYSQL》备忘录
date: 2022-03-02 14:17:22
tags: ["MySQL"]
---



用于整理 MySQL 的相关知识，以备查询。

<!-- More -->



## 01 MySQL 概览

存储引擎：

+ InnoDB：支持事务，支持行级锁，支持外键，采用 MVCC 支持高并发，支持四个隔离级别
+ MyISAM：不支持事务，只支持表锁，支持压缩表和空间数据索引，数据恢复困难

索引数据结构：

+ AVL 树：左右子树树高相差不超过 1 的平衡二叉树，插入和删除会引入旋转操作，适合查找多的场景
+ 红黑树：确保没有一条路径会比其他路径长 2 倍，近似平衡，适合插入删除操作多的场景
+ 跳表：平均性能和红黑树相当，但实现更为简单
+ B 树：多路查找树，中间节点也会携带实际数据
+ B+ 树：多路查找树，只有叶子节点才会携带实际数据，查询性能稳定

B+ 树和红黑树比较：

+ B+ 树一个节点可以存储多个元素，相较于红黑树树高更低，磁盘 IO 次数小
+ 磁盘预读功能对 B+ 树产生优化功能

B+ 树和 B 树比较：

+ B+ 树磁盘 IO 更低，其内部节点全部是指针，没有实际数据，能够更快找到元素
+ B+ 树查询效率更加稳定
+ B+ 树遍历效率高

MySQL 索引：在存储层实现，不同的存储引擎具有不同的索引类型

+ B+ 树索引：主索引通常是聚簇索引，辅助索引通常需要回表，覆盖索引，组合索引
+ 哈希索引：只支持点查询，不支持范围查询，同时不支持排序和分组操作
+ 全文索引：用于查找文本中的关键词，通常采用倒排索引实现
+ 空间数据索引（R-Tree）：多维索引，可用于存储地理数据

索引优化：

+ 独立的列：查询条件中，索引列不能是表达式的一部分
+ 多列索引：比单列索引更好
+ 索引列顺序：让选择性强的索引放在前面
+ 前缀索引
+ 覆盖索引：索引包含所有需要查询的字段的值，不需要进行回表操作

查询语句分析：使用 explain 进行分析，其结果参数

+ select_type：常用的有 SIMPLE 简单查询，UNION 联合查询，SUBQUERY 子查询
+ possible_keys：可选择的索引
+ key：实际使用的索引
+ rows：扫描的行数
+ type：关联类型，决定通过什么方式找到每一行数据
  + system：只有一条数据的系统表
  + const：主键或者唯一查询
  + eq_ref：在进行联接查询的，使用主键或者唯一索引并且只匹配到一行记录的时候
  + ref：使用非唯一索引
  + range：范围查询
  + index：跟全表扫描类似，只是扫表是按照索引顺序进行
  + all：全表扫描，不走索引

查询语句优化：

+ 减少请求的数据量，只返回必要的行数据和列数据
+ 减少服务器扫描的行数，尽量通过覆盖索引
+ 重构查询语句：切分大查询，分解大连接查询，将连接任务交给上层

事务：

+ 特性：ACID
+ 隔离级别：未提交读，提交读，可重复读，可串行化，快照
+ 非一致性问题：脏读，不可重复读，幻读，丢失更新

并发控制：

+ 锁：共享锁，排他锁，意向共享锁，意向排他锁
+ 锁粒度：
  + Record Lock：锁定一个记录对应的索引，而不是本身
  + Gap Lock：锁定索引之间的间隙，但是不包含索引本身
  + Next-Key Lock：左开右闭区间，Gap Lock + Record Lock
+ MVCC：在每个记录后面加上两个隐藏的列，记录创建版本号和删除版本号，通过 undo 日志串联版本
  + 快照读：读取历史数据
  + 当前读：读取数据库当前版本数据，可以通过加锁 `lock in share mode，for update` 实现

分库分表数据切分：水平切分（Sharding）和垂直切分

水平切分：

+ 策略：哈希取模，范围划分，映射表
+ 问题：
  + 事务问题：改为分布式事务
  + 连接：多个单表查询，在用户程序中连接
  + 唯一性：使用全局唯一 GUID

MySQL 集群：

+ 主从复制：主要涉及三个线程，binglog 线程，IO 线程和 SQL 线程
+ 读写分离：主服务器处理实时性要求高的读写操作，从服务器处理读操作，可以减轻主服务器的负载

关系数据库设计范式：

+ 1NF：每个属性不可分割，可能存在数据冗余问题
+ 2NF：消除非主属性对码的部分函数依赖
+ 3NF：消除非主属性对于码的传递函数依赖，基本消除了各种异常
+ BCNF：主属性不依赖于主属性
+ 4NF：消除多值依赖



## 02 MySQL 索引

索引的优缺点：

+ 优势：
  + 可以提高数据检索的速度，降低 IO 成本
  + 索引还能对数据进行排序，降低排序查询语句的执行时间
+ 劣势：
  + 索引本身会占用部分空间
  + 索引虽然提高了查询效率，但是降低了数据更新的效率，因为更新数据的同时需要更新数据

索引类型：主键索引，普通索引（辅助索引），唯一索引，全文索引，空间索引，前缀索引，单列索引，联合索引，聚簇索引

索引的数据结构：

+ Hash 表：单点查询性能好，但是不支持范围查询
+ 平衡二叉树：查询性能良好，但是树高太大，IO 次数多
+ B 树：改造二叉树，每个节点上有多个数据项，同时对应多个分支，中间节点上可以存储数据
+ B+ 树：只有叶子节点上存在数据，中间节点只有索引和节点值，进一步降低查找时的 IO 开销

MyISAM 索引：索引和数据分开存储在不同的文件中，叶子节点记录的是磁盘地址

InnoDB 索引：叶子节点存储的数据是整行的数据，称之为聚簇索引，为此，普通索引需要进行回表操作

覆盖索引：在使用辅助索引的时候，需要经过回表操作才能拿到整行数据，可以创建组合索引避免回表

优化：

+ 避免回表：使用覆盖索引
+ 正确使用联合索引，遵循最左匹配原则



## 03 组合索引的特殊情况

假设存在表 t(a, b, c, d)，其中以 a 创建主键索引，以 (b, c, d) 创建组合索引，语句 `select * from t where c = 0` 执行过程中，有以下问题：

+ 上述条件查询并不满足最左匹配原则，为什么查询的时候使用了索引？

  答：联合索引中有查询需要所有数据项，可以使用覆盖索引，但是其并不满足最左匹配，因此 type 是 index，而不是 ref，同时，组合索引中叶子节点信息量更大，主索引通常还包括了版本信息，事务 id，回流指针等等，因此选择组合索引

+ 为这个表增加 e 字段后，上述查询为什么变为全表扫描？

  答：加入 e 字段后，就不能使用覆盖索引了，此时就只能进行全表扫描



## 04 慢 SQL 查询语句

SQL 语句执行流程：

+ 连接器：服务器进行账户检查，权限检查等操作
+ 缓存层
+ 词法语法分析，检查 SQL 正确性
+ 优化器找到最佳物理执行计划
+ 调用存储引擎的相关接口进行查询，并返回结果

InnoDB 存储引擎：

+ 磁盘预读机制：当引擎访问某个数据项的时候，通常其相邻的数据页也会被加载到内存
+ 索引：InnoDB 主索引采用的是聚簇索引，如果没有唯一且非空的键则会隐式创建一个自增的列

慢 SQL 危害：在高并发情况下，慢 SQL 出现后会阻塞大量正常的请求，造成大面积的超时和失败

慢 SQL 原因：

+ 索引创建方面：
  + 索引区分度低
  + 切忌过多创建索引，其会大幅降低更新操作的效率
  + 常用查询，排序，分组字段建索引
  + 主键和外键建索引
+ 索引失效方面：
  + 对索引使用函数
  + 对索引进行运算
  + 对索引使用 <> 、not in 、not exist、!=
  + 对索引进行前导模糊查询
  + 隐式转换会导致不走索引
  + 非索引字段的 or 连接
  + 非最左前缀

预防慢 SQL 方案：

+ 使用连接代替子查询
+ 使用覆盖索引
+ 多表关联查询时，小表在前，大表在后
+ 调整 where 子句中的连接顺序
+ 使用联合索引，而非建立多个单独索引

慢 SQL 分析：打开慢 SQL 日志，设置慢 SQL 执行时间阈值，之后使用 explain 命令查看原因



## 05 分页场景

假设存在表 t_record(id, age, name)，id 上存在主索引，age 上存在辅助索引，下列语句

```sql
select * from t_record where age > 10 offset 10000 limit 10;
```

在第一次执行的时候很慢，在第二次有了缓存之后，才会变快。

对于 MySQL，上述语句会使用 age 上的索引，首先找到满足 age > 10 的第一个数据，然后向后遍历 10000 项数据，并且对每一项数据，都会进行回表操作，即使我们不需要这些数据。这样的话引入了大量的随机 IO，自然速度变慢。

分页性能问题优化：

+ 产品上绕过，只提供上一页和下一页功能不需要回表，并且没有 offset

  ```sql
  select * from t_record where id > last_id  limit 10;
  ```

+ 使用覆盖索引：不需要进行额外的回表操作

  ```sql
  select * from t_record id in
  (select id from t_record where age > 10 offset 10000 limit 10）;
  ```



## 06 MySQL 事务隔离性实现

事务特性：ACID

InnoDB 保证事务特性：

+ 原子性和持久性是通过 redo log （重做日志）来保证的
+ 一致性是通过 undo log（回滚日志） 来保证的
+ 隔离性是通过 MVCC（多版本并发控制） 和锁机制来保证的

并行事务引发的问题：丢失更新，脏读，不可重复读，幻读

事务隔离性级别：未提交读，提交读，可重复读，串行化，快照隔离

InnoDB 保证事务隔离级别：

+ 未提交读：直接读取最新的数据
+ 串行化：加读写锁实现
+ 读提交和可重复读：通过 Read View 实现，读提交在每次读数据前生成一个 Read View，可重复读则在启动事务时生成一个 Read View，在之后都使用该 Read View

MVCC 实现：在每个记录后面还增加了两个隐藏列，trx_id 和 roll_pointer，后者指向旧版本记录

Read View 数据结构：

![图片](《MYSQL》备忘录/640-16462283919542.png)

可重复读：遍历记录版本，直到找到 trx_id 小于等于 creator_trx_id 的记录

读提交：遍历记录版本，直到找到 trx_id 小于 max_trx_id，并且其不在 m_ids 列表中的记录



## 07 幻读的处理

在可重复隔离级别下，普通的查询语句是快照读，其是不会看到别的事务插入的数据的，幻读的现象只能在当前读下产生。

InnoDB 为了防止该问题，采用了 next-key 锁，下面的事务 A 会锁住 `(2, +inf)` 范围的记录，如果该期间有其他事务在这个锁住的范围插入数据就会被阻塞，从而解决了幻读现象。

![图片](《MYSQL》备忘录/640-16462307083174.png)

next-key 锁锁的是索引，而不是数据本身，如果 update 语句的 where 条件没有使用索引列，那么就会全表扫描，不仅加上行锁，还加上了间隙锁，相当于锁住整个表，直到事务结束时释放。因此，在线上千万不要执行没有带索引条件的 update 语句，不然会造成业务停滞。



## 08 MySQL 中的锁

全局锁：

+ 使用方法：`flush tables with read lock` 和 `unlock tables` 加锁和解锁，加锁后整个数据库就只处于只读状态，会阻塞其他线程对表的结构和数据的更改
+ 应用场景：全库逻辑备份，通常在不支持 MVCC 的引擎中使用，而对于像 InnoDB 引擎，可以在 mysqldump 时加上 `-single-transaction` 就能保证数据一致性
+ 缺点：整个数据库只读状态，可能会造成业务停滞

表级锁：

+ 表锁：`lock tables t_name read/write`，其会限制本线程和其他线程的读写操作

+ 元数据锁（MDL）：不需要显式使用 MDL，其根据如下规则加锁：

  + 对一张表进行 CRUD 操作时，加的是 MDL 读锁
  + 对一张表做结构变更操作的时候，加的是 MDL 写锁

  MDL 在事务提交后才会释放，另外，MDL 写锁获取的优先级高于读锁

+ 意向锁：加锁规则如下：

  + 在对某些记录加上共享锁之前，需要先在表级别加上一个意向共享锁
  + 在对某些纪录加上独占锁之前，需要先在表级别加上一个意向独占锁

  注意，普通的 select 是不会加锁的，因为其是利用 MVCC 实现，可以通过 `lock in share mode` 实现，意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁和独占表锁发生冲突，意向锁的目的是快速判断表里是否有记录被加锁

+ AUTO-INC 锁：该锁在执行完插入语句后就会释放，MySQL 5.2 后的版本提供了轻量级的锁，但是其在并发插入的时候，不能保证自增长的值是连续的，这在主从赋值的场景中是不安全的

行级锁：InnoDB 才有，MyISAM 并没有行锁

+ 记录锁：锁住一条记录
+ 间隙锁：锁定一个范围
+ Next-Key Lock：记录锁和间隙锁的组合，用左开右闭区间表示，是加锁的基本单位，但是可能会退化



## 09 MySQL 加锁规则

唯一索引等值查询：

+ 查询的记录存在：退化成记录锁
+ 查询的记录不存在：退化成间隙锁

唯一索引范围查询：首先找到 min 对应的 next-key lock，如果 min 存在，退化成记录锁；最后找到 max 对应的 next-key lock，如果 max 不存在，退化成间隙锁

非唯一索引等值查询：

+ 查询的记录存在：先加 next-key lock， 另外一把锁退化成间隙锁
+ 查询的记录不存在：退化成间隙锁

非唯一索引范围查询：next-key lock 不会退化



## 10 update 语句

当执行 update 语句的时候，如果没有带上索引，可能会走全表扫描，从而导致全表加上了独占锁，导致业务停滞，通常可以使用以下方法避免该情况：

+ 开启安全更新模式，`sql_safe_update` 参数设置为 1，此时需要 update 有 where 或者 limit 子句
+ 如果带上索引，但是优化器选择走全表扫描，可以使用 force index 语句



## 11 索引失效

索引失效的情况：

+ 对索引使用左或者左右模糊匹配
+ 对索引使用函数：MySQL 8.0 以后可以使用函数索引
+ 对索引进行表达式计算
+ 对索引隐式类型转换：在遇到字符串和数字比较的时候，会先把字符串转为数字，然后再进行比较
+ 联合索引非最左匹配：(a, b, c) 组合索引，`where a = 6 and c = 8`，MySQL 5.6 之前版本会回表比较，而 之后的版本使用索引下推优化
+ WHERE 子句中的 OR



## 12 

















