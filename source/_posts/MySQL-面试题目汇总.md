---
title: MySQL 面试题目汇总
date: 2023-02-04 12:05:45
tags: ["MySQL"]
---





本文整理了 MySQL 的相关问题，以便更深入掌握 MySQL。

<!-- More -->



1. SQL 语句分类？

   主要分为三类，DDL，DML 和 DCL。

2. 内连接和外连接的区别？

   内连接只包含符合条件的元组，外连接则还包含了哪些不符合条件的元组。

3. 内连接中自然连接和等值连接的区别？

   自然连接会去除相同列，等值连接则不会。

4. Union 和 Union All 的区别？

   前者是集合并，后者是包并，后者执行速度更快。

5. MySQL 数值类型有哪些？

   TINYINT，SMALLINT，MEDIUMINT，INT，BIGINT，FLOAT，DOUBLE，DECIMAL。

6. DECIMAL（20，9）需要多少字节表示其数值部分？

   DECIMAL 采用四字节存储 9 位数字的方式进行存储，小数部分需要 4 字节，整数部分共 11 位，低 9 位 4 字节，高 3 位需要 2 字节，一共需要 4 + 4 + 2 = 10 字节。DECIMAL 负数存储只需要将每个字节取反即可。

7. INT(5) 和 INT 区别？

   表示数据上没有什么不同，INT(5) 在展示小于 5 位的数字时，会进行空格填充，并且依旧能够显示大于 5 位的整数。

8. MySQL 日期类型有哪些？

   DATE，TIME，YEAR，DATETIME，TIMESTAMP。

9. 在 MySQL 5.6 之前，为什么 DATE，TIME 各自需要 3 个字节，而 DATETIME 需要 8 个字节？

   DATE/TIME 是转换到对应天或者秒来计算的，只需要 3 个字节足矣；而 DATETIME 中 DATE 保存方式是 YYYY×10000 + MM×100 + DD，需要四字节，时间整数表示 HH×10000000 + MM×100000 + SS * 1000，同样四字节。

10. MySQL 中的字符串/字节串类型？

    CHAR，VARCHAR，TINYTEXT，TEXT，MEDIUMTEXT，LONGTEXT，TINYBLOB，BLOB，MEDIUMBLOB，LONGBLOB。

11. char(n) 和 varchar(n) 的区别？

    前者表示定长，数据长度不够时会补空格填充，后者则是变长，严格存储对应长度的字符串，还会记录 1 或 2 个字节的长度值。

12. MySQL 复合类型有哪些？

    ENUM 和 SET。ENUM 规定数据只能在枚举值中，并且存储上按照整数存储，因此 enum('male', 'female') 中的 male 实际存储的是 1，female 实际存储的是 2，`''` 空字符串存储 0，`NULL` 将被定义为 NULL。SET 则是定义集合，会自动去除重复值。

13. MySQL 中如何获取 DATETIME 类型对应的 DATE？

    可以通过 date_format(datetime, '%Y-%m-%d') 获取对应的字符串，然后通过 str_to_date 即可。

14. MySQL 有哪些存储引擎（表类型），各自的优缺点分别是什么？

    + MyISAM：不支持事务、也不支持外键，其优势是访问的速度快，对事务完整性没有要求或者以 SELECT、INSERT 为主的应用基本上都可以使用这个引擎创建表
    + InnoDB：提供了具有提交、回滚和崩溃恢复能力的事务安全，锁粒度可以达到行级锁。但是对比MyISAM 的存储引擎，InnoDB 写的处理效率差一些，并且会占用更多的磁盘空间以保留数据和索引
    + MEMORY：使用存在于内存中的内容来创建表。每个MEMORY 表只实际对应一个磁盘文件，格式是 `.frm`。MEMORY 类型的表访问非常快，因为它的数据是放在内存中的

15. TEXT 和 BLOB 的异同点？

    都是用于存储较大的数据，TEXT 用于存储字符数据，如一篇文章或者日记，BLOB 则用于存储二进制文件，如图片。

16. 为什么删除 TEXT 和 BLOB 数据后，需要及时使用 `OPTIMIZE TABLE` 命令？

    在执行删除操作之后，会在数据表中留下很大的空洞，可以定期使用 OPTIMIZE TABLE 来进行碎片整理。另外，可以将 TEXT 和 BLOB 列分离到单独的表中，减少主表的碎片。

17. 如何选择日期类型？

    根据实际需要选择能够满足应用的最小存储的日期类型。如果记录的日期需要让不同时区的用户使用，那么最好使用 TIMESTAMP，因为日期类型中只有它能够和实际时区相对应。

18. 如何选择字符集？

    如果需要处理各种各样的文字，选择 utf8 编码；如果应用涉及已有数据的导入，需要考虑兼容性；如果需要考虑对字符串的比较排序等操作，可以选择定长的编码集。

19. MySQL 中的字符集和校对规则区别？

    字符集用于定义 MySQL 存储字符串的编码格式，校对规则用来定义字符串的比较方式，通常以字符集开始，以 `_ci`（大小不敏感），`_cs` 或者 `bin` 结束。

20. MySQL 4 个级别的字符集设置？

    服务器级别，数据库级别，标记别和列级别。

21. 如果原来的数据库中存在部分数据，想要修改字符集，正确的做法是？

    直接使用 `alter database/table` 修改字符集并不能修改之前已经插入的字符串，需要先导出数据，然后手动修改字符集，最后再导入即可。

22. BTREE 索引和 HASH 索引区别？

    HASH 索引适用于点查询，BTREE 索引适用于范围查询。

23. 为什么说不要过度使用索引？

    每次插入数据的时候需要更新相关索引，造成插入速度变慢；并且还会消耗大量的磁盘空间。

24. MySQL 已经提供了表结构，为什么还提供视图这一概念？

    让终端用户直接使用视图而不是表，可以带来以下优点：简单，安全，数据独立。

25. 如何保证用户对视图里面的数据修改操作是合法的，满足视图定义条件的？

    可以添加 `WITH [LOCAL | CASCADE] CHECK OPTION`，用于是否允许更新数据使记录不再满足视图的条件，LOCAL 只需要满足本视图即可，CASCADE 则必须满足针对该视图的所有视图的条件才可以更新。

26. 触发器发生时间，针对的操作以及使用限制？

    `[BEFORE | AFTER] [INSERT | DELETE | UPDATE]`，在触发器中，可以使用 OLD 和 NEW 来引用发生变化的记录。触发器中不能显式或者隐式方式开启事务，并且其可能会影响性能。

27. MySQL 提供的锁定级别有哪些？

    对于 MyISAM 和 MEMORY 引擎，支持表级别锁定；对于 BDB 引擎，支持表数据的页级别锁定；对于 InnoDB 引擎，支持行级锁定。

28. MySQL 是如何支持分布式事务的？

    通常涉及到一个事务管理器和多个资源管理器，采用两阶段提交协议进行提交。

29. SQL 预计中存在的安全问题和应对方式？

    SQL 注入攻击，可以采取以下措施（基本都是进行转义）：

    + PrepareStatement + Bind-Variable：通过转义用户输入的参数防护
    + 使用应用程序提供的转换函数：如 `mysql_real_escape_string()`
    + 自定义：正则校验，特殊字符转义等

30. SQL Mode 的功能？

    + 设置不同的 SQL Mode，可以设置不同程度的数据校验，保证准确性
    + 在数据迁移之前，改变 SQL Mode 为其他数据库的数据格式，可以便于数据迁移

31. 什么是 MySQL 分区，分区有哪些好处？

    采用分而治之的思想，将表分成一系列的分区，分区对于应用来说是完全透明的，有利于管理非常大的表

    + 跨多个磁盘，能获得更大的吞吐量
    + 和单个磁盘相比，能存储更多的数据
    + 优化查询，删除等操作，如通过删除分区直接删除相关的数据

32. 常见的分区类型有哪些？

    RANGE 分区和 HASH 分区，前者指定连续区间范围，后者则是通过哈希算法将热点数据打散，确保负载均衡。另外也有 LIST 分区，COLUMNS 分区，KEY 分区。

33. InnoDB 引擎支持哈希索引吗？

    并不支持让用户定义一个索引的类型为哈希索引，但是其内部使用了自适应哈希算法，以加快查询语句的速度。

34. SQL 语句优化的一般步骤是什么？

    + 通过使用 `SHOW [SESSION | GLOBAL] STATUS` 命令了解各种 SQL 执行频率和执行信息
    + 定位执行效率缓慢的语句，可以通过启动慢查询日志来实现
    + 通过 explain 语句来分析低效 SQL 的执行计划，采取相应措施

35. 索引失效的常见场景？

    + 以 % 开头的 LIKE 查询不能够利用 B-Tree 索引
    + 数据类型出现隐式转换的时候也不会使用索引
    + 复合索引的情况下，不满足最左原则
    + 用 or 分割开的条件，如果 or 前的条件中的列有索引，而后面的列中没有索引

36. 如何优化分页查询？

    + 在索引上完成排序分页的操作，最后根据主键关联回原表查询所需要的其他列内容
    + 把 LIMIIT 查询转换成某个位置的查询，如根据上次的查询的最大 id 计算下一次的最大的值

37. 如何使用 SQL 语句提取随即行？

    使用 RAND() 提取随机行：

    + `select * from category order by rand() limit 10`，适用于小表
    + `select * from category where rand() <= 0.006 limit 10`，适用于大表

38. 如何对数据库进行优化？

    + 优化表的数据类型，如在设计表的时候需要考虑字段的长度留有一定的冗余
    + 通过拆分提高表的访问效率，如水平拆分和垂直拆分，缺点是查询所有数据需要联合
    + 逆规范化，规范化程度越高，产生的关系就越多，从而导致表之间的连接操作越频繁，而导致性能下降，可以考虑增加冗余列，派生列等
    + 使用中间表提高统计查询速度，如查询最近一周的消费情况，就可以在原来的消费表上建立起来，可以进行隔离，另外中间表上也可以添加索引

39. MySQL 中提供哪几种粒度的锁？

    + 表级锁：如 MyISAM 和 MEMORY 引擎，开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低
    + 行级锁：如 InnoDB 引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高
    + 页级锁：如 BDB 引擎，开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般

40. MyISAM 如何加表锁的？

    + 隐式：执行查询语句时，自动加读锁；执行更新操作时，自动加写锁
    + 显式：LOCK TABLES tbl_name [READ | WRITE] [LOCAL]，LOCAL 参数允许用户在表尾并发插入记录

41. MyISAM 中的系统变量 concurrent_insert，作用是什么？

    用于控制并发插入：

    + 设置为 0 时，不允许并发插入
    + 设置为 1 时，如果 MyISAM 表中没有空洞(即表的中间没有被删除的行)，MyISAM允许在一个进程读表的同时，另一个进程从表尾插入记录。默认项
    + 设置为 2 时，无论 MyISAM 表中有没有空洞，都允许在表尾并发插入记录

42. MyISAM 中写锁优先还是读锁优先？能否进行配置？

    如果同时存在一个写进程和一个读进程获取相同项的锁，MySQL 会优先将锁给写进程。可以通过调整low-priority-updates变量改变调度行为。

43. InnoDB 存在哪些锁模式？

    行锁有共享锁和排他锁，表锁（意向锁）有 IS 和 IX 锁，意向锁是自动加的。对于更新操作，会加上 X 锁，对于普通的 SELECT 语句，则不会加任何锁，但是可以通过 SELECT ... LOCK IN SHARE MODE 获取 S 锁，通过 SELECT ... FOR UPDATE 获取 X 锁。

44. InnoDB 行锁有哪几种类型？

    + Record Lock：对索引项加锁
    + Gap Lock：对索引项之间的“间隙”、第一条记录前的“间隙”或最后一条记录后的“间隙”加锁
    + Next-key Lock：前两种的组合，对记录及其前面的间隙加锁

    行锁的实现方式是给索引上的索引项加锁来实现的，这意味着只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁。

45. MySQL 中存在死锁吗？

    MyISAM 是 deadlock free 的，这是因为 MyISAM 一次获取需要的所有锁，而在InnoDB中，锁是逐步获得的。可以使用顺序加锁，申请大粒度锁等情况规避死锁。

46. MySQL 体系概览？

    ![image-20210309145331858](MySQL-面试题目汇总/image-20210309145331858.png)

47. InnoDB log 优化方案？

    + innodb_flush_log_at_trx_commit：0 表示 commit 到 innodb 内存，每秒写入disk file，1 表示 commit 到 disk file，2 表示 commit 到 os cache，每秒写入 disk file
    + 设置 log file size，控制检查点：日志文件切换会导致检查点变化，会导致缓存页小批量刷新，降低性能，通常每半个小时写满一个日志文件较好
    + 调整 innodb_log_buffer_size：默认 8 MB，对于具有大量更新记录的事务，可以增加该值，减少对磁盘写入次数

48. MySQL 并发相关的参数？

    + 调整 max connections，提高并发连接
    + 调整 back_log：积压请求栈大小
    + 调整 table_open_cache：控制所有 SQL 执行线程可打开表缓存的数量
    + 调整 thread cache size
    + innod lock wait timeout，设置锁超时时间

49. MyISAM 如何进行内存优化？

    MyISAM 使用 key buffer 缓存索引块，对于数据块，则依赖于 IO 缓存，优化策略有：

    + 调整 key_buffer_size 大小
    + 调整中点插入策略：对 LRU 的改进
    + 调整 read_buffer_size 和 read_rnd_buffer_size

50. read_rnd_buffer_size 作用？

    可用于优化 order by 的语句，因为 sort 后的数据是以 key-value 的形式存在的，使用这些行指针去读取数据，将是以指针数据物理的顺序去读取，很大程度上是随机的方式读取数据的。MySQL 从 sort_buffer 中读取这些行指针数据，然后通过指针排序后存入 read_rnd_buffer 中，之后再通过指针读取数据时，基本上都是顺序读取了。

51. InnoDB 内存优化？

    用一块内存区做 IO 缓存池，该缓存池不仅用来缓存 InnoDB 的索引块，而且也用来缓存InnoDB的数据块，缓存池逻辑上由 free list、flush list 和 LRU list 组成。InnoDB 使用的 LRU 算法是类似两级队列的方法

    + innodb_buffer_pool_size
    + 调整 old sublist 大小
    + 调整 innodb_old_blocks_time 的设置：确定从 old sublist 到 young sublist 的时间
    + 调整缓存池数量 innodb_buffer_pool_instances
    + 控制 innodb buffer 刷新，延长数据缓存时间
    + 调整排序缓存大小 sort_buffer_size 和连接缓存大小 join_buffer_size
    + InnoDB doublewrite：原因是 MySQL 的数据页大小（一般是 16KB）与操作系统的 IO 数据页大小（一般是 4KB）不一致，无法保证 InnoDB 缓存页被完整、一致地刷新到磁盘。原理是用系统表空间中的一块连续磁盘空间（100个连续数据页，大小为 2MB）作为 doublewrite buffer，当进行脏页刷新时，首先将脏页的副本写到系统表空间的 doublewrite buffer 中，然后调用 fsync 刷新操作系统 IO 缓存，确保副本被真正写入磁盘。

52. MySQL 如何优化磁盘 IO 速度？

    + 使用 Symbolic Links 分布 IO：默认情况下，数据库名和表名对应的就是文件系统的目录名和文件名，但是这样不利于多磁盘并发读写的能力，可以使用符号链接将不同的数据库指向不同的物理磁盘，达到分布磁盘 IO 的目的。
    + 禁止操作系统更新文件的 atime 属性：LINUX 系统下，每次读取一个文件，操作系统就会将读操作的时间写回到磁盘上，这可能会影响 IO 性能。
    + 使用裸设备存放 InnoDB 的共享表空间：对于 MyISAM，数据文件的读写完全依赖于操作系统，但是对于 InnoDB 来说，其自己实现了数据缓存机制，操作系统的缓存系统可能对其有反作用，可将数据放倒 Raw Device 上。

53. 在应用层面上，如何对 MySQL 服务进行优化？

    + 使用连接池，减少建立销毁连接的开销
    + 减少对 MySQL 的访问：增加 CACHE 层，使用查询缓存（适用于更新不频繁的表）
    + 负载均衡：利用 MySQL 复制实现读写分流，采用分布式数据库架构

54. MySQL 常用工具？

    mysql，mysqladmin，mysqlbinlog，mysqldump，mysqlimport，mysqlshow。

55. 

56. 能说下 MyISAM 和 InnoDB 的区别吗？

    MyISAM 支持全文索引，压缩表和空间函数等，但是不支持事务和行级锁，通常用于大量查询少量插入的场景，MyISAM 的索引和数据是分开的；InnoDB 采用聚簇索引，其支持事务，外键和行级锁，并且通过 MVCC 来支持高并发。

57. 使用 VARCHAR(5) 和 VARCHAR(200) 存储 "hello" 的空间开销是一样的。那么使用更短的列有什么优势吗？

    事实证明有很大的优势。更长的列会消耗更多的内存，因为 MySQL 通常会分配固定大小的内存块来保存内部值。尤其是使用内存临时表进行排序或其他操作时会特别糟糕。在利用磁盘临时表进行排序时也同样糟糕。

58. 说下 MySQL 的索引有哪些吧，聚簇和非聚簇索引又是什么？

    索引按照数据结构来说主要分为 B+Tree 和哈希索引，聚簇索引是索引和数据存放在一起。

59. 主键索引自增有什么优点？

    在插入数据的时候，可以直接将数据追加到最后一个数据页里面，不涉及数据在数据页中的移动，如果不使用自增主键，在插入的时候可能会造成页分裂等耗时操作。

60. 空闲连接的查看和解决方式？

    通过 `show processlist` 查看空闲连接，MySQL 规定了空闲连接的默认最大时长（8 小时），用户也可主动在执行 `kill connection +<id>` 来终结空闲连接。

61. 那你知道什么是覆盖索引和回表吗？

    覆盖索引指的是通过索引就可以取到所需的数据，如果所需数据不能通过覆盖索引，就需要访问聚簇索引获取相应的数据，该行为称为回表。

62. 锁的类型有哪些呢？

    从粒度上，分为全局锁，表级锁，行锁；从加锁方式上，分为乐观锁和悲观锁；从是否共享，分为共享锁和排他锁。

63. 你能说下事务的基本特性和隔离级别吗？

    ACID，四种隔离级别分别消除了四种不一致现象。

64. 那ACID靠什么保证的呢？

    原子性通过 undolog 保证，隔离性通过 MVCC 和锁机制实现，持久性通过 redolog 实现，保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。

65. 那你说说什么是幻读，什么是MVCC？

    幻读是指两次读取中读到了新插入的数据行，MVCC 实际上是为每个版本添加创建时间版本号，过期时间版本号，只有满足一定要求的事务才能读到对应的版本。

66. 那你知道什么是 next-key lock 吗？

    next-key lock 是 RR 下才有的锁，结合 MVCC 可以解决幻读的问题，其在一定条件下能够退化成记录锁或间隙锁。

67. MySQL 记录锁+间隙锁可以防止删除操作而导致的幻读吗？

    可以，在 MySQL 的可重复读隔离级别下，针对「当前读」的查询语句会对索引加记录锁+间隙锁，这样可以避免其他事务执行「增、删、改」时导致幻读的现象。

68. 分析以下问题：

    + Q1: select * from t_table where a > 1 and b = 2，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？
    + Q2：select * from t_table where a >= 1 and b = 2，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？
    + Q3：SELECT * FROM t_table WHERE a BETWEEN 2 AND 8 AND b = 2，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？
    + Q4：SELECT * FROM t_user WHERE name like 'j%' and age = 22，联合索引（name, age）哪一个字段用到了联合索引的 B+Tree？

    答案：

    + Q1 只有 a 字段用到了联合索引进行索引查询，而 b 字段并没有使用到联合索引。
    + Q2 语句 a 和 b 字段都用到了联合索引进行索引查询（a = 1 时使用 b 字段索引）。
    + Q3 语句 a 和 b 字段都用到了联合索引进行索引查询（a = 2 或 a = 8 时使用 b 字段索引）。
    + Q4 语句 a 和 b 字段都用到了联合索引进行索引查询（对 name = j 的数据，此时使用 age）。

69. 为什么说 MySQL 单表最好不要超过 2000 万？

    MySQL 数据页大小大约是 16KB，分为索引页和数据页，索引页大约有 1000 数目，数据页假设有 16 条数据，对应的三层 B+ 树就是 1000 * 1000 * 16 = 1600 万，因此 MySQL 数据超过 2000 万可能会造成 B+ 树层数增加，而导致 IO 开销增大。

70. 你们数据量级多大？分库分表怎么做的？

    一般拆分顺序是先垂直后水平，水平分库一般通过哈希取模实现，为提高性能，可以引入一致性哈希。

71. 那分表后的自增 ID 怎么保证唯一性的呢？

    设定不同步长，分布式 ID 如雪花算法，不使用自增主键而是使用其他唯一数据列作为主键。

72. 分表后非 sharding_key 的查询怎么处理呢？

    对实时性要求不高的话，可以建立宽表；数据量不是很大的话，可以多线程扫表，然后再聚合结果。

73. 说说 mysql 主从同步怎么做的吧？

    主服务器写入 binglog 后，会创建 dump 线程推送其到从服务器，从服务器启动 IO 线程读取推送过来的 binglog，记录到 relay log 中继日志中，从服务器开启一个 sql 线程读取 relay log 并且执行，最后从服务器也记录自己的 binlog。主从同步分为全同步复制和半同步复制，前者需要所有从库执行完才返回客户端，后者至少收到一个从库的 ack 即可。

74. 那主从的延迟怎么解决呢？

    并不能解决，但是能尽量优化，如尽量减少或者不使用长事务。

75. 查询缓存的作用？

    查询的时候先查询缓存，但是在 MySQL 8.0 后，该功能被移除。缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。建议设置query_cache_type 变量为 DEMAND。
