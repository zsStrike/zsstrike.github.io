---
title: MySQL 面试题目汇总
date: 2023-02-04 12:05:45
tags: ["MySQL"]
---





本文整理了 MySQL 的相关问题，以便更深入掌握 MySQL。

<!-- More -->



1. SQL 语句分类？

   主要分为三类，DDL，DML 和 DCL。

2. 内连接和外连接的区别？

   内连接只包含符合条件的元组，外连接则还包含了哪些不符合条件的元组。

3. 内连接中自然连接和等值连接的区别？

   自然连接会去除相同列，等值连接则不会。

4. Union 和 Union All 的区别？

   前者是集合并，后者是包并，后者执行速度更快。

5. MySQL 数值类型有哪些？

   TINYINT，SMALLINT，MEDIUMINT，INT，BIGINT，FLOAT，DOUBLE，DECIMAL。

6. DECIMAL（20，9）需要多少字节表示其数值部分？

   DECIMAL 采用四字节存储 9 位数字的方式进行存储，小数部分需要 4 字节，整数部分共 11 位，低 9 位 4 字节，高 3 位需要 2 字节，一共需要 4 + 4 + 2 = 10 字节。DECIMAL 负数存储只需要将每个字节取反即可。

7. INT(5) 和 INT 区别？

   表示数据上没有什么不同，INT(5) 在展示小于 5 位的数字时，会进行空格填充，并且依旧能够显示大于 5 位的整数。

8. MySQL 日期类型有哪些？

   DATE，TIME，YEAR，DATETIME，TIMESTAMP。

9. 在 MySQL 5.6 之前，为什么 DATE，TIME 各自需要 3 个字节，而 DATETIME 需要 8 个字节？

   DATE/TIME 是转换到对应天或者秒来计算的，只需要 3 个字节足矣；而 DATETIME 中 DATE 保存方式是 YYYY×10000 + MM×100 + DD，需要四字节，时间整数表示 HH×10000000 + MM×100000 + SS * 1000，同样四字节。

10. MySQL 中的字符串/字节串类型？

    CHAR，VARCHAR，TINYTEXT，TEXT，MEDIUMTEXT，LONGTEXT，TINYBLOB，BLOB，MEDIUMBLOB，LONGBLOB。

11. char(n) 和 varchar(n) 的区别？

    前者表示定长，数据长度不够时会补空格填充，后者则是变长，严格存储对应长度的字符串，还会记录 1 或 2 个字节的长度值。

12. MySQL 复合类型有哪些？

    ENUM 和 SET。ENUM 规定数据只能在枚举值中，并且存储上按照整数存储，因此 enum('male', 'female') 中的 male 实际存储的是 1，female 实际存储的是 2，`''` 空字符串存储 0，`NULL` 将被定义为 NULL。SET 则是定义集合，会自动去除重复值。

13. MySQL 中如何获取 DATETIME 类型对应的 DATE？

    可以通过 date_format(datetime, '%Y-%m-%d') 获取对应的字符串，然后通过 str_to_date 即可。

14. 能说下 MyISAM 和 InnoDB 的区别吗？

    MyISAM 支持全文索引，压缩表和空间函数等，但是不支持事务和行级锁，通常用于大量查询少量插入的场景，MyISAM 的索引和数据是分开的；InnoDB 采用聚簇索引，其支持事务，外键和行级锁，并且通过 MVCC 来支持高并发。

15. 使用 VARCHAR(5) 和 VARCHAR(200) 存储 "hello" 的空间开销是一样的。那么使用更短的列有什么优势吗？

    事实证明有很大的优势。更长的列会消耗更多的内存，因为 MySQL 通常会分配固定大小的内存块来保存内部值。尤其是使用内存临时表进行排序或其他操作时会特别糟糕。在利用磁盘临时表进行排序时也同样糟糕。

16. 说下 MySQL 的索引有哪些吧，聚簇和非聚簇索引又是什么？

    索引按照数据结构来说主要分为 B+Tree 和哈希索引，聚簇索引是索引和数据存放在一起。

17. 主键索引自增有什么优点？

    在插入数据的时候，可以直接将数据追加到最后一个数据页里面，不涉及数据在数据页中的移动，如果不使用自增主键，在插入的时候可能会造成页分裂等耗时操作。

18. 空闲连接的查看和解决方式？

    通过 `show processlist` 查看空闲连接，MySQL 规定了空闲连接的默认最大时长（8 小时），用户也可主动在执行 `kill connection +<id>` 来终结空闲连接。

19. 那你知道什么是覆盖索引和回表吗？

    覆盖索引指的是通过索引就可以取到所需的数据，如果所需数据不能通过覆盖索引，就需要访问聚簇索引获取相应的数据，该行为称为回表。

20. 锁的类型有哪些呢？

    从粒度上，分为全局锁，表级锁，行锁；从加锁方式上，分为乐观锁和悲观锁；从是否共享，分为共享锁和排他锁。

21. 你能说下事务的基本特性和隔离级别吗？

    ACID，四种隔离级别分别消除了四种不一致现象。

22. 那ACID靠什么保证的呢？

    原子性通过 undolog 保证，隔离性通过 MVCC 和锁机制实现，持久性通过 redolog 实现，保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。

23. 那你说说什么是幻读，什么是MVCC？

    幻读是指两次读取中读到了新插入的数据行，MVCC 实际上是为每个版本添加创建时间版本号，过期时间版本号，只有满足一定要求的事务才能读到对应的版本。

24. 那你知道什么是 next-key lock 吗？

    next-key lock 是 RR 下才有的锁，结合 MVCC 可以解决幻读的问题，其在一定条件下能够退化成记录锁或间隙锁。

25. MySQL 记录锁+间隙锁可以防止删除操作而导致的幻读吗？

    可以，在 MySQL 的可重复读隔离级别下，针对「当前读」的查询语句会对索引加记录锁+间隙锁，这样可以避免其他事务执行「增、删、改」时导致幻读的现象。

26. 分析以下问题：

    + Q1: select * from t_table where a > 1 and b = 2，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？
    + Q2：select * from t_table where a >= 1 and b = 2，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？
    + Q3：SELECT * FROM t_table WHERE a BETWEEN 2 AND 8 AND b = 2，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？
    + Q4：SELECT * FROM t_user WHERE name like 'j%' and age = 22，联合索引（name, age）哪一个字段用到了联合索引的 B+Tree？

    答案：

    + Q1 只有 a 字段用到了联合索引进行索引查询，而 b 字段并没有使用到联合索引。
    + Q2 语句 a 和 b 字段都用到了联合索引进行索引查询（a = 1 时使用 b 字段索引）。
    + Q3 语句 a 和 b 字段都用到了联合索引进行索引查询（a = 2 或 a = 8 时使用 b 字段索引）。
    + Q4 语句 a 和 b 字段都用到了联合索引进行索引查询（对 name = j 的数据，此时使用 age）。

27. 为什么说 MySQL 单表最好不要超过 2000 万？

    MySQL 数据页大小大约是 16KB，分为索引页和数据页，索引页大约有 1000 数目，数据页假设有 16 条数据，对应的三层 B+ 树就是 1000 * 1000 * 16 = 1600 万，因此 MySQL 数据超过 2000 万可能会造成 B+ 树层数增加，而导致 IO 开销增大。

28. 你们数据量级多大？分库分表怎么做的？

    一般拆分顺序是先垂直后水平，水平分库一般通过哈希取模实现，为提高性能，可以引入一致性哈希。

29. 那分表后的自增 ID 怎么保证唯一性的呢？

    设定不同步长，分布式 ID 如雪花算法，不使用自增主键而是使用其他唯一数据列作为主键。

30. 分表后非 sharding_key 的查询怎么处理呢？

    对实时性要求不高的话，可以建立宽表；数据量不是很大的话，可以多线程扫表，然后再聚合结果。

31. 说说 mysql 主从同步怎么做的吧？

    主服务器写入 binglog 后，会创建 dump 线程推送其到从服务器，从服务器启动 IO 线程读取推送过来的 binglog，记录到 relay log 中继日志中，从服务器开启一个 sql 线程读取 relay log 并且执行，最后从服务器也记录自己的 binlog。主从同步分为全同步复制和半同步复制，前者需要所有从库执行完才返回客户端，后者至少收到一个从库的 ack 即可。

32. 那主从的延迟怎么解决呢？

    并不能解决，但是能尽量优化，如尽量减少或者不使用长事务。

33. 查询缓存的作用？

    查询的时候先查询缓存，但是在 MySQL 8.0 后，该功能被移除。缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。建议设置query_cache_type 变量为 DEMAND。
