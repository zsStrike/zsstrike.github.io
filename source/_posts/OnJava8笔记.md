---
title: OnJava8笔记
date: 2020-10-25 23:15:42
tags: ["Java"]
---

本文主要整理了 OnJava8 的阅读笔记。

<!-- More -->

## 第三章 万物皆对象

对象操纵：在 Java 中程序员实际操作的是对象的引用，方法参数中传递的也只是对象的引用。

对象创建：new。

+ 数据存储：
  + 寄存器：Java 中不存在该方式。
  + 栈内存：存放一些 Java 数据，比如对象的引用。
  + 堆内存：Java 对象都存于其中。
  + 常量内存：程序代码中，不会改变。
  + 非 RAM 存储：序列化对象（用于传送）和持久化对象（用于恢复）。

+ 基本类型的存储：不是通过 new 创建，变量直接存储值。有 boolean，byte，short，char，int，float，long，double，void。boolean 类型的大小没有明确规定。

+ 高精度数值：BigInteger 和 BigDecimal。

+ 数组的存储：当创建对象数组的时候，实际上是对象引用的数组，初始化为 null。

代码注释：`/* ... */` 和 `//`。

对象清理：

+ 作用域：`{}` 决定，不允许父作用域和子作用域声明相同的变量。
+ 对象作用域：使用 new 关键字创建的 Java 对象生命周期超出作用域。

类的创建：

+ 类型：class
+ 字段：类里面声明的变量
+ 方法：类里面定义的函数
+ 基本类型的默认值：全 0，但是不适用与局部变量。
+ 方法签名：方法名和参数列表统称为方法签名。

程序编写：

+ 命名可见性：反向使用自己的网络域名，但是存在空文件夹
+ 使用其他组件：import
+ static 关键字：类变量和类方法声明，在没有对象时候也可以进行调用，另外类变量在所有的对象中共享



## 第四章 运算符

赋值：`=`，基本类型的赋值都是直接的，而不像对象，赋予的只是其内存的引用。在方法的参数中传递一个对象，在方法体里面对其进行修改，那么在该对象在外部也会被修改。

算术运算符：`+，-，*，/，%`，其中`+, -`可以作为一元运算符。

递增和递减：`++,--`。前缀递增和递减立即修改变量的值，后缀则是使用变量的值，然后再修改。

关系运算符：`>, >=, <, <=, ==, !=`。判断基本对象的时候使用`==`，判断对象的使用 equals 方法，判断对象时使用 `==` 比较的只是引用。

逻辑运算符：`&&, OR, !`。Java 支持短路。

字面量常量：`0x, 0, 0b, L, F, L`, F 可以默认不写。

下划线：用于分割数字字面量。

指数计数法：`e`。

位运算符：`&, |, ^, ~`。

移位运算符：`<<, >>, >>>`。注意 `>>` 是算术右移，`>>>` 是逻辑右移（首位添0）。

三目运算符：`<boolean condition> ? <value1> : <value2>`。

字符串运算符：`+`。

类型转换：向上转换是安全的，向下转换需要显式说明`(type)`。对于浮点数向整数转换，小数总是被截断。

Java 没有 sizeof 运算符，因为每种类型的值都是固定的。



## 第五章 控制流

true 和 false：所有关系运算符都能产生条件语句，注意在 Java 中使用数值作为布尔值是非法的。

条件控制：`if-else`。

迭代语句：`while`，`do-while`，`for`，`for-in`。

return：退出当前的方法，放回一个方法值。

break 和 continue：break 用于中止内层循环，continue 用于跳过此次迭代。

goto：Java 不支持 `goto` 语句，但是支持标签语法，可以和 break 和 continue 一起使用。

switch-case：每个 case 后面跟上 break，同时在 Java7 的时候开始支持字符串匹配。



## 第六章 初始化和清理

使用构造器保证初始化：构造器名称和类名相同，每次创建一个对象的时候，自动调用构造器进行初始化。构造器并没有返回值。

方法重载：每个被重载的方法需要具有一个独一无二的参数列表。返回值并不能用来区分重载的方法。

无参构造器：一个无参构造器就是不接受参数的构造器，如果没有显式提供任何构造器，那么编译器会自动提供一个无参构造器。

this：this 关键字只能在非静态的方法内部使用，等同于当前方法所属的对象引用。

在构造器中调用构造器：通过 `this(param list)` 实现。注意只能通过 this 调用一次构造器，不可重复多次调用构造器。并且，只能在构造器首行进行调用。

static 的含义：static 修饰的方法中不存在 this。静态方法和静态变量是为了类而创建的。

垃圾回收器：在 Java 中，对象并非总是被垃圾回收：

1. 对象可能不被垃圾回收。
2. 垃圾回收不等同于析构。
3. 垃圾回收只和内存有关。

在 Java 中，虽然提供了一个 `finialize()` 的方法用于清理对象，但是事实上我们并不需要过多使用该方法。记住，无论是"垃圾回收"还是"终结"，都不保证一定会发生。如果 Java 虚拟机（JVM）并未面临内存耗尽的情形，它可能不会浪费时间执行垃圾回收以恢复内存。

垃圾回收器如何工作：

+ 引用计数：每个对象有一个引用计数器，每次有引用指向该对象的时候，引用计数加 1.当引用离开作用域或者被置为 null 的时候，引用计数减一。垃圾回收器会遍历含有全部对象的列表，当发现某个对象的引用计数为 0 时，就释放其占用的空间（但是，引用计数模式经常会在计数为 0 时立即释放对象）。这个机制存在一个缺点：如果对象之间存在**循环引用**，那么它们的引用计数都不为 0，就会出现应该被回收但无法被回收的情况。
+ 自适应的垃圾回收技术：对于任意“活”的对象，总是可以追溯到其存活在栈或者静态区的引用，从栈或者静态存储区出发，将会发现所有的活的对象。至于如何处理找到的存活对象，取决于不同的 Java 虚拟机实现。其中有一种做法叫做停止-复制（stop-and-copy）。顾名思义，这需要先暂停程序的运行（不属于后台回收模式），然后将所有存活的对象从当前堆复制到另一个堆，没有复制的就是需要被垃圾回收的。另外，当对象被复制到新堆时，它们是一个挨着一个紧凑排列，然后就可以按照前面描述的那样简单、直接地分配新空间了。上述方法存在缺点：需要两个堆，然后再两个堆之间折腾，得维护比实际空间多一倍的空间；另外在于复制本身，一旦程序进入稳定状态之后，可能只会产生少量垃圾，甚至没有垃圾。尽管如此，复制回收器仍然会将所有内存从一处复制到另一处，这很浪费。为了避免这种状况，一些 Java 虚拟机会进行检查：要是没有新垃圾产生，就会转换到另一种模式（即"自适应"）。这种模式称为标记-清扫（mark-and-sweep）。对一般用途而言，"标记-清扫"方式速度相当慢，但是当你知道程序只会产生少量垃圾甚至不产生垃圾时，它的速度就很快了。"标记-清扫"所依据的思路仍然是从栈和静态存储区出发，遍历所有的引用，找出所有存活的对象。但是，每当找到一个存活对象，就给对象设一个标记，并不回收它。只有当标记过程完成后，清理动作才开始。在清理过程中，没有标记的对象将被释放，不会发生任何复制动作。"标记-清扫"后剩下的堆空间是不连续的，垃圾回收器要是希望得到连续空间的话，就需要重新整理剩下的对象。

成员初始化：在方法中的变量没有默认值，需要手动指定一个值之后才能使用；在类中的变量则会赋予默认值。

初始化的顺序：假设有个名为 **Dog** 的类：

1. 即使没有显式地使用 **static** 关键字，构造器实际上也是静态方法。所以，当首次创建 **Dog** 类型的对象或是首次访问 **Dog** 类的静态方法或属性时，Java 解释器必须在类路径中查找，以定位 **Dog.class**。
2. 当加载完 **Dog.class** 后（后面会学到，这将创建一个 **Class** 对象），有关静态初始化的所有动作都会执行。因此，静态初始化只会在首次加载 **Class** 对象时初始化一次。
3. 当用 `new Dog()` 创建对象时，首先会在堆上为 **Dog** 对象分配足够的存储空间。
4. 分配的存储空间首先会被清零，即会将 **Dog** 对象中的所有基本类型数据设置为默认值（数字会被置为 0，布尔型和字符型也相同），引用被置为 **null**。
5. 执行所有出现在字段定义处的初始化动作。
6. 执行构造器。你将会在"复用"这一章看到，这可能会牵涉到很多动作，尤其当涉及继承的时候。

显式的静态初始化：`static { statements； }`，与其他静态初始化动作一样，这段代码仅执行一次：当首次创建这个类的对象或首次访问这个类的静态成员（甚至不需要创建该类的对象）时。

实例初始化：`{ statements; }`，实例初始化子句是在两个构造器之前执行的。

数组初始化：`Type[] arg = new Type[length]`，`Type[] arg = {value1, value2,,,}`

可变参数列表：`void method(int t, char... args)`

枚举类型：`enum Type {}`



## 第七章 封装

包的概念：包内包含有一组类，它们被组织在一个单独的命名空间下。对于单文件的程序，该文件在默认包（default package）下。另外，每个 Java 源文件只能有一个 public 类。

代码组织：为了将功能相近的 Java 源文件组织到一起，可以使用关键字 package。该关键字必须是文件中除了注释的第一行代码。当需要使用到某个包中的类时，可以使用 import 关键字。

独一无二的包名：通常选择反转的域名。

冲突：当两个包下面含有相同的类时，就会出现名称冲突的问题，可以将特定的类写全名称，比如`java.util.ArrayList`。

使用包的注意事项：当创建一个包的时候，包名实际上就隐含了目录结构。

访问权限修饰符：Java 访问权限控制符 public，protected，private 位于定义的类名，属性名和方法名前。

public：当使用 public 关键字的时候，意味着 public 后声明的成员对于每个人都是可用的。

默认包：指不加修饰符定义的成员，可以被相同包下的文件访问。

private：除了包含成员的类，其他任何类都无法访问这个成员。

protected：继承的类可以访问父类中对应的成员，同时也提供了包访问权限。

类访问权限：类既不能是 private，也不能是 protected 的，只能使用 public 或者 是包访问权限。



## 第八章 复用

复用方式：

+ 组合：在新类里面创建现有类的对象
+ 继承：创建现有类型的子类
+ 委托：介于继承和组合之间，将一个成员对象放在正在构建的类中，但同时又在新的类中公开来自成员对象的所有方法（Java 中不直接支持）

组合语法：将对象的引用放在一个新的类里面，就算是使用了组合。

继承语法：使用 extends 关键字。继承后，可以在方法里面使用 super 关键字来使用父类的方法。

子类的初始化：当某个派生类被实例化的时候，会递归向上调用父类的构造器，最高层级的父类的构造器首先被执行，然后是最高层级下的子类，，，一直到该派生类构造器。

带参数的构造器：当没有有参数的基类构造器，只含有有参数的基类构造器，此时就需要通过 super 手动调用基类的构造器。

组合和继承的选择：当想要在新类中包含一个已有类的功能时，使用组合，而非继承；当使用继承时，使用一个现有类并开发出它的新版本，通常这意味着使用一个通用类，并为了某个特殊需求将其特殊化。组合用来表达“有一个”的关系，而继承则是“是一个”关系。

向上转型：派生类到基类的转型称之为向上转型，向上转型是安全的，因为子类必定包含了所有父类的方法。

final 关键字：final 修饰的数据通常指该数据不能被改变：

+ final 数据：对于基本类型，final 使得数值恒定不变，对于对象引用，final 则是使得引用恒定不变。空白 final 是指没有初始化值的 final 属性，编译器保证在使用空白 final 之前必须被初始化，此时必须在构造器中对 final 变量进行赋值。
+ final 参数：在参数列表中，将参数声明为 final 意味着在方法中不能改变参数指向的对象或基本变量。
+ final 方法：给方法上锁，防止子类通过覆写改变方法的行为。类中所有的 private 方法都隐式地指定为 final。
+ final 类：当说一个类是 final ，就意味着它不能被继承。

类初始化和加载：在 Java 中，每个类的编译代码都存在于它自己独立的文件中，该文件只有在使用程序代码时才会被加载。一般可以说“类的代码在首次使用时加载”。这通常是指创建类的第一个对象，或者是访问了类的 static 属性或方法。构造器也是一个 static 方法尽管它的 static 关键字是隐式的。因此，准确地说，一个类当它任意一个 static 成员被访问时，就会被加载。



## 第九章 多态

向上转型：当使用向上转型的时候，我们可以讲所有派生类当做是基类来看待，提高了程序的可拓展性。

方法调用绑定：当派生类重写了基类的方法时，我们使用向上转型后，调用这些被重写的方法时，编译器会动态绑定到派生类中被重写的方法，执行方法调用。Java 中除了 **static** 和 **final** 方法（**private** 方法也是隐式的 **final**）外，其他所有方法都是后期绑定。

陷阱：

+ 试图重写私有方法
+ 只有普通的方法调用是多态的，属性并不能多态

构造器和多态：

+ 构造器调用顺序：首先是基类构造器被调用，然后按照顺序初始化成员，接着调用派生类构造器的方法体
+ 继承和清理：在清理工作的时候，应该先释放派生类的对象，然后释放基类的对象
+ 构造器内部多态方法的行为：如果在构造器中调用了正在构造的对象的动态绑定方法，就会用到那个方法的重写定义

协变返回类型：派生类的被重写方法可以返回基类方法返回类型的派生类型。

向下转型：重新将基类类型改为派生类类型，是不安全的。



## 第十章 接口

接口和抽象类提供了一种将接口与实现分离的更加结构化的方法，抽象类是一种介于普通类和接口之间的折中手段。

抽象类和方法：抽象方法只有声明没有方法体，并且使用 abstract 关键字，包含有抽象方法的类称为抽象类，并且类本身也必须限定为抽象。抽象类不能被实例化，如果某个类继承自抽象类，就必须实现该抽象类中所有的抽象方法，如果不这么做的话，新的类也是一个抽象类。

接口创建：使用 interface 关键字创接口。一个接口表示，所有实现了该接口的类看起来都这样。在 Java8 之前，接口里面只允许抽象方法（不用加 abstract 关键字），在 Java8 里面又新增了默认方法。另外，接口同样可以包含属性，这些属性被隐式指明为 static 和 final。使用 implements 关键字使一个类遵循某个特定接口（或一组接口），它表示：接口只是外形，现在我要说明它是如何工作的。最后，接口中的方法是 public 权限的。

+ 默认方法：当实现了某个接口的类没有实现某个方法的时候，此时可以使用接口的默认方法，使用 default 关键字，可以带有方法体。增加默认方法的极具说服力的理由是它允许在不破坏已使用接口的代码的情况下，在接口中增加新的方法。
+ 多继承：Java 中只支持单继承，当时 Java 通过默认方法具有某种多继承的特性，结合带有默认方法的接口意味着结合了多个基类中的行为。因为接口中仍然不允许存在属性（只有静态属性，不适用），所以属性仍然只会来自单个基类或抽象类，也就是说，不会存在状态的多继承。
+ 接口中的静态方法：Java8 中允许在接口中添加静态方法，这么做能恰当地把工具功能置于接口中，从而操作接口，或者成为通用的工具。

抽象类和接口：

| 特性               | 接口                                                       | 抽象类                                   |
| ------------------ | :--------------------------------------------------------- | ---------------------------------------- |
| 组合               | 新类可以组合多个接口                                       | 只能继承单一抽象类                       |
| 状态               | 不能包含属性（除了静态属性，不支持对象状态）               | 可以包含属性，非抽象方法可能引用这些属性 |
| 默认方法和抽象方法 | 不需要在子类中实现默认方法。默认方法可以引用其他接口的方法 | 必须在子类中实现抽象方法                 |
| 构造器             | 没有构造器                                                 | 可以有构造器                             |
| 可见性             | 隐式 **public**                                            | 可以是 **protected** 或友元              |

完全解耦：使用接口更有利于实现完全解耦，使得代码更具有可复用性。

多接口实现：一个类只能继承自一个父类，同时可以实现多个接口，提高类的灵活度。

使用继承扩展接口：通过继承，可以很容易在接口中增加方法声明，还可以在新的接口中实现多个接口。注意，通常来说，extends 只能用于单一类，但是在构建接口时可以引用多个基类接口。

实现接口时的命名冲突：覆写、实现和重载令人不快地搅和在一起带来了困难，当打算组合接口时，在不同的接口中使用相同的方法名通常会造成代码可读性的混乱，尽量避免这种情况。

接口适配：接口最吸引人的原因之一是相同的接口可以有多个实现。在简单情况下体现在一个方法接受接口作为参数，该接口的实现和传递对象则取决于方法的使用者。

接口字段：因为接口中的字段都自动是 static 和 final 的，所以接口就成为了创建一组常量的方便的工具。但是在 Java8 中，应尽量使用 enum 关键字来定义枚举变量。

接口嵌套：接口可以嵌套在类或者是其他接口中。



## 第十一章 内部类

内部类创建：将类的定义放在外部类的里面。如果想从外部类的非静态方法之外的任意位置创建某个内部类的对象，那么必须具体地指明这个对象的类型：*OuterClassName.InnerClassName*。

链接外部类：当生成一个内部类的对象的时候，该对象能够访问到外部对象的所有成员，而不需要其他任何特殊权限。当某个外部类的对象创建了一个内部类对象时，此内部类对象必定会秘密地捕获一个指向那个外部类对象的引用。然后，在你访问此外部类的成员时，就是用那个引用来选择外部类的成员。但是这些都是编译器的细节了。

使用 `.this` 和 `.new`：如果你需要生成对外部类对象的引用，可以使用外部类的名字后面紧跟圆点和 **this**。有时你可能想要告知某些其他对象，去创建其某个内部类的对象。要实现此目的，你必须在 **new** 表达式中提供对其他外部类对象的引用，这是需要使用 **.new** 语法。

```java
// innerclasses/DotNew.java
// Creating an inner class directly using .new syntax
public class DotNew {
    public class Inner {}
    public static void main(String[] args) {
        DotNew dn = new DotNew();
        DotNew.Inner dni = dn.new Inner();
    }
}

```

内部类和向上转型：当将内部类向上转型为其基类，尤其是转型为一个接口的时候，内部类就有了用武之地。这是因为此内部类-某个接口的实现-能够完全不可见，并且不可用。所得到的只是指向基类或接口的引用，所以能够很方便地隐藏实现细节。

在方法和作用域中声明内部类：可以在一个方法里面或者在任意的作用域内定义内部类。

匿名内部类：通常使用 `new ClassName(params) { ... };`，params 用于构造器传参，后面的分号指代语句结束。另外，如果匿名类内部希望使用一个定义在其外部的对象，那么编译器要求其参数引用必须是 final 的。注意在实例化匿名类的时候，可以使用非 final 修饰的变量。匿名内部类与正规的继承相比有些受限，因为匿名内部类既可以扩展类，也可以实现接口，但是不能两者兼备。而且如果是实现接口，也只能实现一个接口。

嵌套类：如果不需要内部类对象与其外部类对象之间有联系，那么可以将内部类声明为 static，这通常称为嵌套类。想要理解 static 应用于内部类时的含义，就必须记住，普通的内部类对象隐式地保存了一个引用，指向创建它的外部类对象。然而，当内部类是 static 的时，就不是这样了。嵌套类意味着：

1. 要创建嵌套类的对象，并不需要其外部类的对象。
2. 不能从嵌套类的对象中访问非静态的外部类对象。

嵌套类与普通的内部类还有一个区别。普通内部类的字段与方法，只能放在类的外部层次上，所以普通的内部类不能有 static 数据和 static 字段，也不能包含嵌套类。但是嵌套类可以包含所有这些东西。

+ 接口内部的类：嵌套类可以作为接口的一部分。你放到接口中的任何类都自动地是 public 和 static 的。
+ 从多层嵌套类中访问外部类的成员：一个内部类被嵌套多少层并不重要——它能透明地访问所有它所嵌入的外部类的所有成员。

为什么需要内部类：

+ 闭包和回调：在 Java8 之前，内部类是实现闭包的唯一方式，在 Java8 中，我们可以使用 lambda 表达式来实现闭包行为，并且更加优雅。

继承内部类：因为内部类的构造器必须连接到指向其外部类对象的引用，所以在继承内部类的时候，事情会变得有点复杂。问题在于，那个指向外部类对象的“秘密的”引用必须被初始化，而在派生类中不再存在可连接的默认对象。

```java
// innerclasses/InheritInner.java
// Inheriting an inner class
class WithInner {
    class Inner {}
}
public class InheritInner extends WithInner.Inner {
    //- InheritInner() {} // Won't compile
    InheritInner(WithInner wi) {
        wi.super();
    }
    public static void main(String[] args) {
        WithInner wi = new WithInner();
        InheritInner ii = new InheritInner(wi);
    }
}

```

内部类标示符：由于编译后每个类都会产生一个 .class 文件，其中包含了如何创建该类型的对象的全部信息。内部类也必须生成一个 .class 文件以包含它们的 Class 对象信息。这些类文件的命名有严格的规则：外部类的名字，加上 "$" ，再加上内部类的名字。如果内部类是匿名的，编译器会简单地产生一个数字作为其标识符。



## 第十二章 集合

泛型和类型安全的集合：通过使用泛型，规定了向某个集合中可以添加的变量类型，方便进行处理，同时不会引发类型转型错误等问题。

Java 集合类库的两个概念：集合（Collection）和映射（Map）。

添加元素组：通过 Arrays.asList 和 Collections.addAll 方法来添加元素组。注意 Arrays.asList 的返回值是一个 List，但是这个 List 不能调整大小。

集合的打印：必须使用 Arrays.toString 来生成数组的可打印形式，但是打印集合无需任何操作。

列表 List：有 ArrayList 和 LinkedList，前者擅长随机访问，后者擅长插入删除操作。当确定元素是否是属于某个 **List** ，寻找某个元素的索引，以及通过引用从 **List** 中删除元素时，都会用到 `equals()` 方法。`toArray()` 方法将任意的 Collection 转换为数组。

迭代器 Iterators：在任何集合中，都必须有某种方式可以插入元素并再次获取它们。毕竟，保存事物是集合最基本的工作。对于 **List** ， `add()` 是插入元素的一种方式， `get()` 是获取元素的一种方式。如果从更高层次的角度考虑，会发现这里有个缺点：要使用集合，必须对集合的确切类型编程。为此引入迭代器，迭代器相关方法有`iterator，next，hasNext，remove`。迭代器统一了对集合的访问方式。

ListIterator：ListIterator 是一个更强大的 Iterator 子类型，它只能由各种 List 类生成。 Iterator 只能向前移动，而 ListIterator 可以双向移动。它可以生成迭代器在列表中指向位置的后一个和前一个元素的索引，并且可以使用 `set()` 方法替换它访问过的最近一个元素。

LinkedList：LinkedList 还添加了一些方法，使其可以被用作栈、队列或双端队列（deque） 。在这些方法中，有些彼此之间可能只是名称有些差异，或者只存在些许差异，以使得这些名字在特定用法的上下文环境中更加适用（特别是在 Queue 中）。如 element，peek，poll，offer 等。

栈 Stack：后进先出规则，Java 1.0 中附带了一个 Stack 类，结果设计得很糟糕（为了向后兼容，我们永远坚持 Java 中的旧设计错误）。Java 6 添加了 ArrayDeque ，其中包含直接实现堆栈功能的方法。

集合 Set：Set 不保存重复的元素，Set 具有与 Collection 相同的接口，因此没有任何额外的功能。HashSet 产生的输出没有可辨别的顺序，这是因为出于对速度的追求， HashSet 使用了散列。由 HashSet 维护的顺序与 TreeSet 或 LinkedHashSet 不同，因为它们的实现具有不同的元素存储方式。TreeSet 将元素存储在红-黑树数据结构中，而 HashSet 使用散列函数。LinkedHashSet 因为查询速度的原因也使用了散列，但是看起来使用了链表来维护元素的插入顺序。

映射 Map：根据键快速查找值的结构。Map 可以返回由其键组成的 Set ，由其值组成的 Collection ，或者其键值对的 Set 。keySet() 方法生成由在 petPeople 中的所有键组成的 Set ，它在 for-in 语句中被用来遍历该 Map 。

队列 Queue：先进先出的集合，LinkedList 实现了 Queue 接口，并且提供了一些方法以支持队列行为，因此 LinkedList 可以用作 Queue 的一种实现。offer() 是与 Queue 相关的方法之一，它在允许的情况下，在队列的尾部插入一个元素，或者返回 false 。 peek() 和 element() 都返回队头元素而不删除它，但是如果队列为空，则 element() 抛出 NoSuchElementException ，而 peek() 返回 null 。 poll() 和 remove() 都删除并返回队头元素，但如果队列为空，poll() 返回 null ，而 remove() 抛出 NoSuchElementException 。

优先级队列 PriorityQueue：先进先出（FIFO）描述了最典型的队列规则（queuing discipline）。优先级队列声明下一个弹出的元素是最需要的元素（具有最高的优先级）。当在 PriorityQueue 上调用 offer() 方法来插入一个对象时，该对象会在队列中被排序。默认的排序使用队列中对象的自然顺序（natural order），但是可以通过提供自己的 Comparator 来修改这个顺序。 PriorityQueue 确保在调用 peek()， poll() 或 remove() 方法时，获得的元素将是队列中优先级最高的元素。

集合和迭代器：Collection 是所有序列集合共有的根接口，使用接口描述的一个理由是它可以使我们创建更通用的代码。通过针对接口而非具体实现来编写代码，我们的代码可以应用于更多类型的对象。为了对集合进行遍历操作，我们可以使用迭代器来进行操作。

for-in 迭代器：到目前为止，for-in 语法主要用于数组，但它也适用于任何 Collection 对象。这样做的原因是 Java 5 引入了一个名为 Iterable 的接口，该接口包含一个能够生成 Iterator 的 iterator() 方法。for-in 使用此 Iterable 接口来遍历序列。

适配器惯用法：如果已经有一个接口并且需要另一个接口时，则编写适配器就可以解决这个问题。在这里，若希望在默认的正向迭代器的基础上，添加产生反向迭代器的能力，因此不能使用覆盖，相反，而是添加了一个能够生成 Iterable 对象的方法，该对象可以用于 for-in 语句。

注意：不要在新代码中使用遗留类 Vector ，Hashtable 和 Stack 。

Java 集合框架简图：黄色为接口，绿色为抽象类，蓝色为具体类。虚线箭头表示实现关系，实线箭头表示继承关系。

![collection](OnJava8笔记/collection.png)

![map](OnJava8笔记/map.png)



## 第十三章 函数式编程

Lambda 表达式：`(params) -> { statements; }`，只有一个参数的时候，可以省略括号，如果只有一行的话，花括号应该省略。

方法引用：`ClassName::MethodName`。

+ 未绑定的方法引用：未绑定的方法引用是指没有关联对象的普通（非静态）方法。 使用未绑定的引用时，我们必须先提供对象。
+ 构造函数的引用：`ClassName::new`

函数式接口：Lambda 表达式包含类型推导，但是如果存在`(x, y) -> x + y`这样的 lambda 表达式，编译器就不能自动进行类型推导了。因为 x, y 既可以是 String 类型，也可以是 int 类型。此时引入`java.util.function`包，包含了一组接口，每个接口只有一个抽象方法，称为函数式方法。Java 8 允许我们将函数赋值给接口，这样的语法更加简单漂亮。

+ 多参数函数式接口：在 function 包中，只有很少的接口，我们可以自己定义一个函数接口，如下：

  ```java
  // functional/TriFunction.java
  
  @FunctionalInterface
  public interface TriFunction<T, U, V, R> {
      R apply(T t, U u, V v);
  }
  
  ```

高阶函数：消费或产生函数的函数。

```java
// functional/ProduceFunction.java

import java.util.function.*;

interface FuncSS extends Function<String, String> {} // [1]

public class ProduceFunction {
  static FuncSS produce() {
    return s -> s.toLowerCase(); // [2]
  }
  public static void main(String[] args) {
    FuncSS f = produce();
    System.out.println(f.apply("YELLING"));
  }
}

```

闭包：对外部变量引用的函数。

```java
// functional/Closure1.java

import java.util.function.*;

public class Closure1 {
  int i;
  IntSupplier makeFun(int x) {
    return () -> x + i++;
  }
}

```

柯里化和部分求值：柯里化意为：将一个多参数的函数，转换为一系列单参数函数。



## 第十四章 流式编程

流式编程的特点：代码可读性更高；懒加载，意味着它只在绝对必要时才计算，由于计算延迟，流使我们能够表示非常大（甚至无限）的序列，而不需要考虑内存问题。

流支持：Java 8 通过在接口中添加`default`修饰的方法实现流的平滑嵌入。流操作有三种类型：创建流，修改流元素（中间操作），消费流元素（终端操作）。

流创建：通过 Stream.of 将一组元素转化为流，除此之外，每个集合都可以通过调用 stream 方法来产生一个流。除此以外，还有：

+ 随机数流：`new Random().ints()`
+ int 类型流：`IntStream.range(start, end, step)`
+ generate：`Stream.generate(obj)`
+ iterate：`Stream.iterate(initValue, cb)`
+ 流的构造着模式：首先创建一个 builder 对象，然后将创建流所需的多个信息传递给它，最后builder 对象执行“创建”流的操作。
+ Arrays: `Arrays.stream()`

中间操作：用于从一个流中获取对象，并将对象作为另一个流从后端输出，以连接到其他操作。

+ peek：无修改地查看流中的元素
+ sorted：排序，可以使用 lambda 参数
+ distinct：消除重复元素
+ filter：通过过滤条件的被保存下来，否则删除
+ map：将函数操作应用在输入流的元素中，并将返回值传递到输出流中。还有 mapToInt, mapToLong 等
+ flatMap：将产生流的函数应用在每个元素上（与 `map()` 所做的相同），然后将每个流都扁平化为元素，因而最终产生的仅仅是元素。对应还有 flatMapToInt 等

Optimal 类：一些标准流操作返回 Optional 对象，因为它们并不能保证预期结果一定存在。当流为空的时候你会获得一个 Optional.empty 对象，而不是抛出异常。

+ 解包 Optimal 的函数：`ifPresent(Consumer)`, `orElse(otherObject)`
+ 创建 Optimal：静态方法有`empty(), of(value), ofNullable(value)`
+ Optimal 流：假设你的生成器可能产生 null 值，那么当用它来创建流时，你会自然地想到用 Optional 来包装元素。可以使用 filter() 来保留那些非空 Optional

终端操作：以下操作将会获取流的最终结果，终端操作（Terminal Operations）总是我们在流管道中所做的最后一件事。

+ 数组：toArray
+ 循环：forEach，forEachOrdered
+ 集合：collect
+ 组合：reduce
+ 匹配：allMatch，anyMatch，noneMatch
+ 查找：findFirst，findAny
+ 信息：count，max，min
+ 数字流信息：average，max，min



## 第二十一章 数组

数组特性：效率，类型，保存基本数据类型的能力。

一等对象：不管使用什么类型的数组，数组中的数据集实际上都是对堆中真正对象的引用。注意区分聚合初始化和动态聚合初始化。

返回数组：在 Java 中，可以直接返回一个数组，而不用担心其内存消耗情况，垃圾回收期会自动处理。

多维数组：使用多层方括号界定每个维度的大小，同样的也存在有不规则的数组。可以使用 Arrays.deepToString 来查看多维数组里面的内容。Arrays.setAll 方法用于初始化数组。

泛型数组：数组和泛型并不能很好的结合，不能实例化参数化类型的数组，但是允许您创建对此类数组的引用。

Arrays 相关方法：

+ fill：将单个值复制到整个数组，或者在对象数组的情况下，将相同的引用复制到整个数组
+ setAll：使用一个生成器用于生成不同的值，生成器的参数是 int 数组索引
+ asList：将数组转换为列表
+ copyOf：以新的长度复制数组
+ copyOfRange：复制现有数组的一部分数据
+ equals：判断数组是否相同
+ deepEquals：多维数组相等性比较
+ stream：生成流
+ sort：排序
+ binarySearch：二分查找
+ toString，deepToString：数组的字符串表示

数组元素修改：通过使用 setAll 方法来索引现有数据元素





















