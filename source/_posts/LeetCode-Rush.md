---
title: LeetCode Rush
date: 2021-07-12 22:36:59
tags: ["Algorithm"]
---

本文用于记录在算法题目中使用的技巧或者方法，以备查阅。

<!-- More -->

## 链表问题

在遇到链表问题的时候，一般存在着以下技巧：

+ 使用双指针可以解决找固定位置相关问题，环形链表问题，相交链表问题，旋转链表问题
+ 尝试设置 `dummyHead` 节点，用于处理特殊情况
+ 头插法和尾插法的不同点，可以使用头插法实现链表的反转，也可以直接使用迭代方法
+ 链表反转问题：全部反转（迭代，递归，头插法），部分反转（递归），K 个一组翻转（递归）
+ 判断回文链表：使用额外数据结构，反转后半部分的链表再进行比较，使用后序遍历来比较（链表只存在前序和后序）

## 二叉树问题

在解决二叉树问题的过程中，需要注意：

+ 二叉树遍历氛围 BFS（层次遍历），DFS（前序，中序，后序遍历）
+ 在解决二叉树的问题过程中，通常和其递归遍历框架存在关系，而在编写递归算法中，最关键的是要明确函数的定义是什么，然后使用这个递归推到最终结果，而不要跳入到递归的细节中去
+ 一些使用递归解决的二叉树问题：左右翻转二叉树，二叉树展开为链表，填充每个节点的下一个右侧节点指针（注意不同父节点下的关系），最大二叉树构建，二叉树最大深度，路径总和
+ 使用前序－中序构造二叉树问题，使用后序－中序构造二叉树问题：关键点在于找到根结点，然后递归构建左右子树
+ 二叉树的最近公共祖先：维护每个节点的父节点
+ 二叉树的序列化和反序列化：使用前序后序遍历或者层次遍历，不过也需要记录空节点，不可仅仅使用中序遍历
+ 寻找重复的子树：关键在于如何将二叉树序列化起来，然后和已经存在的二叉树进行比较，看看是否重复
+ 二叉搜索树的中序遍历结果是有序的，可以解决：BST 第 K 小的元素，BST 转化为累加树
+ 二叉搜索树的基本操作：删除，插入，搜索，验证 BST
+ 递归解决二叉搜索树问题：不同的二叉搜索树数量，不同的二叉搜索树所有种类
+ 图问题：所有可能路径。涉及到图遍历框架，注意和回溯算法的区别
+ 二叉搜索子树的最大键值和：使用后序遍历可以减少时间复杂度，因为当前节点所做的事情依赖于左右子树
+ 扁平化嵌套列表迭代器：将其当做是一个多叉树进行遍历保存，使用懒加载模式
+ 完全二叉树的节点数：考虑左右二叉树是否为满二叉树，分解问题，减少时间复杂度

## 数组和字符串问题

+ 田忌赛马算法决策：比不过的时候选择最差的元素进行比较，如优势洗牌
+ 二分搜索模板：基本的二分搜索，寻找左侧边界的二分搜索，寻找右侧边界的二分搜索，使用闭区间需要注意索引溢出的问题
+ 二分搜索推广：找到 x，f(x) 和 target，然后套用二分搜索模板即可，相关问题有珂珂吃香蕉，在 D 天内送达包裹的能力，分割数组的最大值
+ 双指针技巧：快慢指针通常用于解决链表中的问题，如判定环形链表以及环的起始位置，寻找中点，倒数第 n 个元素；左右指针通常用于解决二分搜索，两数之和，反转数组，滑动窗口，寻找旋转排序数组中的最小值等算法
+ 滑动窗口模板：维护一个窗口，不断滑动并且更新数据结构，相关问题如最小覆盖子串，字符串排列子串判定，找所有字母的异位词，最长无重复子串，长度最小的子数组
+ 常数时间获取随机数问题：需要使用数组来存储数据，相关问题如常数时间插入、删除和获取随机元素，黑名单中的随机数等
+ 单调栈使用技巧：不同字符的某个子序列，不同字符的最小子序列等
+ 双指针技巧：删除排序数组中的重复项，删除排序链表中的重复元素，移除元素，移动零，合并区间，最长回文子串等
+ 两数之和问题：借助哈希表或者排序实现，如找到和为 target 的两个数，TwoSum 数据结构设计
+ 数组前缀和技巧：寻找数组左右和相等的中心索引，杨辉三角II
+ 二维数组相关：旋转矩阵，对角线遍历

## 数据结构设计问题

+ 并查集算法：解决图论中动态连通性的问题，优化技巧有增加秩，路径压缩，涉及到等价关系的算法可以考虑该数据结构，如等式方程的可满足性
+ LRU 缓存算法：按照访问顺序的淘汰策略，使用 LinkedHashMap 数据结构即可实现，注意其遍历顺序
+ LFU 缓存算法：按照访问频次的淘汰策略，如果最低访问频次有多个，淘汰最旧的数据，使用 HashMap，借助 LinkedHashSet 实现，注意其遍历顺序
+ 最大频率栈：每次 pop 掉频率最大的数据，使用 HashMap 结构实现快速索引
+ 数据流的中位数：使用两个优先级队列，并保持两个队列间数字的大小顺序
+ 合并 k 个有序链表：使用优先级队列实现，如返回朋友圈前 10 条动态
+ 单调栈：指每次在 push 的时候，保持栈中的大小顺序，用于处理 Next Greater Element 问题，如下一个更大元素 I，下一个更大元素 II，每日温度等
+ 单调队列：每次添加元素的时候，保持队列中的大小顺序，用于处理和滑动窗口相关的问题，如滑动窗口最大值
+ 优先队列实现：使用二叉堆来实现，涉及到的操作主要有 sink，swim，offer 和 poll 方法
+ 栈实现队列和队列实现栈：双栈一个用于 offer，一个 用于 poll；队列将队头元素调整到队尾

## 动态规划问题

+ 该类问题存在重叠子问题，具备最优子结构和状态转移方程，解决方案通常有带备忘录的递归，dp table 的迭代解法，注意迭代的方向需要根据已知的 dp 状态来确定，如零钱兑换，斐波拉契数列，下降路径最小和等（复读状态压缩，动态规划和回溯算法）
+ 编辑距离：dp[m, n] 表示子串 s1[0..m] 和 s2[0..n] 的编辑距离，如果想要具体的编辑方案，可以加上对应的选择即可
+ 最长递增子序列：dp[n]  表示将其当作最后一个数字时的最长递增子序列长度，使用 patience sorting 可以降低时间复杂度，推广问题有信封嵌套问题，需要注意其排序方法
+ 最大子序和：包含正负数，dp[n] 表示 num[n] 作为子序中的最后一个数，最大的子序和，而不是 nums[0..n] 中的最大子序和

## Java 编程知识点

+ IntegerCache：在自动装箱时，为了提高性能，Java 缓存了 [-128, 127] 的整形值引用，因此，当我们比较两个 Integer 的时候，应该使用 equals 方法，或者借助 intValue 方法，而不是 `==`
+ random.nextInt() 和 nextInt(upperBound)：不加参数的话，int 类型 32 位都会随机 0 或者 1，可能会产生负数，使用取模可能会产生负数，加参数的话返回 [0, upperBound) 之间的整型
