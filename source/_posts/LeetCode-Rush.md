---
title: LeetCode Rush
date: 2021-07-12 22:36:59
tags: ["Algorithm"]
---

本文用于记录在算法题目中使用的技巧或者方法，以备查阅。

<!-- More -->

## 链表问题

+ 使用双指针可以解决找固定位置相关问题，环形链表问题，相交链表问题，旋转链表问题
+ 尝试设置 `dummyHead` 节点，用于处理特殊情况
+ 头插法和尾插法的不同点，可以使用头插法实现链表的反转，也可以直接使用迭代方法
+ 链表反转问题：全部反转（迭代，递归，头插法），部分反转（递归），k 个一组翻转（递归）
+ 合并链表问题：合并两个链表，合并 k 个链表
+ 判断回文链表：使用额外数据结构，反转后半部分的链表再进行比较，使用后序遍历来比较（链表只存在前序和后序）

## 二叉树问题

在解决二叉树问题的过程中，需要注意：

+ 二叉树遍历分为 BFS（层次遍历），DFS（前序，中序，后序遍历）
+ 在解决二叉树的问题过程中，通常和其递归遍历框架存在关系，而在编写递归算法中，最关键的是要明确函数的定义是什么，然后使用这个递归推到最终结果，而不要跳入到递归的细节中去
+ 递归解决二叉树问题：左右翻转二叉树，二叉树展开为链表，填充每个节点的下一个右侧节点指针（注意不同父节点下的关系），最大二叉树构建，二叉树最大深度，根节点到叶节点路径总和
+ 使用前序－中序构造二叉树问题，使用后序－中序构造二叉树问题：关键点在于找到根结点，然后递归构建左右子树
+ 二叉树的最近公共祖先：维护每个节点的父节点，或者是使用递归查找（注意结束条件）
+ 二叉树的序列化和反序列化：使用前序遍历，后序遍历或者层次遍历，不过也需要记录空节点，不可仅仅使用中序遍历
+ 寻找重复的子树：关键在于如何将二叉树序列化起来，然后和已经存在的二叉树进行比较，看看是否重复
+ 二叉搜索树的中序遍历结果是有序的，可以解决：BST 第 K 小的元素，BST 转化为累加树
+ 二叉搜索树的基本操作：删除，插入，搜索，验证 BST（记录当前树范围）
+ 递归解决二叉搜索树问题：不同的二叉搜索树数量，不同的二叉搜索树所有种类
+ 名流问题：使用排除法减少算法时间复杂度
+ 二叉树中二叉搜索子树的最大键值和：使用后序遍历可以减少时间复杂度，因为当前节点所做的事情依赖于左右子树，涉及到 BST 的验证
+ 扁平化嵌套列表迭代器：将其当做是一个多叉树进行遍历保存，使用懒加载模式
+ 完全二叉树的节点数：考虑左右二叉树是否为满二叉树，分解问题，减少时间复杂度

## 图问题

+ 图中所有可能路径：涉及到图遍历框架，注意和回溯算法的区别，图遍历中 visited 不会重新被设置为 false
+ 拓扑排序：使用 BFS 算法，构建入度数组，之后将入度为 0 的节点入队，使用 DFS 算法，后序遍历并且反转即为拓扑序
+ 判断图中是否存在环：利用拓扑排序判断，或者是深度优先遍历，后者还可以获得当前的环节点
+ Dijkstra 算法：用于查找图中某个节点到其他所有节点的最短路径（不含有负权重），可使用优先队列实现贪心特性，实际上可以扩展成在图中求最值的算法，相关问题如网络延迟时间，概率最大的路径，最小体力消耗路径

## 数组和字符串问题

+ 田忌赛马算法决策：比不过的时候选择最差的元素进行比较，如优势洗牌
+ 二分搜索模板：基本的二分搜索，寻找左侧边界的二分搜索，寻找右侧边界的二分搜索，使用闭区间需要注意索引溢出的问题
+ 二分搜索推广：找到 x，f(x) 和 target，然后套用二分搜索模板即可，相关问题有珂珂吃香蕉，在 D 天内送达包裹的能力，分割数组的最大值
+ 双指针技巧：快慢指针通常用于解决链表中的问题，如判定环形链表以及环的起始位置，寻找中点，倒数第 n 个元素；左右指针通常用于解决二分搜索，两数之和，反转数组，滑动窗口，寻找旋转排序数组中的最小值等算法
+ 滑动窗口模板：维护一个窗口，不断滑动并且更新数据结构，相关问题如最小覆盖子串，字符串排列子串判定，找所有字母的异位词，最长无重复子串，长度最小的子数组
+ 常数时间获取随机数问题：需要使用数组来存储数据，相关问题如常数时间插入、删除和获取随机元素，黑名单中的随机数等
+ 单调栈使用技巧：不同字符的某个子序列，不同字符的最小子序列等
+ 双指针技巧：删除排序数组中的重复项，删除排序链表中的重复元素，移除元素，移动零，合并区间，最长回文子串等
+ 两数之和问题：借助哈希表或者排序实现，如找到和为 target 的两个数，TwoSum 数据结构设计，推广问题如三数之和，四数之和，以及 nSum 问题
+ 数组前缀和技巧：寻找数组左右和相等的中心索引，杨辉三角II
+ 二维数组相关：旋转矩阵，对角线遍历

## 数据结构设计问题

+ 并查集算法：解决图论中动态连通性的问题，优化技巧有增加秩，路径压缩，涉及到等价关系的算法可以考虑该数据结构，如等式方程的可满足性
+ LRU 缓存算法：按照访问顺序的淘汰策略，使用 LinkedHashMap 数据结构即可实现，注意其遍历顺序
+ LFU 缓存算法：按照访问频次的淘汰策略，如果最低访问频次有多个，淘汰最旧的数据，使用 HashMap，借助 LinkedHashSet 实现，注意其遍历顺序
+ 最大频率栈：每次 pop 掉频率最大的数据，使用 HashMap 结构实现快速索引
+ 数据流的中位数：使用两个优先级队列，并保持两个队列间数字的大小顺序
+ 合并 k 个有序链表：使用优先级队列实现，如返回朋友圈前 10 条动态
+ 单调栈：指每次在 push 的时候，保持栈中的大小顺序，用于处理 Next Greater Element 问题，如下一个更大元素 I，下一个更大元素 II，每日温度等
+ 单调队列：每次添加元素的时候，保持队列中的大小顺序，用于处理和滑动窗口相关的问题，如滑动窗口最大值
+ 优先队列实现：使用二叉堆来实现，涉及到的操作主要有 sink，swim，offer 和 poll 方法
+ 栈实现队列和队列实现栈：双栈一个用于 offer，一个 用于 poll；队列将队头元素调整到队尾

## 动态规划问题

+ 该类问题存在重叠子问题，具备最优子结构和状态转移方程，解决方案通常有带备忘录的递归（debug 时可以缩进查看调用栈），dp table 的迭代解法，注意迭代的方向需要根据已知的 dp 状态来确定，如零钱兑换 I，斐波拉契数列，下降路径最小和等
+ 编辑距离：dp[m, n] 表示子串 s1[0..m] 和 s2[0..n] 的编辑距离，如果想要具体的编辑方案，可以加上对应的选择即可
+ 最长递增子序列：dp[n]  表示将其当作最后一个数字时的最长递增子序列长度，使用 patience sorting 可以降低时间复杂度，推广问题有信封嵌套问题，需要注意其排序方法
+ 最大子序和：包含正负数，dp[n] 表示 num[n] 作为子序中的最后一个数，最大的子序和，而不是 nums[0..n] 中的最大子序和
+ 最长公共子序列：使用 dp[m, n] 表示子串 s1[0..m] 和 s2[0..n] 中最长公共子序列的长度，相关问题有两个字符串的删除操作，两个字符串的最小 ASCII 删除和等
+ 最长回文子序列：在子串 s[i..j] 中，最长回文子序列的长度为 dp[i, j]，然后迭代即可，由于回文子序列特殊性，也可以转化为最长公共子序列问题
+ 0-1 背包问题：对于前 i 个物品，当前背包的容量为 w，这种情况下可以装的最大价值是  dp[i, w]，迭代即可，相关问题有分割等和子集
+ 完全背包问题：物品的个数是无限的，通常涉及到将背包刚好填满的情况，相关问题如零钱兑换 II，注意其和爬楼梯算法的区别，前者求组合数，后者求排列数
+ 区间调度问题：选择出来不重叠的区间的最大的个数，贪心算法需要选择 end 最小的，相关问题如无重叠区间，用最少数量的箭引爆气球
+ 视频拼接问题：需要注意排序的方案，start 升序排列，start 相同则按照 end 降序排列
+ 跳跃游戏：跳跃游戏 I 需要找到每次跳跃的最大距离，作为下一次的跳跃起点，跳跃游戏 II 同样道理，注意判定每次增加步数的逻辑，两者也可以使用动态规划来解决
+ 最小路径和问题：dp[i, j] 表示 nums[i, j] 到 nums[0, 0] 的最小路径和
+ 地下城游戏：dp[i, j] 表示从位置 [i, j] 出发，到达 [m, n] 的最少血量，注意其和最小路径和问题的对比
+ 自由之路：dp[i, j] 表示指向 ring[i]，需要输入 key[j..n] 的最小的操作次数
+ K 站中转内最便宜的航班：dp[i, j] 表示经过最多 i 次中转，到达 j 的最便宜的航班
+ 正则表达式匹配：dp(i, j) 表示 s[i..] 能否被 p[j..] 匹配，使用递归；或者 dp[i, j] 表示 s[0..i] 能否被 p[0..j] 匹配，使用迭代
+ 鸡蛋掉落：使用 dp(k, n) 表示从 n 层楼中，使用 k 个鸡蛋，确定 f 的最小确切尝试次数，或者可以使用 dp[k, m] 表示 k 个鸡蛋，最多 m 次操作可以确定 f 的最高的层数，使用迭代解决
+ 戳气球：使用 dp[i, j] 表示开区间 (i, j) 内能得到的最大分数，通过最后一步思考状态转移方程
+ 博弈问题：预测赢家问题中每个人从两端选择数字，最终数字和大的获胜，使用 dp[i, j] 表示从 nums[i, j] 中选择时的情况，dp[i, j, 0] 表示先手分数情况，dp[i, j, 1] 表示后手分数情况，相关问题有石子游戏
+ 四键键盘：N 次操作输出 A 的最多的个数，考虑最后的一次操作，不是 A，就是 C-V，以此作为递推式
+ 股票买卖问题：定义 dp[n, k, 0] 表示在第 n 天，最多 k 次交易，未持有股票的最大收益，而 dp[n, k, 1] 表示在第 n 天，最多 k 次交易，持有股票的最大收益，找到状态转换关系，使用迭代即可解决，注意一些问题也可以使用贪心算法解决
+ 打家劫舍问题：dp[i] 表示 num[i..] 开始，能获得的最大价值，变体如增加首尾限制，二叉树限制等
+ 字符匹配算法：使用 `dp[i, j] = next` 表示当前状态 i，遇到字符 j 后下一个状态是 next，以此为状态机，来进行匹配，第一次相当于 pat 与 pat[1..] 匹配，第二次相当于 pat 与 text[0..n] 匹配；也可以使用 KMP 算法，使用 next 数组表示最大相同真前后缀的前缀末尾索引
+ 构造回文的最小插入次数：dp[i, j] 的表示对字符串 s[i..j]，最少需要进行 dp[i, j] 次插入才能变成回文串，注意状态转换关系
+ IPO：使用贪心算法，每次选择能投资项目中的最大利润

## 回溯算法（DFS 算法）

+ 回溯算法和动态规划递归算法类似，不过不同的是回溯算法不存在重叠子问题，回溯算法的核心就是做选择，回溯，撤销选择，相关问题如全排列，n 皇后，数独问题
+ 集合划分：使用两种视角，桶的视角即为每次刚好填满一个桶，站在数字的视角，即为每次进入一个桶，两种算法通过剪枝可以减少运行时间
+ 子集，组合和排列问题：子集和组合问题都是从当前位置的下个位置开始回溯，但是排列问题不同，另外可以考虑递归思路
+ 括号生成：合法括号对性质，在回溯中添加左右括号剩余数量（有效信息）

## BFS 算法

+ BFS 用于找寻最短路径一类的问题，主要通过队列和设置 `visited` 集合来解决，可采取的优化如双向 BFS 搜索，相关问题如打开转盘锁，二叉树的最小深度等问题
+ 滑动拼图：将二维数组变为字符串处理，同时利用已知信息建立邻居映射

## 数学运算技巧

+ 常用的位操作：使用异或判断两个数字是否异号，使用异或交换两个数字，使用 `n & (n - 1)` 消除数字 n 的二进制表示中的最后一个 1，相关问题如汉明重量，判断是否为 2 的指数，查找只出现一次的元素
+ 阶乘算法题：阶乘后零的个数取决于因子 5 的个数，相关问题有阶乘后的零的个数，阶乘后 k 个零
+ 高效寻找素数：在进行因子判断的时候，只需要遍历到  `sqrt(x)` 即可，相关问题如计算质数的个数，注意两层循环的起始和终止条件
+ 高效模幂运算：使用递归处理数组指数，模运算的防溢出运算，高效求幂，相关问题如超级次方
+ 寻找缺失元素：情况一是 [0, n] 的序列放到长度为 n 的数组中，情况二是 [1, n] 的序列放到长度为 n 的数组中
+ 同时寻找缺失和重复的元素：使用映射来表示某个数字已经存在，通常这样的问题需要索引和数字一起使用
+ 水塘抽样算法：对于第 i 个元素，应该有 `1/i` 的概率选择该元素，`1 - 1/i` 的概率保持原有的选择，可以推广到随即抽取 k 个元素，相关问题如链表随机节点，随机数索引
+ 一行代码解决的问题：Nim 游戏，石子游戏，电灯开关问题（因数个数问题）
+ 反直觉概率问题：男孩女孩问题，生日悖论，三门问题（概率浓缩）
+ 洗牌算法：Fisher-Yates 算法每次迭代模拟了从剩余数字中选择一个放到对应位置上的过程，相关问题如打乱数组
+ 随机数生成问题：基于 `(rand(X) - 1) * Y + rand(Y)`可以均匀生成 [1, XY] 之内的随机数，随后使用拒绝采样挑选随机数

## 其他算法技巧

+ 前缀和数组：适用于原始数组不变，频繁查询某个区间的累加和，相关问题如和为 k 的连续子数组个数，使用前缀和与哈希表解决，思想和 twoSum 类似
+ 差分数组：主要用于频繁对原始数组的某个区间的元素进行加减，对区间 [i, j] 的修改实际上只需要修改 diff 数组的两个元素即可，相关问题如航班预订统计
+ 快速选择算法：存在于快速排序算法中，每次 partition 都会使得左边的数字小，右边的数字大，相关问题如数组中的第 k 个最大元素
+ 分治思路：归并排序，分而治之，相关问题如为运算表达式设计优先级
+ 区间问题：关键在于排序，以及判断两个区间相交与否，相关问题如删除被覆盖区间，区间合并，区间列表的交集
+ 使用哈希表：使用哈希表可以快速统计相同位置上出现的次数，相关问题如回旋镖的数量

## 高频面试算法

+ 分割数组为连续子序列：使用两个哈希表，分别统计出现次数和能在结尾放置的次数，优先放在上个序列的结尾
+ 吃葡萄：将问题转化为三角形边长平分问题，并分析极端情况
+ 烧饼排序算法：使用递归，首先让最大烧饼在最底层，类似于汉罗塔问题
+ 字符串相乘：模拟乘法运算过程，注意参与乘法运算两个数的索引和结果索引间的关系
+ 实现一个计算器：先解决加减，后解决乘除，最后考虑括号，使用单栈方法和双栈方法
+ 接雨水问题：考虑当前节点能接的水是多少，从而解决问题，可以对状态进行优化
+ 寻找最长回文子串：关键在于奇数长度和偶数长度的回文子串的判定
+ 括号相关问题：使用栈结构进行模拟，匹配问题则找到需要的右括号的数量，相关问题如判断合法括号串，使括号有效的最小插入及变体（一个左括号匹配两个右括号），有效的括号字符串（加入 `*`）
+ 判定完美矩形：利用面积和顶点出现次数作为判别条件
+ 考场就座：最大化学生之间的间隔，使用 TreeSet 作为数据结构，按照 distance 排序，需要处理边界情况
+ 高效判定子序列：使用双指针可以解决该问题，但是如果需要匹配的子序列比较多的时候，可以结合二分查找提高效率

## Java 编程知识点

+ IntegerCache：在自动装箱时，为了提高性能，Java 缓存了 [-128, 127] 的整形值引用，因此，当我们比较两个 Integer 的时候，应该使用 equals 方法，或者借助 intValue 方法，而不是 `==`
+ random.nextInt() 和 nextInt(upperBound)：不加参数的话，int 类型 32 位都会随机 0 或者 1，可能会产生负数，使用取模可能会产生负数，加参数的话返回 [0, upperBound) 之间的整型
+ 在 Java 中使用 int[] 作为 HashMap 的键并不会得到想要的结果，因为其会使用 int[] 的索引作为 hashcode，可以使用 `List<Integer>` 或者重写一个类，该类重新实现 hashcode 和 equals 算法，亦或直接使用 TreeMap
+ Integer.valueOf() 和 Integer.parseInt() 两者都是对字符串进行解析，不过它们的返回值类型不同，前者是 Integer，后者是 int
+ `List<Integer>` 到 `int[]` 类型的转换不能直接使用 toArray，可以借助流：`list.stream().mapToInt(Integer.intValue).toArray()`
+ 想要对自定义类实现排序，要么实现 `Comparable<T>` 接口，重写 `compareTo` 方法，或者是排序的时候传入一个 `Comparator<T>` 对象，重写 `compare` 方法
+ 想要对 `int[]` 类型进行降序排序，不能直接用 `Arrays.sort`，其只对 `T[]` 提供自定义比较器，可以使用流操作来实现：`Arrays.stream(arr).boxed().sorted((a, b) -> b - a).mapToInt(Integer::intValue).toArray()`
