---
title: 《计算机系统》备忘录
date: 2022-02-28 09:15:19
tags: ["计算机系统"]
---



计算机系统的相关知识，总结于此，以备查询。

<!-- More -->



## 01 内存管理

虚拟内存：单片机程序写完后会将其进行烧录，程序里面的地址都是内存的物理地址，这给同时运行多个程序带来了困难，为此，可以在物理地址上层提供虚拟地址，程序看到的都是虚拟地址，而物理地址对其是透明的。为了管理虚拟地址和物理地址之间的关系，一般有内存分段和内存分页方式。

内存分段：程序由不同的逻辑段构成，如代码段，数据段，栈段等。分段下的虚拟地址表示为段选择子和段内偏移量，地址转换过程如下：

![6400101](《计算机系统》备忘录/6400101.png)

内存分段的缺点：内外部碎片严重，内存交换效率低。

内存分页：分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小，称其为页，映射过程：

![图片](《计算机系统》备忘录/640-16460119563392.png)

分页很好地解决了内外部碎片和内存交换的问题，但是也存在以下问题：

+ 简单的分页方式浪费内存：可以使用多级页表的方式解决
+ 多级页表转换过程需要更多的时间：引入 TLB，快速进行转换

段页式内存：先将程序划分为多个有逻辑意义的段，接着再把每个段划分为多个页，此时地址结构就由段号、段内页号和页内偏移三部分组成，该方案能提高内存的利用率。

Linux 内存管理：主要采用的是页式内存管理，但同时也不可避免地涉及了段机制，这是由于 Intel 处理器发展历史导致的。Linux 系统通过为每个段分配 0-4G 范围下的虚拟空间，来屏蔽段机制的存在。用户空间划分为：

![图片](《计算机系统》备忘录/640-16460128324164.png)



## 02 进程和线程

进程：运行中的程序，称之为进程。通常，现代 CPU 都支持多进程并发执行。进程的状态变迁图如下：

![图片](《计算机系统》备忘录/640-16460134617116.png)

挂起状态指的是进程目前在外存中，并没有占用物理内存。

操作系统中，通过进程控制块来描述和管理进程，PCB 里面包含了进程的相关信息，如标识符，优先级，当前状态，打开的文件列表，CPU 各个寄存器的值等。PCB 通常通过链表的方式进行组织，把具有相同状态的进程链在一起，组成各种队列。不同进程并发执行时，还会发生进程的上下文切换。

线程：是进程当中的一条执行流程，是更小的能独立运行的基本单位，相同进程内的线程之间共享地址空间，但是保存自己的寄存器和栈资源。

![图片](《计算机系统》备忘录/640-16460142513898.png)

线程优缺点：相同进程内线程可以共享代码段等资源，并发执行起来上下文切换更快；当进程内的一个线程崩溃时，会导致其所属的所有线程崩溃，其原因是操作系统检测到异常，会杀掉进程，其他线程也就一起被杀掉了，之所以不只杀掉崩溃的线程，是因为崩溃的线程可能会破坏其他线程中的内存，导致错误。

线程的实现：

+ 用户级线程的模型：用户线程的切换也是由线程库函数来完成的，无需用户态与内核态的切换，所以速度特别快；但是如果一个线程发起了系统调用而阻塞，那进程所包含的用户线程都不能执行。

+ 内核线程：在一个进程当中，如果某个内核线程发起系统调用而被阻塞，并不会影响其他内核线程的运行；线程的创建、终止和切换都是通过系统调用的方式来进行，因此对于系统来说，系统开销比较大。

+ 轻量级进程：内核支持的用户线程，一个进程可有一个或多个 LWP，每个 LWP 是跟内核线程一对一映射的，也就是 LWP 都是由一个内核线程支持。模式图如下：

  ![图片](《计算机系统》备忘录/640-164601544696910.png)



调度：先来先服务调度算法，最短作业优先调度算法，时间片轮转调度算法，最高优先级调度算法，多级反馈队列调度算法。



## 03 互斥和同步

如果不加同步与互斥操作的话，两个线程对 `i++` 执行 100 次，最小的结果是 2，最大的结果是 200。`i++` 这段代码称为临界区，它是访问共享资源的代码片段，一定不能给多线程同时执行。

同步操作好比操作 A 应在操作 B 之前执行，而互斥就好比操作 A 和操作 B 不能在同一时刻执行。

互斥和同步的实现方式：锁，信号量。

锁操作：忙等待锁（自旋锁）和无忙等待锁。

信号量：通常表示资源的数量，用整型表示，有两个原子操作：P 操作和 V 操作。将信号量设置为 1 可实现临界区互斥，将信号量设置为 0 可实现线程间的同步。

生产者-消费者问题：任何时刻只能有一个线程操作缓冲区，需要互斥；缓冲区空时，消费者必须等待生产者生成数据；缓冲区满时，生产者必须等待消费者取出数据。说明生产者和消费者需要同步。

哲学家就餐问题：可能会发生死锁的现象，解决方法有：

+ 每次只能一个哲学家就餐，通过 mutex 实现
+ 偶数编号的哲学家先拿左边的叉子后拿右边的叉子，奇数编号的哲学家先拿右边的叉子后拿左边的叉子
+ 一个哲学家只有在两个邻居都没有进餐时，才可以进入进餐状态

读者-写者问题：读者优先方案，写者优先方案，多读者单写者方案（注意写者开始写的时候需要以前的读者全部读取完毕）



## 04 进程间通信

每个进程的用户空间都是独立的，一般而言不能互相访问，但是内核空间是每个进程都共享的，因此，进程之间通信需要通过内核来实现。Linux 中提供的通信方式有：

管道：管道传输数据是单向，先进先出的。对于匿名管道，它的通信范围是存在父子关系的进程，对于命名管道，它可以在不相关的进程间也能相互通信。管道通信的方式效率低下，不适合进程间频繁地交换数据。

消息队列：消息队列是保存在内核中的消息链表，A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程需要的时候再去读取数据就可以了。但是消息队列方式存在通信不及时和消息大小限制的问题，另外，消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销。

共享内存：不存在内核态和用户态数据拷贝的开销，提高了通信的速度。

信号量：共享内存如果存在多个进程一起写的情况下，可能会产生数据竞争等问题，通过将信号量初始化为 1 或者 0，就可以实现互斥或同步的功能。

信号：对于异常情况下的工作模式，就需要用信号的方式来通知进程。这是进程间通信机制中唯一的异步通信机制，用户进程对信号处理方式：执行默认操作，捕捉信号，忽略信号。

Socket：跨网络与不同主机上的进程之间通信。



## 05 文件系统

Linux 文件系统会为每个文件分配两个数据结构：

+ 索引节点（inode）：用来记录文件的元信息，如文件大小，修改时间、数据在磁盘的位置等，其占用磁盘空间
+ 目录项（dentry）：用来记录文件的名字、索引节点指针以及与其他目录项的层级关联关系，其被换存在内存中

目录和目录项：目录也是一个文件，只不过该文件存储的是目录数据，目录项是内核的数据结构

逻辑块：多个扇区组成，是文件系统读写的最小单位

![图片](《计算机系统》备忘录/640-164603946581412.png)

虚拟文件系统：文件系统多种多样，为了屏蔽不同文件系统，给上层用户一个统一的接口，操作系统加入了虚拟文件系统，其定义了一组所有文件系统都支持的数据结构和标准接口，这样程序员不需要了解文件系统的工作原理，只需要了解 VFS 提供的统一接口即可。

文件的存储方式：

+ 连续空间存放：读写效率高，但是磁盘空间碎片和文件长度不易扩展
+ 非连续空间存放方式：
  + 链表方式：无外部碎片，动态增长方便，但是查找效率低下
  + 索引方式：可以随机访问，易于文件增长，但是索引表会增加对空间的消耗

目录的存储：目录文件的块里面保存的是目录里面一项一项的文件信息，简单的方式就是表，如果里面的文件太多，则会使用哈希方式优化

![图片](《计算机系统》备忘录/640-164604038988214.png)

空闲空间管理：空闲表，空闲链表，空闲位图（Linux 使用）

软链接和硬链接：硬链接是多个目录项中的索引节点指向同一个索引节点，不可用于跨文件系统；软链接相当于重新创建一个文件，这个文件有独立的 inode，但是这个文件的内容是另外一个文件的路径

文件 IO：

+ 缓冲与非缓冲 I/O：根据是否利用了标准库缓冲划分，缓冲 IO 可以减少系统调用次数

+ 直接与非直接 I/O：根据是否利用操作系统的缓存划分，非直接 IO 需要将用户数据拷贝到内核缓存中

+ 阻塞与非阻塞 I/O：阻塞 IO 等待的是内核数据准备好和数据从内核态拷贝到用户态这两个过程，非阻塞 IO 则需要在最后进行同步过程。非阻塞 IO 需要应用程序进行轮询，该实现方式低下，可以使用 IO 多路复用技术，如 select，poll 等，它是通过 I/O 事件分发，当内核数据准备好时，再以事件通知应用程序进行操作，多路复用过程：

  ![图片](《计算机系统》备忘录/640-164604111913418.png)

+ 同步与异步 I/O：阻塞 I/O、非阻塞 I/O，还是基于非阻塞 I/O 的多路复用都是同步调用，异步 I/O 是内核数据准备好和数据从内核态拷贝到用户态这两个过程都不用等待



## 06 输入输出

设备控制器：CPU 不直接和相应的设备进行交互，而是通过设备控制器来控制对应的设备的。控制器一般存在三类寄存器，分别是状态寄存器，命令寄存器和数据寄存器。另外，设备也可以分为块设备和字符设备，字符设备不可寻址，鼠标是常见的字符设备。CPU 和控制器的寄存器进行通信的方式有：端口IO 和 共享内存。

IO 控制方式：当 CPU 给设备发送了一个指令，让设备控制器去读设备的数据，CPU 通过以下方式感知到读取数据完毕：

+ 轮询控制器的寄存器状态位：浪费 CPU 资源

+ 使用中断：对于频繁读写数据的磁盘，并不友好

+ 使用 DMA：使得设备在 CPU 不参与的情况下，能够自行完成把设备 I/O 数据放入到内存

  ![图片](《计算机系统》备忘录/640-164604206107320.png)

设备驱动程序：虽然设备控制器屏蔽了设备的众多细节，但是不同控制器其寄存器和缓冲区也是不同的，为了屏蔽设备控制器的差异，引入了设备驱动程序。通常，设备驱动程序初始化的时候，要先注册一个该设备的中断处理函数。

通用块层：对于块设备，为了减少不同块设备的差异带来的影响，Linux 通过一个统一的通用块层，来管理不同的块设备。其为文件系统和应用程序，提供访问块设备的标准接口；还会给文件系统和应用程序发来的 I/O 请求排队，进行 I/O 调度。

存储系统 IO 软件分层：

![图片](《计算机系统》备忘录/640-164604231108122.png)

键盘敲入字母到显示屏显示时，该期间：

+ 当用户输入了键盘字符，键盘控制器就会产生扫描码数据，将其缓存，并发送中断请求
+ CPU 收到中断请求时，会保存被中断进程的 CPU 上下文，然后调用键盘的中断处理程序
+ 中断处理函数的功能就是将缓存的数据搬运到显示设备的读缓冲区队列中，最终显示设备驱动程序定时将其显示到屏幕上



## 07 调度算法

进程调度：当 CPU 空闲时，操作系统就会选择内存中的某个就绪状态的进程，并为其分配 CPU 资源，调度方式分为抢占式调度和非抢占式调度，常见的调度方式有：

+ 先来先服务调度算法
+ 最短作业优先调度算法
+ 高响应比优先调度算法：优先级计算考虑到了等待时间和要求服务时间
+ 时间片轮转调度算法
+ 最高优先级调度算法
+ 多级反馈队列调度算法：抢占式的，优先级越高的进程分配到的时间片越少

内存页面置换算法：当产生缺页错误并且当前的内存没有空闲页的时候，此时需要选择一个页面替换出去，常见置换算法：

- 最佳页面置换算法（OPT）：理论存在，作为基准测试
- 先进先出置换算法（FIFO）
- 最近最久未使用的置换算法（LRU）
- Second-Chance LRU：每个页面连续两次被选择逐出时才会真正被逐出
- 时钟页面置换算法（LOCK）：只有当需要替换的时候，才会移动指针，并且只有当访问位为 0 时淘汰
- 最不常用置换算法（LFU）

磁盘调度算法：磁盘访问中，耗时成分主要有寻道延迟，旋转延迟和传输延迟。磁盘调度算法则主要为了减少寻道延迟，相关算法有：

- 先来先服务算法
- 最短寻道时间优先算法：可能会导致饥饿现象
- 扫描算法：磁头在一个方向上移动，直到磁头到达该方向上的最后的磁道才调换方向
- 循环扫描算法：磁头只能朝某个方向移动，返回时直接复位磁头，返回时不处理请求
- LOOK 与 C-LOOK 算法：对扫描算法和循环扫描算法的优化，当磁头在移动到最远的请求位置，然后立刻向反方向移动



## 08 锁的应用场景

互斥锁和自旋锁：互斥锁加锁失败后，线程会释放 CPU，给其他线程；自旋锁加锁失败后，线程会忙等待，直到它拿到锁。互斥锁存在两次上下文切换的成本，因此如果被锁住的代码执行时间很短，就不应该用互斥锁，而应该选用自旋锁，否则使用互斥锁。需要注意的是，在单核 CPU 上，需要抢占式的调度器，否则自旋锁将会一直循环等待下去。互斥锁加锁过程：

![图片](《计算机系统》备忘录/640-164604860877824.png)

读写锁：适用于能明确区分读操作和写操作的场景，读写锁在读多写少的场景，能发挥出优势。不管是读优先锁还是写优先锁，都存在饥饿的问题。为此，可以采用公平读写锁，比较简单的一种方式是：用队列把获取锁的线程排队，不管是写线程还是读线程都按照先进先出的原则加锁即可，这样读线程仍然可以并发，也不会出现饥饿的现象。

乐观锁和悲观锁：悲观锁做事比较悲观，它认为多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁。乐观锁做事比较乐观，它假定冲突的概率很低，它的工作方式是：先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。像在线文档便是采用乐观锁。































































