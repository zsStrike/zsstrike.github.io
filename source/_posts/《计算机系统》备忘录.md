---
title: 《计算机系统》备忘录
date: 2022-02-28 09:15:19
tags: ["计算机系统"]
---



计算机系统的相关知识，总结于此，以备查询。

<!-- More -->



## 01 内存管理

虚拟内存：单片机程序写完后会将其进行烧录，程序里面的地址都是内存的物理地址，这给同时运行多个程序带来了困难，为此，可以在物理地址上层提供虚拟地址，程序看到的都是虚拟地址，而物理地址对其是透明的。为了管理虚拟地址和物理地址之间的关系，一般有内存分段和内存分页方式。

内存分段：程序由不同的逻辑段构成，如代码段，数据段，栈段等。分段下的虚拟地址表示为段选择子和段内偏移量，地址转换过程如下：

![6400101](《计算机系统》备忘录/6400101.png)

内存分段的缺点：内外部碎片严重，内存交换效率低。

内存分页：分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小，称其为页，映射过程：

![图片](《计算机系统》备忘录/640-16460119563392.png)

分页很好地解决了内外部碎片和内存交换的问题，但是也存在以下问题：

+ 简单的分页方式浪费内存：可以使用多级页表的方式解决
+ 多级页表转换过程需要更多的时间：引入 TLB，快速进行转换

段页式内存：先将程序划分为多个有逻辑意义的段，接着再把每个段划分为多个页，此时地址结构就由段号、段内页号和页内偏移三部分组成，该方案能提高内存的利用率。

Linux 内存管理：主要采用的是页式内存管理，但同时也不可避免地涉及了段机制，这是由于 Intel 处理器发展历史导致的。Linux 系统通过为每个段分配 0-4G 范围下的虚拟空间，来屏蔽段机制的存在。用户空间划分为：

![图片](《计算机系统》备忘录/640-16460128324164.png)



## 02 进程和线程

进程：运行中的程序，称之为进程。通常，现代 CPU 都支持多进程并发执行。进程的状态变迁图如下：

![图片](《计算机系统》备忘录/640-16460134617116.png)

挂起状态指的是进程目前在外存中，并没有占用物理内存。

操作系统中，通过进程控制块来描述和管理进程，PCB 里面包含了进程的相关信息，如标识符，优先级，当前状态，打开的文件列表，CPU 各个寄存器的值等。PCB 通常通过链表的方式进行组织，把具有相同状态的进程链在一起，组成各种队列。不同进程并发执行时，还会发生进程的上下文切换。

线程：是进程当中的一条执行流程，是更小的能独立运行的基本单位，相同进程内的线程之间共享地址空间，但是保存自己的寄存器和栈资源。

![图片](《计算机系统》备忘录/640-16460142513898.png)

线程优缺点：相同进程内线程可以共享代码段等资源，并发执行起来上下文切换更快；当进程内的一个线程崩溃时，会导致其所属的所有线程崩溃，其原因是操作系统检测到异常，会杀掉进程，其他线程也就一起被杀掉了，之所以不只杀掉崩溃的线程，是因为崩溃的线程可能会破坏其他线程中的内存，导致错误。

线程的实现：

+ 用户级线程的模型：用户线程的切换也是由线程库函数来完成的，无需用户态与内核态的切换，所以速度特别快；但是如果一个线程发起了系统调用而阻塞，那进程所包含的用户线程都不能执行。

+ 内核线程：在一个进程当中，如果某个内核线程发起系统调用而被阻塞，并不会影响其他内核线程的运行；线程的创建、终止和切换都是通过系统调用的方式来进行，因此对于系统来说，系统开销比较大。

+ 轻量级进程：内核支持的用户线程，一个进程可有一个或多个 LWP，每个 LWP 是跟内核线程一对一映射的，也就是 LWP 都是由一个内核线程支持。模式图如下：

  ![图片](《计算机系统》备忘录/640-164601544696910.png)



调度：先来先服务调度算法，最短作业优先调度算法，时间片轮转调度算法，最高优先级调度算法，多级反馈队列调度算法。



## 03 互斥和同步

如果不加同步与互斥操作的话，两个线程对 `i++` 执行 100 次，最小的结果是 2，最大的结果是 200。`i++` 这段代码称为临界区，它是访问共享资源的代码片段，一定不能给多线程同时执行。

同步操作好比操作 A 应在操作 B 之前执行，而互斥就好比操作 A 和操作 B 不能在同一时刻执行。

互斥和同步的实现方式：锁，信号量。

锁操作：忙等待锁（自旋锁）和无忙等待锁。

信号量：通常表示资源的数量，用整型表示，有两个原子操作：P 操作和 V 操作。将信号量设置为 1 可实现临界区互斥，将信号量设置为 0 可实现线程间的同步。

生产者-消费者问题：任何时刻只能有一个线程操作缓冲区，需要互斥；缓冲区空时，消费者必须等待生产者生成数据；缓冲区满时，生产者必须等待消费者取出数据。说明生产者和消费者需要同步。

哲学家就餐问题：可能会发生死锁的现象，解决方法有：

+ 每次只能一个哲学家就餐，通过 mutex 实现
+ 偶数编号的哲学家先拿左边的叉子后拿右边的叉子，奇数编号的哲学家先拿右边的叉子后拿左边的叉子
+ 一个哲学家只有在两个邻居都没有进餐时，才可以进入进餐状态

读者-写者问题：读者优先方案，写者优先方案，多读者单写者方案（注意写者开始写的时候需要以前的读者全部读取完毕）



## 04 进程间通信

每个进程的用户空间都是独立的，一般而言不能互相访问，但是内核空间是每个进程都共享的，因此，进程之间通信需要通过内核来实现。Linux 中提供的通信方式有：

管道：管道传输数据是单向，先进先出的。对于匿名管道，它的通信范围是存在父子关系的进程，对于命名管道，它可以在不相关的进程间也能相互通信。管道通信的方式效率低下，不适合进程间频繁地交换数据。

消息队列：消息队列是保存在内核中的消息链表，A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程需要的时候再去读取数据就可以了。但是消息队列方式存在通信不及时和消息大小限制的问题，另外，消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销。

共享内存：不存在内核态和用户态数据拷贝的开销，提高了通信的速度。

信号量：共享内存如果存在多个进程一起写的情况下，可能会产生数据竞争等问题，通过将信号量初始化为 1 或者 0，就可以实现互斥或同步的功能。

信号：对于异常情况下的工作模式，就需要用信号的方式来通知进程。这是进程间通信机制中唯一的异步通信机制，用户进程对信号处理方式：执行默认操作，捕捉信号，忽略信号。

Socket：跨网络与不同主机上的进程之间通信。





























































