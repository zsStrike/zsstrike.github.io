---
title: 《深入理解计算机系统》笔记
date: 2022-09-27 11:01:21
tags: ["计算机系统", "Computer Systems"]
---

本文用于记录《深入学习计算机系统》中的知识点，以备查阅。

<!-- More -->

## 第二章 信息的表示和处理

字节顺序：大尾端（sun，sparc）和小尾端（x86，arm），看低地址放的是 MSB 字节还是 LSB 字节

位操作：`& | ～ ^ << >> >>>`

整数表示：

- 无符号：$\sum_{i = 0}^{w - 1}x_i * 2^i$​​​​，有符号：$-x_{w - 1}*2^{w - 1} + \sum_{i = 0}^{w - 2}x_i * 2^i$​​​ 

+ 无符号与有符号之间的变换：保持每个位不变，但是按照转换后的整数类型解释
+ 如果表达式中既有无符号整数，也有有符号整数，那么有符号整数会被解释成无符号整数（ux > -1）
+ 在判断表达式真假的时候，可以使用 0，-1，Tmin 等特殊值检验
+ 扩展：符号扩展，0 扩展
+ 截断：去掉最高的那些位
+ 除法：整数除法中由于截断，正整数结果趋近 0，负整数结果远离 0

浮点数表示：

+ IEEE 标准：采用 $(-1)^s M * 2^E$​ 表示，注意阶码偏移（单精度 127），隐含 1（E 全为 0 除外）

+ 单精度编码规则如下图：

  ![16090749848677](《深入理解计算机系统》笔记/16090749848677.jpg)

  规格化时，此时 E = exp - bias，M 前缀 1，非规格化时，此时 E = -bias + 1，而不是 -bias，M 前缀 0



## 第三章 程序的机器级表示

C 语言程序通过编译器产生汇编文件，汇编文件通过汇编器产生二进制文件，二进制文件通过链接器产生可执行文件。

x86-64 寄存器：%rax，%rbx，%rcx，%rdx，%rdi，%rsi，%rbp，**%rsp**，%r8-%15

数据传输：`movq src, dst`，可以是立即数，寄存器，内存数据，但是 src 和 dst 不能同时是内存数据

内存寻址模式：(R)，D(R)，D(Rb, Ri, S)

地址计算指令：leaq，计算出新的地址，不改变条件码

算术指令：`op src, dst`，表示 dst = dst op src

条件码：

+ 种类：CF，ZF，SF，OF
+ 隐式设置：算术运算
+ 显式设置：cmpq 和 testq
+ 显式读取：setX dest，最低字节根据条件被设置为 0 或者 1，通常和 movzbl 一起使用

条件跳转：jmp，je(zero/equal)，jne，ja，jb，jg，jl，jge，jle

条件 mov：如 cmovle，可能对于三目运算符有副作用

循环：在汇编中，都是通过 jmp 和 label 构成

switch 语句：通过 jumtable 实现，但是如果是稀疏格式，则使用决策树格式（if-elseif-else）

x86-64 栈：向低地址区域增长，%rsp 指向栈顶

+ pushq src：%rsp -= 8，stack[%rsp] = src
+ popq dest：dest = stack[%rsp]，%rsp += 8

控制转移：

+ call label：返回地址压栈，jmp label
+ ret：返回地址出栈，jmp retaddr

数据转移：

+ 函数参数：前 6 个参数分别存储在 %rdi，%rsi，%rdx，%rcx，%r8，%r9；后面参数压栈
+ 返回值：%rax

局部参数：存储在栈中，注意对齐

对于每个函数，使用 Frame（帧）来进行数据管理，从而保证代码可重入，%rbp 用于指向上一个栈帧的位置，对于寄存器保护，一般由操作系统约定：

+ 调用者保存：%rax，参数寄存器，%r10，%r11，浮点数寄存器
+ 被调用者保存：%rbx, %r12, %r13, %r14, %r15，%rbp，%rsp

数组：一系列相同类型的数据，在内存中连续存储，多维数组和多级数组的区别

+ `int A1[3][5]` ：表示 3 * 5 的数据
+ `int *A2[3][5]` ：表示 3 * 5 的 int* 指针
+ `int (*A3)[3][5]` ：表示一个指向 3 * 5 数组的指针
+ `int *(A4[3][5])` ：表示 3 * 5 的 int* 指针
+ `int (*A5[3])[5]` ：表示指针数组，指针指向大小为 5 的数组

结构体：不同类型数据的组合，由编译器决定域的大小和位置，注意每个元素的对齐和整个结构体的对齐

浮点数：浮点数参数被存储在 %xmm0, %xmm1, ...%xmm7，返回值存储在 %xmm0

联合体：按照最大域分配，不同的域共用内存

缓冲区溢出：

+ 原因：主要源于对有界字符数组不加长度限制的写操作造成的
+ 类型：stack smashing attack，code injection attack
+ 措施：使用更加安全的库函数，随机化堆栈偏移量，不可执行代码段保护，Stack Canaries

