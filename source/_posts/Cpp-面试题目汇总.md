---
title: Cpp 面试题目汇总
date: 2023-03-20 09:32:06
tags: ["Cpp"]
---





文本文用于整理学习 Cpp 时遇到的疑问和解答，以及一些面试题目，以备查阅。

<!-- More -->



1. C++ 静态库和动态库在链接时有何不同？

   静态库：将可重定位目标文件以一种特定的方式打包成一个单独的文件，并且在链接生成可执行文件时，从这个单独的文件中“拷贝”它自己需要的内容到最终的可执行文件中。

   动态库：动态库和静态库类似，但是它并不在链接时将需要的二进制代码都“拷贝”到可执行文件中，而是仅仅“拷贝”一些重定位和符号表信息，这些信息可以在程序运行时完成真正的链接过程。gcc 编译时默认使用的方式。

   动态库链接可以减少可执行文件的大小，并且动态库发生修改时，只需要修改动态库即可，而静态库链接则需要重新编译所有可执行程序，静态库唯一的优点是代码执行速度较快，因为不需要进行动态加载过程。

2. C++ 中程序必须从 main 函数开始执行吗？

   这是由编译器决定的，实际上可以进行改动，如果使用 GCC 的话，可以通过attribute 关键字声明 constructor 和 destructor（类似 hook 函数）来观察到程序的执行过程。

   gcc中默认main 就是C语言的入口函数，在 main 函数启动之前，内核会调用一个特殊的启动例程，这个启动例程从内核中取得命令行参数值和环境变量值，为调用 main 函数做好准备。

3. main 函数执行完后，还会调用执行其他的语句吗？

   可以通过调用 atexit 函数来登记这些函数，当程序正常终止时，调用指定的函数 **func**。您可以在任何地方注册你的终止函数，但它会在程序终止的时候被调用。

4. Cpp 语言支持的编程范式以及简介？

   C++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程，是一种中级语言，综合了高级语言和低级语言的特点。

5. 面向对象开发的四大特性？

   + **封装（Encapsulation）**：封装是将数据和方法组合在一起，对外部隐藏实现细节，只公开对外提供的接口。
   + **继承（Inheritance）**：继承是从已有类中派生出新类，新类具有已有类的属性和方法，并且可以扩展或修改这些属性和方法。
   + **多态（Polymorphism）**：多态是指同一种操作作用于不同的对象，可以有不同的解释和实现。
   + **抽象（Abstraction）**：抽象是从具体的实例中提取共同的特征，形成抽象类或接口，以便于代码的复用和扩展。

6. g++ 常用命令选项？

   | 选项         | 解释                                                         |
   | :----------- | :----------------------------------------------------------- |
   | -ansi        | 只支持 ANSI 标准的 C 语法。这一选项将禁止 GNU C 的某些特色， 例如 asm 或 typeof 关键词。 |
   | -c           | 只编译并生成目标文件。                                       |
   | -DMACRO      | 以字符串"1"定义 MACRO 宏。                                   |
   | -DMACRO=DEFN | 以字符串"DEFN"定义 MACRO 宏。                                |
   | -E           | 只运行 C 预编译器。                                          |
   | -g           | 生成调试信息。GNU 调试器可利用该信息。                       |
   | -IDIRECTORY  | 指定额外的头文件搜索路径DIRECTORY。                          |
   | -LDIRECTORY  | 指定额外的函数库搜索路径DIRECTORY。                          |
   | -lLIBRARY    | 连接时搜索指定的函数库LIBRARY。                              |
   | -m486        | 针对 486 进行代码优化。                                      |
   | -o           | FILE 生成指定的输出文件。用在生成可执行文件时。              |
   | -O0          | 不进行优化处理。                                             |
   | -O           | 或 -O1 优化生成代码。                                        |
   | -O2          | 进一步优化。                                                 |
   | -O3          | 比 -O2 更进一步优化，包括 inline 函数。                      |
   | -shared      | 生成共享目标文件。通常用在建立共享库时。                     |
   | -static      | 禁止使用共享连接。                                           |
   | -UMACRO      | 取消对 MACRO 宏的定义。                                      |
   | -w           | 不生成任何警告信息。                                         |
   | -Wall        | 生成所有警告信息。                                           |

7. include 编译指令的作用？

   用于将头文件的内容添加到当前的源代码程序中，这是一种典型的预处理器操作：在源代码被编译之前，替换或添加文本。

8. C++ 标识符起名规则？

   一个标识符以字母 A-Z 或 a-z 或下划线 _ 或美元符 `$` 开始，后跟零个或多个字母、下划线和数字（0-9）和美元符 `$`。注意不能和保留字冲突。

   > 以两个下划线或下划线和大写字母打头的名称被保留给实现（编译器及其使用的资源）使用。以一个下划线开头的名称通常用作类的私有变量。

9. C++ 基本数据类型有哪些？

   bool，char，int，float，double，void，wchar_t（早期实现为 short int）。一些基本类型可以使用一个或多个类型修饰符进行修饰：signed，unsigned，short，long。

10. C++中 "\n" 与 endl 的区别是什么?

   "\n" 表示内容为一个回车符的字符串。std::endl 是流操作子，输出的作用和输出 "\n" 类似，但可能略有区别。std::endl 输出一个换行符，并立即刷新缓冲区。对于有输出缓冲的流（例如cout、clog），如果不手动进行缓冲区刷新操作，将在缓冲区满后自动刷新输出。不过对于 cout 来说（相对于文件输出流等），缓冲一般体现得并不明显。但是必要情况下使用 endl 代替 '\n' 一般是个好习惯。对于无缓冲的流（例如标准错误输出流cerr），刷新是不必要的，可以直接使用 '\n'。

11. 位域有何作用？

    通常用在结构体中 `struct data {char a : 4; char b : 4;}`，表示某个变量有几位数据，用于节省内存，当然也可以通过整型和位运算实现相同效果（如 Java）。

12. include 时 `<>` 和 `""` 区别？

    **`<>`** 先去系统目录中找头文件，如果没有在到当前目录下找。**`" "`** 首先在当前目录下寻找，如果找不到，再到系统目录中寻找。这个用于 include 自定义的头文件，让系统优先使用当前目录中定义的。

13. `::` 在 Cpp 中的作用有哪些？

    在 C++ 中表示作用域，和所属关系。 **::** 是运算符中等级最高的，它分为三种：

    1. **作用域符号：**前面一般是类名称，后面一般是该类的成员名称
    2. **全局作用域符号：**当全局变量在局部函数中与其中某个变量重名，那么就可以用 **::** 来区分
    3. **作用域分解运算符：**比如声明了一个类 A，类 A 里声明了一个成员函数 void f()，但没有在类的声明里给出 f 的定义，那么在类外定义 f 时，就要写成 voidA::f()，表示这个 f() 函数是类 A 的成员函数

14. typedef 与 #define 的区别?

    1. 执行时间不同：typedef 在编译阶段有效，由于是在编译阶段，因此 typedef 有类型检查的功能。#define 则是宏定义，发生在预处理阶段，也就是编译之前，它只进行简单而机械的字符串替换，而不进行任何检查。
    2. 功能有差异：typedef 用来定义类型的别名，定义与平台无关的数据类型，\#define 不只是可以为类型取别名，还可以定义常量、变量、编译开关等。
    3. 作用域不同：#define 没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用。而 typedef 有自己的作用域。

15. typedef 和 using 的区别？

    都用于为类型定义平台无关的别名，便于程序移植，但是：

    + 使用 using 定义别名简单清晰，特别是在定义函数指针时
    + using 在模板环境下更为强大，如 `using grid1=grid<1>`，但是 typedef 不行

16. 枚举类型的作用和缺点？

    是 C++ 中的一种派生数据类型，它是由用户定义的若干枚举常量的集合，默认从 0 开始，因此其枚举量实际上是整型变量，存在风险。可以考虑使用 enum class 替代。

17. C++ 中有哪些类型转换？

    可以使用 c 风格的转换，即 `type (expr)` ，但是 cpp 推荐以下几种方式转换：

    + 静态转换（Static Cast）：用于基本数据类型之间的转换，用于类层次结构中基类和子类之间指针或引用的转换，只会在编译时检查，不进行任何运行时类型检查。
    + 动态转换（Dynamic Cast）：用于将一个基类指针或引用转换为派生类指针或引用。动态转换在运行时进行类型检查，如果不能进行转换则返回空指针或者异常。
    + 常量转换（Const Cast）：用于将 const 类型的对象转换为非 const 类型的对象，只能用于转换掉 const 属性，不能改变对象的类型。
    + 重新解释转换（Reinterpret Cast）：将一个数据类型的值重新解释为另一个数据类型的值，通常用于在不同的数据类型之间进行转换，不进行任何类型检查。**最不安全**

18. C++ 中的变量声明作用？

    变量声明向编译器保证变量以给定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明和定义。可以使用 extern 来进行声明，声明是不会为变量开辟内存空间的。

19. C++ 中的左值（Lvalues）和右值（Rvalues）？

    + **左值（lvalue）：**指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。
    + **右值（rvalue）：**术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。

20. 变量类型间的自动转换规则？

    1. 若参与运算量的类型不同，则先转换成同一类型，然后进行运算。
    2. 转换按数据长度增加的方向进行，以保证精度不降低。
    3. 若两种类型的字节数相同，且一种有符号，一种无符号，**则转换成无符号类型**。
    4. 所有的浮点运算都是以双精度进行的，即使仅含 float 单精度量运算的表达式，也要先转换成 double 型，再作运算
    5. char 型和 short 型参与运算时，必须先转换成 int 型
    6. 在赋值运算中，赋值号两边量的数据类型不同时，赋值号右边量的类型将转换为左边量的类型。此时可能会产生截断

21. C++ 全局变量、局部变量、静态全局变量、静态局部变量的区别？

    + 全局变量具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。
    + 静态局部变量具有局部作用域，它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在，它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。
    + 局部变量也只有局部作用域，它是自动对象（auto），它在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回。
    + 静态全局变量也具有全局作用域，它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被 static 关键字修饰过的变量具有**文件作用域**。

22. 宏定义 #define 和常量 const 的区别？

    1. 类型和安全检查不同：宏定义是字符替换，没有数据类型的区别；const 常量是常量的声明，有类型区别，需要在编译阶段进行类型检查
    2. 编译器处理不同：宏定义是一个"编译时"概念，在预处理阶段展开；const 常量是一个"运行时"概念，在程序运行使用，类似于一个只读行数据
    3. 存储方式不同：宏定义是直接替换，不会分配内存，存储于程序的代码段中；const常量需要进行内存分配，存储于程序的数据段中
    4. 定义后能否取消：宏定义可以通过#undef来使之前的宏定义失效，const常量定义后将在定义域内永久有效
    5. 是否可以做函数参数：宏定义不能作为参数传递给函数；const 常量可以在函数的参数列表中出现

23. const 关键字在修饰指针时，有哪几种形式，分别有什么效果？

    1. const 关键字出现在 ***** 的左边：指针指向的内容不能被修改。
    2. const 关键字出现在 ***** 的右边：指针本身不能被修改。
    3. const 关键字出现在 ***** 的两边：指针指向的内容和指针本身都不能被修改。

    > 指针指向的内容并非不可修改，只是无法通过该指针进行修改，可以通过赋值等方法改变其指向的内容

24. C++ 中的类型限定符？

    | 限定符   | 含义                                                         |
    | :------- | :----------------------------------------------------------- |
    | const    | **const** 定义常量，表示该变量的值不能被修改。               |
    | volatile | 修饰符 **volatile** 告诉该变量的值可能会被程序以外的因素改变，如硬件或其他线程，每次读取必定从内存中进行读取。 |
    | mutable  | 表示类中的成员变量可以在 const 成员函数中被修改。            |
    | static   | 用于定义静态变量，表示该变量的作用域仅限于当前文件或当前函数内，不会被其他文件或函数访问。 |
    | register | 用于定义寄存器变量，表示该变量被频繁使用，可以存储在CPU的寄存器中，以提高程序的运行效率，但是实际上是否会存储在寄存器中由编译器决定 |

25. explict 关键字的作用？

    C++ 中， 一个参数的构造函数(或者除了第一个参数外其余参数都有默认值的多参构造函数)， 承担了两个角色： 构造器，隐含的类型转换操作符（A = xxx）。C++ 提供了关键字 explicit，可以阻止不应该允许的经过转换构造函数进行的隐式转换的发生。

26. thread_local 作用？

    使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。

27. 算术运算符 ++d 和 d++ 的区别？

    + **++d** 是**先加**，先对 d 的值加 1，再使用 d 的值执行该行命令。
    + **d++** 是**后加**，先使用 d 的值执行该行命令，执行完后再对 d 的值加 1。

28. C++ 中向函数传参的方式有哪些？

    + 传值调用：该方法把参数的实际值赋值给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。
    + 指针调用：该方法把参数的地址赋值给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。
    + 引用调用：该方法把参数的引用赋值给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。

    > 实际上，C++ 使用**传值调用**来传递参数，在编译器实现上，引用传递可以当作匿名指针看待

29. Lambda 函数基本格式是怎样的，捕获列表语法规则？

    捕获列表语法规则如下：

    ```
    [capture] (parameters) mutable -> return-type {body}
    []      // 沒有定义任何变量。使用未定义变量会引发错误。
    [x, &y] // x以传值方式传入（默认），y以引用方式传入。
    [&]     // 任何被使用到的外部变量都隐式地以引用方式加以引用。
    [=]     // 任何被使用到的外部变量都隐式地以传值方式加以引用。
    [&, x]  // x显式地以传值方式加以引用。其余变量以引用方式加以引用。
    [=, &z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。
    ```

    > 对于 [=] 或 [&] 的形式，lambda 表达式可以直接使用 this 指针

30. 如何使用 rand() 函数产生均匀的 [range_min, range_max) 随机数？

    + rand() % (range_max - range_min) + range_min
    + rand() * 1.0 / (RAND_MAX + 1) * (range_max - range_min) + range_min

    > 第二种方法更为准确，也可以使用 cpp 提供的 random 库提供随机数

31. C++ 中字符串的表示形式有哪些？

    1. C 语言风格的字符串，使用 const char * str = "";
    2. C++ 自带的 string 库，提供了更多的方法支持
    3. C++ 提供了原始字符串，使用 R"()" 开头，可自定义分隔符

    > C++ 还提供了字符串前缀，如 L，u，U，u8 分别表示 wchar_t，char16_t，char32_t，char，对应的字符串是 wstring, u16string, u32string, string

32. C++ 指针是什么，如何进行空指针赋值？

    **指针**是一个变量，其值为另一个变量的地址，可以使用 NULL 或者 nullptr 来进行空指针赋值，推荐使用 nullptr 进行复制，因为 NULL 可能产生重载二义性问题。

33. 指针的算术运算意义？

    实际上进行了重载，+1 表示指针指向的地址进行 sizeof(*p) 的偏移，而非加 1。

34. 指针数组和数组指针的区别和定义？

    + int *ptr[3]：指针数组，[] 运算优先级高于 *
    + int (*ptr)[3]：数组指针，ptr 指向类型是 int[3]

35. C++ 支持在函数外返回局部变量的地址吗？

    C++ 不支持在函数外返回局部变量的地址，除非定义局部变量为 static变量。

36. C++ 引用是什么，和指针有什么区别？

    引用变量是一个**别名**，也就是说，它是某个已存在变量的另一个名字。和指针区别：

    - 不存在空引用。引用必须连接到一块合法的内存。
    - 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。
    - 引用必须在创建时被初始化。指针可以在任何时间被初始化。

37. 引用作为函数返回值有哪些优点和局限？

    优点是在内存中不产生被返回值的副本，局限如下：

    + 不能返回局部变量的引用。主要原因是局部变量会在函数返回后被销毁，因此被返回的引用就成为了"无所指"的引用，程序会进入未知状态。
    + 不能返回函数内部new分配的内存的引用。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一 个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak。
    + 可以返回类成员的引用，但最好是const。主要原因是当对象的属性是与某种业务规则（business rule）相关联的时候，其赋值常常与某些其它属性或者对象的状态有关，因此有必要将赋值操作封装在一个业务规则当中。如果其它对象可以获得该属性的非常 量引用（或指针），那么对该属性的单纯赋值就会破坏业务规则的完整性。

38. C++ 获取当前日期和时间的方法有哪些？

    其继承了 C 语言中处理时间的方法，主要通过 ctime 库提供，可以通过 strftime 或者 snprintf 进行格式化输出。

39. C++ 类和结构体的区别？

    + class 中默认的成员访问权限是 private 的，而 struct 中则是 public 的。
    + 从 class 继承默认是 private 继承，而从 struct 继承默认是 public 继承。
    + class 可以定义模板，而 struct 不可以。

40. 成员函数定义在类定义内部或者外部有什么区别？

    在类定义中定义的成员函数把函数声明为**内联**的，即便没有使用 inline 标识符。inline 作用是消除函数调用过程，提高运行速度，适用于函数体较小的成员函数。

41. C++ 类访问修饰符有哪些？

    + public：**公有**成员在程序中类的外部是可访问的。
    + private：**私有**成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有类和友元函数可以访问私有成员。
    + protected：与私有成员十分相似，但有一点不同，protected（受保护）成员在派生类（即子类）中是可访问的。

42. C++ 类的三种继承方式有什么不同？

    | 继承方式      | 基类的public成员  | 基类的protected成员 | 基类的private成员 | 继承引起的访问控制关系变化概括         |
    | :------------ | :---------------- | :------------------ | :---------------- | :------------------------------------- |
    | public继承    | 仍为public成员    | 仍为protected成员   | 不可见            | 基类的非私有成员在子类的访问属性不变   |
    | protected继承 | 变为protected成员 | 变为protected成员   | 不可见            | 基类的非私有成员都为子类的保护成员     |
    | private继承   | 变为private成员   | 变为private成员     | 不可见            | 基类中的非私有成员都称为子类的私有成员 |

43. C++ 类构造函数和析构函数的作用？

    类的**构造函数**是类的一种特殊的成员函数，它会在每次创建类的新对象时执行，用于执行一些初始化的工作；类的**析构函数**是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行，用于清理资源。

    构造函数可以存在多个，但是析构函数只能存在一个。

44. C++ 为成员变量初始化的方式？

    + 声明时初始化
    + 构造函数初始化
    + 初始化列表：和书写顺序无关，按照**成员声明顺序进行初始化**的

45. C++ 列表初始化有什么优点？

    C++11 将使用大括号的初始化称为列表初始化（list-initialization），因为这种初始化常用于给复杂的数据类型提供值列表。它对类型转换的要求更严格。具体地说，列表初始化不允许缩窄（narrowing），即变量的类型可能无法表示赋给它的值。

46. 拷贝构造函数的作用？

    是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。通常用于：

    + 通过使用另一个同类型的对象来初始化新创建的对象。
    + 复制对象，把它作为参数传递给函数。
    + 复制对象，并从函数返回这个对象。

47. 为什么拷贝构造函数传递的是引用，而不是值？

    如果传入的是值，将会引起无限递归调用。

48. 关于为什么当类成员中含有指针类型成员且需要对其分配内存时，一定要定义拷贝构造函数？

    默认的拷贝构造函数实现的只能是浅拷贝，即直接将原对象的数据成员值依次复制给新对象中对应的数据成员，并没有为新对象另外分配内存资源。这样，如果对象的数据成员是指针，两个指针对象实际上指向的是同一块内存空间。就可能会导致释放相同空间两次而产生问题。

49. 如何防止默认拷贝发生？

    **声明一个私有的拷贝构造函数**，这样因为拷贝构造函数是私有的，如果用户试图按值传递或函数返回该类的对象，编译器会报告错误，从而可以避免按值传递或返回对象。或者使用 `=delete` 来显式说明。

50. 友元函数/类有何作用？

    类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。

51. this 指针指代的是什么，当调用成员函数的时候，this 如何传入的？

    this 指向的是调用成员函数的对象，当调用成员函数的时候，this 被当作第一个参数进行传入，从而达到在函数中使用的目的，另外，this 可以当作是一个 const 指针。

    > 静态成员函数第一个参数则不是 this 指针，其属于类层次的

52. C++ 中的静态成员变量和函数与普通的成员变量和函数有何不同？

    当我们声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本。静态成员可以看作是类成员。

53. 派生类不继承基类中的哪些方法？

    - 基类的构造函数、析构函数和拷贝构造函数。
    - 基类的重载运算符。
    - 基类的友元函数。

54. 派生类在继承基类的成员变量时，是如何实现的？

    派生类在继承基类的成员变量时，会单独开辟一块内存保存基类的成员变量，因此派生类自己的成员变量即使和基类的成员变量重名，但是也不会引起冲突。

55. 若存在环状继承时，需要如何处理？

    可以通过虚拟继承方式实现，如下：

    ```cpp
    class D{......};
    class B: virtual public D{......};
    class A: virtual public D{......};
    class C: public B, public A{.....};
    ```

56. 重载运算符时，其被当作成员函数和非成员函数在参数上有何不同？

    当作成员函数时，默认的第一个参数是 this 指针，非成员函数时则需要显式定义该参数。常见的运算符重载技巧：

    + 重载前缀 ++ 和后缀 ++ 是不同的，重载后缀需要额外增加一个 int 参数
    + 重载加法时，如果两个对象类型不同（如 A 和 int），则需要额外定义一个友元函数来保证加法的交换律
    + 输入输出运算符重载时，最好定义为友元函数，同时返回对应的输入输出的引用
    + 重载函数调用运算符时，可以将其当作是函数对象使用，可以重载接收任意参数
    + 还可以定义 new，delete 等空间申请和释放操作符

57. 哪些运算符不能进行重载？

    `.* :: sizeof ?` 不能重载。

58. 多态的实现？

    **虚函数** 是在基类中使用关键字 **virtual** 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为**动态链接**，或**后期绑定**。也可以通过`virtual void fun() = 0` 来定义纯虚函数，注意含有纯虚函数的对象不可被实例化，其为抽象类。

    每个含有虚函数的类都有各自的一张虚函数表 **VTABLE**。每个派生类的VTABLE继承了它各个基类的VTABLE，如果基类VTABLE中包含某一项（虚函数的入口地址），则其派生类的VTABLE中也将包含同样的一项，但是两项的值可能不同。如果派生类中重载了该项对应的虚函数，则派生类VTABLE的该项指向重载后的虚函数，如果派生类中没有对该项对应的虚函数进行重新定义，则使用基类的这个虚函数地址。

    在创建含有虚函数的类的对象的时候，编译器会在每个对象的内存布局中增加一个vptr指针项，该指针指向本类的VTABLE。在通过指向基类对象的指针（设为bp）调用一个虚函数时，编译器生成的代码是先获取所指对象的vtb1指针，然后调用vtb1所指向类的VTABLE中的对应项（具体虚函数的入口地址）。

    > C++中**, 虚函数**可以为private, 并且可以被子类覆盖（因为虚函数表的传递），但子类不能调用父类的private虚函数。虚函数的重载性和它声明的权限无关。

59. final 关键字有何作用？

    + 应用在虚函数上，表示不再允许虚函数被子类重写
    + 应用在类上，表示不允许类被继承

60. C++ 是如何进行异常处理的？

    主要通过 `try catch throw` 实现，所有的异常继承自 std::exception，其中包含了一个 virtual 方法 what，派生类可以重写该方法来自定义异常产生的原因。

61. noexcept 作用？

    C++11 后，给函数增加 noexcept 表示不会发生异常，否则表示可能会发生任意的异常。在 C++ 以前版本，也有通过 throw(E1, E2) 的方式来声明，但是现在很少使用。

62. new 和 malloc 内部的实现方式有什么区别？

    new 的功能是在堆区新建一个对象，并返回该对象的指针。所谓的**【新建对象】**的意思就是，将调用该类的构造函数，因为如果不构造的话，就不能称之为一个对象。而 malloc 只是机械的分配一块内存，如果用 mallco 在堆区创建一个对象的话，是不会调用构造函数的。

63. delete 与 delete[] 区别？

    针对简单类型，使用 new 分配后的不管是数组还是非数组形式内存空间用两种方式均可；但是使用类对象数组，则只能通过 delete[] 来进行释放，否则的话只会释放对象数组的第一个指针指向的内存。

64. C++ 命名空间作用？

    可作为附加信息来区分不同库中相同名称的函数、类、变量等。使用了命名空间即定义了上下文。本质上，命名空间就是定义了一个范围。

65. C++ 中 typename 和 class 的区别？

    最初使用 class 在模板中定义类型，为了避免混淆，引入了 typename 关键词，在模板定义语法中关键字 class 与 typename 的作用完全一样。但是 typename 另外一个作用为：使用嵌套依赖类型(nested depended name)，如下所示：`typedef typename T::LengthType LengthType;` 。

66. C++ 如何确保头文件只被引入一次？

    + ifndef-define-endif：移植性高
    + #pragma once：通用，不是标准的预处理器
    + _Pragma("once")：C99 中定义，标准，但是使用较少

67. C++ 如何进行信号处理的？

    通过 signal(registered signal, signal handler) 来进行注册，handler 便是实际处理的程序，也可以在程序中通过 raise(signal sig) 来生成信号。 

68. C++ thread join 和 detach 的区别？

    join 表示主线程需要等待从线程结束之后才能继续执行，而 detach 则表示让从线程在后台运行，即说明主线程不会等待子线程运行结束才结束。一般来说，当程序没有使用共享变量或引用之类的话，可以使用 detach 函数，分离线程。否则需要使用 join 来确保共享变量的安全析构。

69. C++ 标准模板库主要有那三个组件？

    | 组件                | 描述                                                         |
    | :------------------ | :----------------------------------------------------------- |
    | 容器（Containers）  | 容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等。 |
    | 算法（Algorithms）  | 算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。 |
    | 迭代器（iterators） | 迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。 |

    







