---
title: Cpp 面试题目汇总
date: 2023-03-20 09:32:06
tags: ["Cpp"]
---





文本文用于整理学习 Cpp 时遇到的疑问和解答，以及一些面试题目，以备查阅。

<!-- More -->



1. Cpp 语言支持的编程范式以及简介？

   C++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程，是一种中级语言，综合了高级语言和低级语言的特点。

2. 面向对象开发的四大特性？

   + **封装（Encapsulation）**：封装是将数据和方法组合在一起，对外部隐藏实现细节，只公开对外提供的接口。
   + **继承（Inheritance）**：继承是从已有类中派生出新类，新类具有已有类的属性和方法，并且可以扩展或修改这些属性和方法。
   + **多态（Polymorphism）**：多态是指同一种操作作用于不同的对象，可以有不同的解释和实现。
   + **抽象（Abstraction）**：抽象是从具体的实例中提取共同的特征，形成抽象类或接口，以便于代码的复用和扩展。

3. g++ 常用命令选项？

   | 选项         | 解释                                                         |
   | :----------- | :----------------------------------------------------------- |
   | -ansi        | 只支持 ANSI 标准的 C 语法。这一选项将禁止 GNU C 的某些特色， 例如 asm 或 typeof 关键词。 |
   | -c           | 只编译并生成目标文件。                                       |
   | -DMACRO      | 以字符串"1"定义 MACRO 宏。                                   |
   | -DMACRO=DEFN | 以字符串"DEFN"定义 MACRO 宏。                                |
   | -E           | 只运行 C 预编译器。                                          |
   | -g           | 生成调试信息。GNU 调试器可利用该信息。                       |
   | -IDIRECTORY  | 指定额外的头文件搜索路径DIRECTORY。                          |
   | -LDIRECTORY  | 指定额外的函数库搜索路径DIRECTORY。                          |
   | -lLIBRARY    | 连接时搜索指定的函数库LIBRARY。                              |
   | -m486        | 针对 486 进行代码优化。                                      |
   | -o           | FILE 生成指定的输出文件。用在生成可执行文件时。              |
   | -O0          | 不进行优化处理。                                             |
   | -O           | 或 -O1 优化生成代码。                                        |
   | -O2          | 进一步优化。                                                 |
   | -O3          | 比 -O2 更进一步优化，包括 inline 函数。                      |
   | -shared      | 生成共享目标文件。通常用在建立共享库时。                     |
   | -static      | 禁止使用共享连接。                                           |
   | -UMACRO      | 取消对 MACRO 宏的定义。                                      |
   | -w           | 不生成任何警告信息。                                         |
   | -Wall        | 生成所有警告信息。                                           |

4. C++ 标识符起名规则？

   一个标识符以字母 A-Z 或 a-z 或下划线 _ 或美元符 `$` 开始，后跟零个或多个字母、下划线和数字（0-9）和美元符 `$`。注意不能和保留字冲突。

5. C++ 基本数据类型有哪些？

   bool，char，int，float，double，void，wchar_t（早期实现为 short int）。一些基本类型可以使用一个或多个类型修饰符进行修饰：signed，unsigned，short，long。

6. C++中 "\n" 与 endl 的区别是什么?

   "\n" 表示内容为一个回车符的字符串。std::endl 是流操作子，输出的作用和输出 "\n" 类似，但可能略有区别。std::endl 输出一个换行符，并立即刷新缓冲区。对于有输出缓冲的流（例如cout、clog），如果不手动进行缓冲区刷新操作，将在缓冲区满后自动刷新输出。不过对于 cout 来说（相对于文件输出流等），缓冲一般体现得并不明显。但是必要情况下使用 endl 代替 '\n' 一般是个好习惯。对于无缓冲的流（例如标准错误输出流cerr），刷新是不必要的，可以直接使用 '\n'。

7. include 时 `<>` 和 `""` 区别？

   **`<>`** 先去系统目录中找头文件，如果没有在到当前目录下找。**`" "`** 首先在当前目录下寻找，如果找不到，再到系统目录中寻找。这个用于 include 自定义的头文件，让系统优先使用当前目录中定义的。

8. `::` 在 Cpp 中的作用有哪些？

   在 C++ 中表示作用域，和所属关系。 **::** 是运算符中等级最高的，它分为三种：

   1. **作用域符号：**前面一般是类名称，后面一般是该类的成员名称
   2. **全局作用域符号：**当全局变量在局部函数中与其中某个变量重名，那么就可以用 **::** 来区分
   3. **作用域分解运算符：**比如声明了一个类 A，类 A 里声明了一个成员函数 void f()，但没有在类的声明里给出 f 的定义，那么在类外定义 f 时，就要写成 voidA::f()，表示这个 f() 函数是类 A 的成员函数

9. typedef 与 #define 的区别?

   1. 执行时间不同：typedef 在编译阶段有效，由于是在编译阶段，因此 typedef 有类型检查的功能。#define 则是宏定义，发生在预处理阶段，也就是编译之前，它只进行简单而机械的字符串替换，而不进行任何检查。
   2. 功能有差异：typedef 用来定义类型的别名，定义与平台无关的数据类型，\#define 不只是可以为类型取别名，还可以定义常量、变量、编译开关等。
   3. 作用域不同：#define 没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用。而 typedef 有自己的作用域。

10. typedef 和 using 的区别？

    都用于为类型定义平台无关的别名，便于程序移植，但是：

    + 使用 using 定义别名简单清晰，特别是在定义函数指针时
    + using 在模板环境下更为强大，如 `using grid1=grid<1>`，但是 typedef 不行

11. 枚举类型的作用和缺点？

    是 C++ 中的一种派生数据类型，它是由用户定义的若干枚举常量的集合，默认从 0 开始，因此其枚举量实际上是整型变量，存在风险。可以考虑使用 enum class 替代。

12. C++ 中有哪些类型转换？

    可以使用 c 风格的转换，即 `type (expr)` ，但是 cpp 推荐以下几种方式转换：

    + 静态转换（Static Cast）：用于基本数据类型之间的转换，用于类层次结构中基类和子类之间指针或引用的转换，只会在编译时检查，不进行任何运行时类型检查。
    + 动态转换（Dynamic Cast）：用于将一个基类指针或引用转换为派生类指针或引用。动态转换在运行时进行类型检查，如果不能进行转换则返回空指针或者异常。
    + 常量转换（Const Cast）：用于将 const 类型的对象转换为非 const 类型的对象，只能用于转换掉 const 属性，不能改变对象的类型。
    + 重新解释转换（Reinterpret Cast）：将一个数据类型的值重新解释为另一个数据类型的值，通常用于在不同的数据类型之间进行转换，不进行任何类型检查。**最不安全**

13. C++ 中的变量声明作用？

    变量声明向编译器保证变量以给定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明和定义。可以使用 extern 来进行声明，声明是不会为变量开辟内存空间的。

14. C++ 中的左值（Lvalues）和右值（Rvalues）？

    + **左值（lvalue）：**指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。
    + **右值（rvalue）：**术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。

15. 变量类型间的自动转换规则？

    1. 若参与运算量的类型不同，则先转换成同一类型，然后进行运算。
    2. 转换按数据长度增加的方向进行，以保证精度不降低。
    3. 若两种类型的字节数相同，且一种有符号，一种无符号，**则转换成无符号类型**。
    4. 所有的浮点运算都是以双精度进行的，即使仅含 float 单精度量运算的表达式，也要先转换成 double 型，再作运算
    5. char 型和 short 型参与运算时，必须先转换成 int 型
    6. 在赋值运算中，赋值号两边量的数据类型不同时，赋值号右边量的类型将转换为左边量的类型。此时可能会产生截断

16. C++ 全局变量、局部变量、静态全局变量、静态局部变量的区别？

    + 全局变量具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。
    + 静态局部变量具有局部作用域，它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在，它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。
    + 局部变量也只有局部作用域，它是自动对象（auto），它在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回。
    + 静态全局变量也具有全局作用域，它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被 static 关键字修饰过的变量具有**文件作用域**。

17. 宏定义 #define 和常量 const 的区别？

    1. 类型和安全检查不同：宏定义是字符替换，没有数据类型的区别；const 常量是常量的声明，有类型区别，需要在编译阶段进行类型检查
    2. 编译器处理不同：宏定义是一个"编译时"概念，在预处理阶段展开；const 常量是一个"运行时"概念，在程序运行使用，类似于一个只读行数据
    3. 存储方式不同：宏定义是直接替换，不会分配内存，存储于程序的代码段中；const常量需要进行内存分配，存储于程序的数据段中
    4. 定义后能否取消：宏定义可以通过#undef来使之前的宏定义失效，const常量定义后将在定义域内永久有效
    5. 是否可以做函数参数：宏定义不能作为参数传递给函数；const 常量可以在函数的参数列表中出现

18. const 关键字在修饰指针时，有哪几种形式，分别有什么效果？

    1. const 关键字出现在 ***** 的左边：指针指向的内容不能被修改。
    2. const 关键字出现在 ***** 的右边：指针本身不能被修改。
    3. const 关键字出现在 ***** 的两边：指针指向的内容和指针本身都不能被修改。

    > 指针指向的内容并非不可修改，只是无法通过该指针进行修改，可以通过赋值等方法改变其指向的内容

19. C++ 中的类型限定符？

    | 限定符   | 含义                                                         |
    | :------- | :----------------------------------------------------------- |
    | const    | **const** 定义常量，表示该变量的值不能被修改。               |
    | volatile | 修饰符 **volatile** 告诉该变量的值可能会被程序以外的因素改变，如硬件或其他线程，每次读取必定从内存中进行读取。 |
    | mutable  | 表示类中的成员变量可以在 const 成员函数中被修改。            |
    | static   | 用于定义静态变量，表示该变量的作用域仅限于当前文件或当前函数内，不会被其他文件或函数访问。 |
    | register | 用于定义寄存器变量，表示该变量被频繁使用，可以存储在CPU的寄存器中，以提高程序的运行效率，但是实际上是否会存储在寄存器中由编译器决定 |

20. explict 关键字的作用？

    C++ 中， 一个参数的构造函数(或者除了第一个参数外其余参数都有默认值的多参构造函数)， 承担了两个角色： 构造器，隐含的类型转换操作符（A = xxx）。C++ 提供了关键字 explicit，可以阻止不应该允许的经过转换构造函数进行的隐式转换的发生。

21. thread_local 作用？

    使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。

22. 算术运算符 ++d 和 d++ 的区别？

    + **++d** 是**先加**，先对 d 的值加 1，再使用 d 的值执行该行命令。
    + **d++** 是**后加**，先使用 d 的值执行该行命令，执行完后再对 d 的值加 1。

23. C++ 中向函数传参的方式有哪些？

    + 传值调用：该方法把参数的实际值赋值给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。
    + 指针调用：该方法把参数的地址赋值给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。
    + 引用调用：该方法把参数的引用赋值给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。

    > 实际上，C++ 使用**传值调用**来传递参数，在编译器实现上，引用传递可以当作匿名指针看待

24. Lambda 函数基本格式是怎样的，捕获列表语法规则？

    捕获列表语法规则如下：

    ```
    [capture] (parameters) mutable -> return-type {body}
    []      // 沒有定义任何变量。使用未定义变量会引发错误。
    [x, &y] // x以传值方式传入（默认），y以引用方式传入。
    [&]     // 任何被使用到的外部变量都隐式地以引用方式加以引用。
    [=]     // 任何被使用到的外部变量都隐式地以传值方式加以引用。
    [&, x]  // x显式地以传值方式加以引用。其余变量以引用方式加以引用。
    [=, &z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。
    ```

    > 对于 [=] 或 [&] 的形式，lambda 表达式可以直接使用 this 指针

25. 如何使用 rand() 函数产生均匀的 [range_min, range_max) 随机数？

    + rand() % (range_max - range_min) + range_min
    + rand() * 1.0 / (RAND_MAX + 1) * (range_max - range_min) + range_min

    > 第二种方法更为准确，也可以使用 cpp 提供的 random 库提供随机数

26. C++ 中字符串的表示形式有哪些？

    1. C 语言风格的字符串，使用 const char * str = "";
    2. C++ 自带的 string 库，提供了更多的方法支持
    3. C++ 提供了原始字符串，使用 R"()" 开头，可自定义分隔符

    > C++ 还提供了字符串前缀，如 L，u，U，u8 分别表示 wchar_t，char16_t，char32_t，char

27. C++ 指针是什么，如何进行空指针赋值？

    **指针**是一个变量，其值为另一个变量的地址，可以使用 NULL 或者 nullptr 来进行空指针赋值，推荐使用 nullptr 进行复制，因为 NULL 可能产生重载二义性问题。

28. 指针的算术运算意义？

    实际上进行了重载，+1 表示指针指向的地址进行 sizeof(*p) 的偏移，而非加 1。

29. 指针数组和数组指针的区别和定义？

    + int *ptr[3]：指针数组，[] 运算优先级高于 *
    + int (*ptr)[3]：数组指针，ptr 指向类型是 int[3]

30. C++ 支持在函数外返回局部变量的地址吗？

    C++ 不支持在函数外返回局部变量的地址，除非定义局部变量为 static变量。

31. 
