---
title: Cpp 面试题目汇总
date: 2023-03-20 09:32:06
tags: ["Cpp"]
hidden: [true]
---





文本文用于整理学习 Cpp 时遇到的疑问和解答，以及一些面试题目，以备查阅。

<!-- More -->



## 相关问题

1. C++ 静态库和动态库在链接时有何不同？

   静态库：将可重定位目标文件以一种特定的方式打包成一个单独的文件，并且在链接生成可执行文件时，从这个单独的文件中“拷贝”它自己需要的内容到最终的可执行文件中。

   动态库：动态库和静态库类似，但是它并不在链接时将需要的二进制代码都“拷贝”到可执行文件中，而是仅仅“拷贝”一些重定位和符号表信息，这些信息可以在程序运行时完成真正的链接过程。gcc 编译时默认使用的方式。

   动态库链接可以减少可执行文件的大小，并且动态库发生修改时，只需要修改动态库即可，而静态库链接则需要重新编译所有可执行程序，静态库唯一的优点是代码执行速度较快，因为运行时不需要进行动态加载过程。

2. 谈谈如何将依赖与 cmath 库的 main.cpp 进行编译生成可执行文件的过程？

   1. 首先进行预处理，包括宏处理，include 指令处理等，得到编译单元
   2. 对于处理过的编译单元进行编译，生成目标代码，但是此时还不能运行
   3. 目标代码和 cmath 库以及**启动代码**进行链接，得到可执行文件

3. include 编译指令的作用？

   用于将头文件的内容添加到当前的源代码程序中，这是一种典型的预处理器操作：在源代码被编译之前，替换或添加文本。

4. C++ 中程序必须从 main 函数开始执行吗？

   这是由编译器决定的，实际上可以进行改动，如果使用 GCC 的话，可以通过attribute 关键字声明 constructor 和 destructor（类似 hook 函数）来观察到程序在执行 main 函数前后的过程。

   GCC中默认main 就是 C 语言的入口函数，在 main 函数启动之前，内核会调用一个特殊的启动例程（启动代码），这个启动例程从内核中取得命令行参数值和环境变量值，为调用 main 函数做好准备。

5. main 函数执行完后，还会调用执行其他的语句吗？

   可以通过调用 atexit 函数来登记这些函数，当程序正常终止时，调用已经登记的函数 **func**。您可以在任何地方注册你的终止函数，但它会在程序终止的时候被调用。另外，也可以通过 attribute((destructor)) 来声明退出 main 函数后应该执行的函数，该方式运行顺序在 atexit 中的函数运行之后。

6. C++ 语言支持的编程范式以及简介？

   C++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程，是一种中级语言，综合了高级语言和低级语言的特点。

7. C 和 C++ 有什什么区别？

   C++ 是 C 语言的超集，其区别有：

   + C++ 是支持多种编程范式，而 C 是面向过程的语言；
   + C++ 引入 new/delete 运算符，取代了 C 中的 malloc/free 库函数； 
   + C++ 引入引用的概念，而 C 中没有； 
   + C++ 引入类的概念，而 C 中没有； 
   + C++ 引入函数重载的特性，而 C 中没有

8. 面向对象开发的四大特性？

   + **封装（Encapsulation）**：封装是将数据和方法组合在一起，对外部隐藏实现细节，只公开对外提供的接口。
   + **继承（Inheritance）**：继承是从已有类中派生出新类，新类具有已有类的属性和方法，并且可以扩展或修改这些属性和方法。
   + **多态（Polymorphism）**：多态是指同一种操作作用于不同的对象，可以有不同的解释和实现。
   + **抽象（Abstraction）**：抽象是从具体的实例中提取共同的特征，形成抽象类或接口，以便于代码的复用和扩展。

9. g++ 常用命令选项？

   | 选项    | 解释                                                         |
   | :------ | :----------------------------------------------------------- |
   | -ansi   | 只支持 ANSI 标准的 C 语法。这一选项将禁止  asm 或 typeof 关键词。 |
   | -c      | 只编译并生成目标文件。                                       |
   | -DDEF   | 以字符串 "1" 定义 DEF 宏。                                   |
   | -DDEF=V | 以字符串 "V" 定义 DEF 宏。                                   |
   | -UDEF   | 取消对 DEF 宏的定义。                                        |
   | -E      | 只运行 C 预编译器。                                          |
   | -g      | 生成调试信息。GNU 调试器可利用该信息。                       |
   | -IDIR   | 指定额外的头文件搜索路径 DIR。                               |
   | -LDIR   | 指定额外的函数库搜索路径 DIR。                               |
   | -lLIB   | 连接时搜索指定的函数库 LIB。                                 |
   | -o      | FILE 生成指定的输出文件。用在生成可执行文件时。              |
   | -O0     | 不进行优化处理。                                             |
   | -O1     | 优化生成代码。                                               |
   | -O2     | 进一步优化。                                                 |
   | -O3     | 比 -O2 更进一步优化，包括 inline 函数。                      |
   | -shared | 生成共享目标文件。通常用在建立共享库时。                     |
   | -static | 禁止使用动态库（共享库），只能使用静态库。                   |
   | -w      | 不生成任何警告信息。                                         |
   | -Wall   | 生成所有警告信息。                                           |

10. C++ 标识符起名规则？

   一个标识符以字母 A-Z 或 a-z 或下划线 _ 或美元符 `$` 开始，后跟零个或多个字母、下划线,数字和美元符 `$`。注意不能和保留字冲突。

   > 以两个下划线或下划线和大写字母打头的名称被保留给实现（编译器及其使用的资源）使用。以一个下划线开头的名称通常用作类的私有变量。

11. C++ 基本数据类型有哪些？

    bool，char，int，float，double，void，wchar_t（早期实现为 short int）。一些基本类型可以使用一个或多个类型修饰符进行修饰：signed，unsigned，short，long。C++ 规定了基本类型的最少 bit 数目：

    | type      | C++ standard （at least） |
    | --------- | ------------------------- |
    | char      | 8                         |
    | short     | 16                        |
    | int       | 16                        |
    | long      | 32                        |
    | long long | 64                        |

    > 在实际开发中，最好使用 uint32_t 这样知道大小的数据类型。

12. 变量类型间的自动转换规则？

    1. 若参与运算量的类型不同，则先转换成同一类型，然后进行运算。
    2. 转换按数据长度增加的方向进行，以保证精度不降低。
    3. 若两种类型的字节数相同，且一种有符号，一种无符号，**则转换成无符号类型**。
    4. 所有的浮点运算都是以双精度进行的，即使仅含 float 单精度量运算的表达式，也要先转换成 double 型，再作运算
    5. char 型和 short 型参与运算时，必须先转换成 int 型
    6. 在赋值运算中，赋值号两边量的数据类型不同时，赋值号右边量的类型将转换为左边量的类型。此时可能会产生截断

13. 变量的声明和定义有什么区别？

    变量的定义为变量分配地址和存储空间， 变量的声明不分配地址。一个变量可以在多个地方声明，但是只在一个地 方定义。加入 extern 修饰的是变量的声明，说明此变量将在文件以外或在文件后面部分定义。

14. 下列代码存在什么问题，如何改进？

    ```cpp
    for(auto i = vector.size() - 1; i >= 0; i--) {}
    ```

    auto 类型推导为 size_t，该类型是无符号数，该循环会发生下溢不可能中止。可以使用反向迭代器或者通过 `long i = vector.size() - 1` 来确保。

15. C++中 "\n" 与 endl 的区别是什么?

    "\n" 表示内容为一个回车符的字符串。std::endl 是流操作子，输出的作用和输出 "\n" 类似，但可能略有区别。std::endl 输出一个换行符，并立即刷新缓冲区。对于有输出缓冲的流（例如cout、clog），如果不手动进行缓冲区刷新操作，将在缓冲区满后自动刷新输出。不过对于 cout 来说（相对于文件输出流等），缓冲一般体现得并不明显。但是必要情况下使用 endl 代替 '\n' 一般是个好习惯。对于无缓冲的流（例如标准错误输出流cerr），刷新是不必要的，可以直接使用 '\n'。

16. 位域有何作用？

    通常用在结构体中 `struct data {char a : 4; char b : 4;}`，表示某个变量有几位数据，用于节省内存，当然也可以通过整型和位运算实现相同效果（如 Java）。

17. 下列代码存在问题吗，为什么？

    ```cpp
    for(auto& b : vector_bool) { b = !b; }
    ```

    存在问题，vector_bool 内部是按照 bit 来存储 bool 变量的，得到的是一个 bit_reference，该内存是临时性的，不能被引用用于修改。另外，采用了位域声明的变量也不可被引用。

18. include 时 `<>` 和 `""` 区别？

    **`<>`** 先去系统目录中找头文件，如果没有找到再在当前目录下找。**`" "`** 首先在当前目录下寻找，如果找不到，再到系统目录中寻找，这个用于 include 自定义的头文件，让系统优先使用当前目录中定义的。

19. `::` 在 C++ 中的作用有哪些？

    在 C++ 中表示作用域和所属关系。 **::** 是运算符中等级最高的，它分为三种：

    1. **作用域符号：**前面一般是类名称或者命名空间，后面一般是该作用域里面的成员名称
    2. **全局作用域符号：**当全局变量在局部函数中与其中某个变量重名，可以用 **::** 来区分
    3. **作用域分解运算符：**在类外定义A 的成员函数 f 时，就要写成 voidA::f()

20. typedef 与 #define 的区别？

    1. 执行时机不同：typedef 在编译阶段有效，由于是在编译阶段，因此 typedef 有类型检查的功能。#define 则是宏定义，发生在预处理阶段，也就是编译之前，它只进行简单而机械的字符串替换，而不进行任何检查。
    2. 功能有差异：typedef 用来定义类型的别名，定义与平台无关的数据类型，\#define 不只是可以为类型取别名，还可以定义常量、变量、编译开关等。
    3. 作用域不同：#define 没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用。而 typedef 有自己的作用域。

21. typedef 和 using 的区别？

    都用于为类型定义平台无关的别名，便于程序移植，但是：

    + 使用 using 定义别名简单清晰，特别是在定义函数指针时
    + using 在模板环境下更为强大，可以用于模板部分具体化，如 `using pairInt = std::pair<int, T>;`，但是 typedef 不行

22. 如何处理变长参数模板？

    可以使用 `sizeof...` 运算符获取变长参数的个数，处理变长参数模板：

    + 递归定义：即定义一个单变量，再定义一个多变量模板
    + 变参展开：可以通过使用 `sizeof...(args) > 0` 来决定是否递归调用
    + 初始化列表展开：`std::initializer_list<T>{lambda, value}` ，不推荐

23. 折叠表达式作用？

    可以使用 `...` 表示剩余的表达式，更方便处理变长参数模板：

    `template<typename T> auto sum(T ... t) { return (t + ...); }`

24. 枚举类型的作用和缺点，以及其替代？

    是 C++ 中的一种派生数据类型，它是由用户定义的若干枚举常量的集合，默认从 0 开始，因此其枚举量实际上是整型变量，**参与运算时会自动执行隐式转换**，存在风险。可以考虑使用 enum class 替代，作用域内枚举不能隐式转换为整形数据，更加安全。

25. C++ 中有哪些类型转换？

    可以使用 C 风格的转换，即 `type (expr)` ，但是 C++ 推荐以下几种方式转换：

    + 静态转换（Static Cast）：用于基本数据类型之间的转换，或者类层次结构中基类和子类之间指针或引用的转换，只会在编译时检查，不进行任何运行时类型检查。
    + 动态转换（Dynamic Cast）：用于子类和父类之间的安全转换，可以实现向上向下转换，因为编译器默认向上转换总是安全的，而向下转换时， dynamic_cast 具有类型检查的功能。转换失败时，对于指针会返回目标类型的 nullptr ，对于引用会返回bad_cast 异常。
    + 常量转换（Const Cast）：用于转换掉 const，volatile 属性，不能改变对象的类型。
    + 重新解释转换（Reinterpret Cast）：用于不同类型指针之间、不同类型引用之间、指针和能容纳指针的整数类型之间的转换，不进行任何类型检查。**最不安全**

26. RTTI 是什么？其原理是什么？

    RTTI 即运行时类型识别，其功能由两个运算符实现：

    + typeid 运算符，用于返回表达式的类型，可以通过基类的指针获取派生类的数据类型
    + dynamic_cast 运算符，具有类型检查的功能，用于将基类的指针或引用安全地转换成派生类的指针或引用。

27. C++ 中的变量声明作用？

    变量声明向编译器保证变量以给定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能**继续进一步的编译**。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明和定义。可以使用 extern 来进行声明，声明是不会为变量开辟内存空间的。

28. C++ 全局变量、局部变量、静态全局变量、静态局部变量的区别？

    + 全局变量具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。
    + 静态全局变量也具有全局作用域，它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被 static 关键字修饰过的变量具有**文件作用域**。
    + 静态局部变量具有局部作用域，它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在，它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。
    + 局部变量也只有局部作用域，它是自动对象（auto），它在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回。

29. static 关键字有什么作用？

    + 修饰局部变量时，使得该变量在静态存储区分配内存；只能在首次函数调用中进行首次初始化，之后的函数调 用不再进行初始化；其生命周期与程序相同，但其作用域为局部作用域，并不能一直被访问；
    + 修饰全局变量时，使得该变量在静态存储区分配内存；在声明该变量的整个文件中都是可见的，而在文件外是 不 可见的
    + 修饰函数时，在声明该函数的整个文件中都是可见的，而在文件外是不可见的，从而可以在多人协作时避免同 名的函数冲突
    + 修饰成员变量时，所有的对象都只维持一份拷贝，可以实现不同对象间的数据共享；不需要实例化对象即可访 问；不能在类内部初始化，一般在类外部初始化，并且初始化时不加 static ；
    + 修饰成员函数时，该函数不接受 this 指针，只能访问类的静态成员；不需要实例化对象即可访问

30. 宏定义 #define 和 const 的区别？

    1. 类型和安全检查不同：宏定义是字符替换，没有数据类型的区别；const 常量是常量的声明，有类型区别，需要在编译阶段进行类型检查
    2. 编译器处理不同：宏定义是一个"编译时"概念，在预处理阶段展开；const 常量是一个"运行时"概念，在程序运行使用，类似于一个只读数据
    3. 存储方式不同：宏定义是直接替换，不会分配内存，存储于程序的代码段中；const常量需要进行内存分配，存储于程序的数据段中
    4. 定义后能否取消：宏定义可以通过 #undef 来使之前的宏定义失效，const常量定义后将在定义域内永久有效
    5. 是否可以做函数参数：宏定义不能作为参数传递给函数；const 常量可以在函数的参数列表中出现

31. const 关键字在修饰指针时，有哪几种形式，分别有什么效果？

    1. const 关键字出现在 ***** 的左边：指针指向的内容不能被修改。
    2. const 关键字出现在 ***** 的右边：指针本身不能被修改。
    3. const 关键字出现在 ***** 的两边：指针指向的内容和指针本身都不能被修改。

    > 指针指向的内容并非不可修改，只是无法通过该指针进行修改，可以通过赋值等方法改变其指向的内容

32. 悬挂指针与野指针有什么区别？

    + 悬挂指针：当指针所指向的对象被释放，但是该指针没有任何改变，以至于其仍然指向已经被回收的内存地 址，这种情况下该指针被称为悬挂指针； 
    + 野指针：未初始化的指针被称为野指针。

33. 如何避免悬挂指针和野指带来的危害？

    + 指针变量声明时没有被初始化。解决办法：指针声明时初始化，可以是具体的地址值，也可让它指向 NULL。
    + 指针 p 被 free 或者 delete 之后，没有置为 NULL。解决办法：指针指向的内存空间被释放后指针应该指向 NULL。
    + 指针操作超越了变量的作用范围。解决办法：在变量的作用域结束前释放掉变量的地址空间并且让指针指向 NULL。

34. C++ 中的类型限定符？

    | 限定符   | 含义                                                         |
    | :------- | :----------------------------------------------------------- |
    | const    | **const** 定义常量，表示该变量的值不能被修改。               |
    | volatile | 修饰符 **volatile** 告诉该变量的值可能会被程序以外的因素改变，如硬件或其他线程，每次读取必定从内存中进行读取。**不建议用于并发，推荐使用原子变量** |
    | mutable  | 表示类中的成员变量可以在 const 成员函数中被修改。            |
    | static   | 用于定义静态变量，表示该变量的作用域仅限于当前文件或当前函数内，不会被其他文件或函数访问。 |
    | register | 用于定义寄存器变量，表示该变量被频繁使用，可以存储在CPU的寄存器中，以提高程序的运行效率，但是实际上是否会存储在寄存器中由编译器决定 |

35. 一个参数可以既是 const 又是 volatile 吗？

    可以，用 const 和 volatile 同时修饰变量，表示这个变量在程序内部是只读的，不能改变的，只在程序外部条件变化 下改变，并且编译器不会优化这个变量。每次使用这个变量时，都要小心地去内存读取这个变量的值，而不是去寄 存器读取它的备份。注意：在此一定要注意 const 的意思，const 只是不允许程序中的代码改变某一变量，其在编译期发挥作用，它并没实际地禁止某段内存的读写特性。

36. C++ 可执行文件怎么进行分段的？

    主要分为 text，data（已初始化数据），bss（未初始化数据），heap，stack。

37. bss 段与 data 段的区别？

    在初始化时 bss 段部分将会清零。bss 段属于静态内存分配，即程序一开始就将其清零了。比如，在 C 语言之类的程序编译完成之后，已初始化的全局变量保存在 .data  段中，未初始化的全局变量保存在 .bss 段中。

    - text 和 data 段都在**可执行文件中**，由系统从可执行文件中加载；
    - 而 bss 段**不在可执行文件中**，由系统初始化。

38. `extern "C"` 的作用是什么？

    extern "C" 的主要作用就是为了能够正确实现 C++ 代码调用其他 C 语言代码。加上 extern "C" 后，会指示编译器这部分 代码按 C 语言（而不是C++）的方式进行编译：由于 C++ 支持函数重载，因此编译器编译函数的过程中会将函数的 参 数类型也加到编译后的代码中，而不仅仅是函数名；而 C 语言并不支持函数重载，因此编译 C 语言代码的函数时不 会带 上函数的参数类型，一般只包括函数名。

    其作用可以实现 C++ 和 C 的混合编程，并且可以更好地兼容原有的 C 语言库。

39. C++ 存储数据的方案有哪些？

    + 自动存储：在函数定义中声明的变量（包括函数参数）的存储持续性为自动的。它们在程序开始执行其所属的函数或代码块时被创建，在执行完函数或代码块时，它们使用的内存被释放。
    + 静态存储：在函数定义外定义的变量和使用关键字 static 定义的变量的存储持续性都为静态。它们在程序整个运行过程中都存在。
    + 线程存储：如果变量是使用关键字 thread_local 声明的，则其生命周期与所属的线程一样长。
    + 动态存储：用 new 运算符分配的内存将一直存在，直到使用 delete 运算符将其释放或程序结束为止。这种内存的存储持续性为动态，有时被称为自由存储（free store）或堆（heap）。

40. 如何理解 C++ 中的对象和值两个概念？

    + **值** 是一个纯粹的数学抽象概念，比如数字 `10` ，或者字符 `'a'` , 或者布尔值 `false` ，等等。它们完全不需要依赖于计算机或者内存而存在，就只是一个纯粹的值：不需要存储到内存，当然也就不可修改。那么 `1+2` 呢？这是一个表达式，但这个表达式的求值结果也是一个 **值** 。因而，这是一个值类别的表达式 。
    + **对象** 是一个在内存中占据了一定空间的有类型的东西。因而，它必然是与计算机内存这个物理上具体存在的设备关联在一起的一个物质。因而，每一个对象都必然有一个 **标识** （ Identifier ），从而你可以知道这个对象在内存中唯一的起始位置。

    区分 **对象** 和 **值** 的方法非常简单：是否有 **标识** ，或可否被 **引用** （毕竟引用就是一种标识）。

41. 值和对象的关系是怎样的？

    很简单， **值** 用来初始化 **对象** 。比如： `bool b = true` , 其语意是：用值 `true` 初始化对象 `b` ；**对象** 表示内存中的一段有类型的空间， **值** 这则是个空间里的内容。 用 **值** 来初始化 **对象** 的过程， 是一个将值加载到空间的隐喻。

42. 纯右值如何理解，其作用是什么？

    所有的 **值** 语意的表达式，都归类为 **纯右值** ，在 C++11 之前，它们被称做 **右值** 。其存在的唯一的目的，是为了初始化 **对象** 。单独写一个 **纯右值** 表达式的语句，比如： `1+2;` ，或者 `true && (1 == 2);` ，这样的表达式被称做 `弃值表达式` 。从语意上，它们仍然会初始化一个临时对象，而临时对象也是泛左值。

43. 泛左值如何理解？

    与 **纯右值** 对应的是 **泛左值** （ glvalue ）。整个表达式的世界被分为这两大类别。前者全部是 **值** 语意，后者全部是 **对象** 语意。泛左值分为：

    + 左值：任何可以对其通过符号 `&` 取地址的表达式，都属于 **左值** 。因而，任何变量（包括常量），无论是全局的，还是类成员的，还是函数参数，还是函数名字，都肯定属于左值。所有返回值是左值引用的函数调用表达式（包括用户自定义的重载操作符），以及 `static_cast<T&>(expr)` 都必然也属于左值。毕竟，没有内存中的对象，哪里来的引用？最为特殊的是字符串字面常量，比如： `"abcd"` ，这是一个左值对象。这有点违背直觉，但由于 C/C++ 中字符串并不是一个 builtin 基本类型。这些字符串字面常量都会在内存中得以存储。
    + 速亡值：速亡值是所有返回类型为 **右值引用** 的非左值表达式。 这包括返回值类型为 **右值引用** 的函数调用表达式，`static_cast<T&&>(expr)` 表达式。其所引用的对象，从理论上同样也是可以取其地址的。其目的是为了初始化类型为 **右值引用** 类型的变量。借此，也可以匹配参数类型为右值引用的函数。 一旦允许取其地址，程序的其它部分将无从判断，一个地址来自于速亡值对象，从而让速亡值的存在失去了本来的意义。 因而，对其取地址操作被强行禁止。

44. 将亡值是什么？

    将亡值是在 C++ 11 中跟右值引用相关的表达式，这种表达式通常是被移动的对象，比如返回右值引用 T&& 的函数返回值，std::move 的返回值，或者转换为 T&& 的类型转换函数的返回值。

45. `Foo foo = Foo{10}` 与 `Foo foo{10}` 在 C++ 17 前后有何不同？

    在 C++17 前，`Foo{10}` 表达的是一个临时对象，那么 `copy/move` 构造语意也就变得不可避免，尽管其可能会被编译器给优化掉；

    在 C++ 17 后，对于类似于 `Foo{10}` 表达式的语意进行了重新定义， 它们不再是一个 **对象** 语意，而只是一个 **值** 。即 `Foo{10}` 与内存临时对象再无任何关系，它就是一个 **值** ： 其估值结果，是对构造函数 `Foo(int)` 进行调用所产生的 **值** 。而这个 **值** ，通过等号表达式，赋值给左边的 **对象** 。从语义上，不再有对象间的 `copy/move` ，而是直接将构造函数调用表达式作用于等号左边的 **对象** ， 从而完成用 **值** 初始化 **对象** 的过程。因而， `Foo foo = Foo{10}` ，与 `Foo foo{10}` ， 在 C++17 之后，从语意上（而不是编译器优化上）完全等价。

46. 什么是纯右值物质化？`Foo&& foo = Foo{10}` 表达了什么语意？

    按照我们之前的讨论，等号右边是一个 **值** ， 而左边是一个对于对象的 **引用** 。而 **引用** 只能引用一个对象，引用一个 **值** 是逻辑上是讲不通的。这中间隐含着一个过程： **纯右值物质化** 。即将一个 **纯右值** ， 赋值给一个 **临时对象** ，即 **速亡值** 。然后再将等号左边的 **引用** 绑定到这个 **速亡值** 对象上。

    <img src="Cpp-面试题目汇总/obj-value-2.png" alt="_images/obj-value-2.png" style="zoom:30%;" />

47. 关于 C++ 中的值，需要注意哪些？

    - 所有的表达式都可以归类为 **纯右值** 和 **泛左值** ；
    - 所有的 **纯右值** 都是 **值** 的概念；所有的 **泛左值** 都是 **对象** 的概念；
    - **左值** 可以求地址，**速亡值** 不可以求地址；
    - **纯右值** 在需要临时对象存在的场景下，会通过 **物质化** ，转化成 **速亡值** 。
    - **泛左值** 可以是抽象类型和不完备类型，可以进行多态调用；**纯右值** 只能是具体类型，无法进行多态调用。
    - 用 **纯右值** 构造一个 **左值** 对象时，是 **直接构造** 语意； 用 **速亡值** 构造一个 **左值** 对象时，是 **拷贝/移动构造** 语意。

48. C++ 中的左值（Lvalues）和右值（Rvalues）？

    + **左值（lvalue）：**指向内存位置的表达式被称为左值（lvalue）表达式，**任何可以取地址的表达式**，都是左值。左值可以出现在赋值号的左边或右边。
    + **右值（rvalue）：**术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。

49. 如何理解移动（move）语义？

    传统 C++ 通过拷贝构造函数和拷贝赋值操作符为类对象设计了拷贝/复制的概念，但为了实现对资源的移动操作， 调用者必须使用先复制、再析构的方式，否则就需要自己实现移动对象的接口。 试想，搬家的时候是把家里的东西直接搬到新家去，而不是将所有东西复制一份（重买）再放到新家、 再把原来的东西全部扔掉（销毁），这是非常反人类的一件事情。

    传统的 C++ 没有区分**移动**和**拷贝**的概念，造成了大量的数据拷贝，浪费时间和空间。 右值引用的出现恰好就解决了这两个概念的混淆问题。

50. 已经有了左值引用，为什么还需要右值引用，右值引用有何作用？

    右值引用的主要目的是为了实现转移语义和完美转发，消除两个对象交互时不必要的对象拷贝，也能够更加简洁明确地定义泛型。函数右值引用可以解决 STL 模板有些实现存在的效率问题，通过右值引用我们可以将其绑定到一个将亡值，便可以节省一次复制的开销，**实现更高效的 move 语义**。可以使用 std::move 实现强制的右值转换。**constness** 和 **引用** 的 **对象类别** 组合在一起，一共能产生四种类型的引用：

    + const lvalue reference：通过 const Foo& 匹配
    + non-const lvalue reference：通过 Foo& 匹配，当然可以通过 const Foo& 匹配
    + const rvalue reference：通过 const Foo& 匹配
    + non-const rvalue reference：通过 `Foo&&` 匹配

51. 右值是否可以匹配到左值引用类型参数？

    +  一个右值，可以被类型为 `const T&` 类型的参数匹配；
    + 但一个右值，不能被 `T&` 类型的参数匹配；修改一个调用后即消失的 **临时对象** ，没有任何意义，反而会导致程序员犯下潜在的错误，因而还是禁止了最好。

52. 使用右值类型变量有什么需要注意的？

    1. 对于任何类型为 **右值引用** 的变量（当然也包括函数参数），只能由 **右值** 来初始化；**右值** 包括 **纯右值** 和 **速亡值** ，其中 **速亡值** 的类型是 **右值引用** ；
    2. 一旦初始化完成， **右值引用** 类型的变量，其性质与一个 **左值引用** 再也没有任何差别。类型为 **右值引用** 的变量，是一个 **左值** ，因而不能赋值给其它类型为 **右值引用** 的变量， 当然也不能匹配参数类型为 **右值引用** 的函数。如果想要保持其右值语义，可以考虑使用 std::move 函数。

53. 模板函数中的使用 `T&&` 一定能匹配到右值引用吗？

    不一定，模板中的 `T&&` 是通用引用，既可以匹配左引用又可以匹配右引用。在传统 C++ 中，我们不能够对一个引用类型继续进行引用， 但 C++ 由于右值引用的出现而放宽了这一做法，从而产生了引用坍缩规则，允许我们对引用进行引用， 既能左引用，又能右引用。但是却遵循如下规则：

    | 函数形参类型 | 实参参数类型 | 推导后函数形参类型 |
    | :----------- | :----------- | :----------------- |
    | T&           | 左引用       | T&                 |
    | T&           | 右引用       | T&                 |
    | T&&          | 左引用       | T&                 |
    | T&&          | 右引用       | T&&                |

    **无论模板参数是什么类型的引用，当且仅当实参类型和形参类型为右引用时，模板参数才能被推导为右引用类型**。

54. 完美转发是什么意思？

    不论参数类型是左值引用还是右值引用，参数始终是左值，在通过该参数调用其他函数时，只会匹配到左引用形参，不可能匹配到右引用形参。所谓完美转发，就是为了让我们在传递参数的时候， 保持原来的参数类型（左引用保持左引用，右引用保持右引用）。 为了解决这个问题，我们应该使用 `std::forward` 来进行参数的转发（传递），其内部实现和 `static_cast<T&&>(v)` 相同，通常使用在通用引用函数模板中。

55. 函数指针 pf 如何进行方法调用？

    通过 `pf()` 或者 `(*pf)()` 都可以，一种学派认为，由于 pf 是函数指针，而`*pf`是函数，因此应将`(*pf)()`用作函数调用。另一种学派认为，由于函数名是指向该函数的指针，指向函数的指针的行为应与函数名相似，因此应将`pf()`用作函数调用使用。C++进行了折衷。

56. explict 关键字的作用？

    C++ 中， 一个参数的构造函数(或者除了第一个参数外其余参数都有默认值的多参构造函数)， 承担了两个角色： 构造器，隐含的类型转换操作符（A = xxx）。C++ 提供了关键字 explicit，可以阻止不应该允许的经过转换构造函数进行的隐式转换的发生。另外，也可以作用在转换函数上，防止隐式调用转换函数。

57. thread_local 作用？

    使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。

58. 算术运算符 ++d 和 d++ 的区别？

    + **++d** 是**先加**，先对 d 的值加 1，再使用 d 的值执行该行命令。
    + **d++** 是**后加**，先使用 d 的值执行该行命令，执行完后再对 d 的值加 1。

59. C++ 中向函数传参的方式有哪些？

    + 传值调用：该方法把参数的实际值赋值给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。可能伴随着拷贝构造函数的调用。
    + 指针调用：该方法把参数的地址赋值给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。
    + 引用调用：该方法把参数的引用赋值给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。

    > 实际上，C++ 使用**传值调用**来传递参数，在编译器实现上，引用传递可以当作匿名指针看待

60. Lambda 函数基本格式是怎样的，捕获列表语法规则？

    捕获列表语法规则如下：

    ```cpp
    [capture] (parameters) mutable -> return-type {body}
    []      // 沒有定义任何变量。使用未定义变量会引发错误。
    [x, &y] // x以传值方式传入（默认），y以引用方式传入。
    [&]     // 任何被使用到的外部变量都隐式地以引用方式加以引用。
    [=]     // 任何被使用到的外部变量都隐式地以传值方式加以引用。
    [&, x]  // x显式地以传值方式加以引用。其余变量以引用方式加以引用。
    [=, &z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。
    [status=std::move(res_status)] //表达式捕获，可对右值进行捕获，其为匿名类成员
    ```

    > 对于 [=] 或 [&] 的形式，lambda 表达式可以直接使用 this 指针

61. 如何使用 rand() 函数产生均匀的 [range_min, range_max) 随机数？

    + rand() % (range_max - range_min) + range_min
    + rand() * 1.0 / (RAND_MAX + 1) * (range_max - range_min) + range_min

    > 第二种方法更为准确，也可以使用 cpp 提供的 random 库提供随机数

62. C++ 中字符串的表示形式有哪些？

    1. C 语言风格的字符串，使用 const char * str = "";
    2. C++ 自带的 string 库，提供了更多的方法支持
    3. C++ 提供了原始字符串，使用 R"()" 开头，可自定义分隔符

    > C++ 还提供了字符串前缀，如 L，u，U，u8 分别表示 wchar_t，char16_t，char32_t，char，对应的字符串是 wstring, u16string, u32string, string

63. C++ 指针是什么，如何进行空指针赋值？

    **指针**是一个变量，其值为另一个变量的地址，可以使用 NULL 或者 nullptr 来进行空指针赋值，推荐使用 nullptr 进行复制，因为 NULL 可能产生重载二义性问题。

64. 指针的算术运算意义？

    实际上进行了重载，+1 表示指针指向的地址进行 sizeof(*p) 的偏移，而非加 1。

65. nullptr 为什么被引入 C++？

    传统 C++ 可能将 NULL 定义为 `void *`，并且规定了 **不允许 **直接将 `void *` 隐式转换到其他类型，但是这样的语句却是合理的：`char *ch = NULL`；

    因此只能将 NULL 定义成 0L，但是这样又会带来重载的问题，即 `foo(NULL)` 将优先匹配 `foo(long/int)` 而不是 `foo(void *)`。

    为了解决这个问题，C++11 引入了 `nullptr` 关键字，专门用来区分空指针、`0`。并且其能够隐式的转换为任何指针或成员指针的类型。

66. 指针数组和数组指针的区别和定义？

    + int *ptr[3]：指针数组，**[] 运算优先级高于 ***
    + int (*ptr)[3]：数组指针，ptr 指向类型是 int[3]

67. C++ 支持在函数外返回局部变量的地址吗？

    C++ 不支持在函数外返回局部变量的地址，除非定义局部变量为 static 变量。

68. static_assert 和 assert 有何区别？

    static_assert 声明在编译时测试软件断言。 相反，assert (CRT) 宏在运行时测试软件断言，并会导致增大运行时花费的空间和时间，因此，assert 主要用在 debug 版本开发中。

69. C++ 引用是什么，和指针有什么区别？

    引用变量是一个**别名**，也就是说，它是某个已存在变量的另一个名字。和指针区别：

    - 不存在空引用，引用必须连接到一块合法的内存。
    - 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。
    - 引用必须在创建时被初始化，指针可以在任何时间被初始化。

    > 使用引用作为参数可以避免检查空引用的语句，如何使用指针则需要检查空指针

70. C++ 引用有哪些特点？

    1. 引用是对象的别名，对于引用的一切操作都是对对象的操作；
    2. 引用自身从概念上没有大小（或者就是对象的大小）；**但引用在传递或需要存储时，其传递或存储的大小为地址的大小**（在编译期内部实现上和指针相同）。
    3. 引用必须初始化；
    4. 引用不可能重新绑定；
    5. 将指针所指向的对象绑定到一个引用时，需要确保指针非空。
    6. 任何引用类型的变量，都是左值，即便其是右值引用。

71. 引用作为函数返回值有哪些优点和局限？

    优点是在内存中不产生被返回值的副本，局限如下：

    + 不能返回局部变量的引用。主要原因是局部变量会在函数返回后被销毁，因此被返回的引用就成为了"无所指"的引用，程序会进入未知状态。
    + 不能返回函数内部 new 分配的内存的引用。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部 new 分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一 个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由 new 分配）就无法释放，造成 memory leak。
    + 可以返回类成员的引用，但最好是 const。主要原因是当对象的属性是与某种业务规则（business rule）相关联的时候，其赋值常常与某些其它属性或者对象的状态有关，因此有必要将赋值操作封装在一个业务规则当中。如果其它对象可以获得该属性的非常量引用（或指针），那么对该属性的单纯赋值就会破坏业务规则的完整性。

72. C++ 获取当前日期和时间的方法有哪些？

    其继承了 C 语言中处理时间的方法，主要通过 ctime 库提供，可以通过 strftime 或者 snprintf 进行格式化输出。

73. C++ 类中有哪些特殊的函数？

    默认构造函数、复制构造函数、复制赋值运算符和析构函数，C++11 新增移动构造函数和移动赋值运算符函数。

74. C++ 类和结构体的区别？

    + class 中默认的成员访问权限是 private 的，而 struct 中则是 public 的。
    + 从 class 继承默认是 private 继承，而从 struct 继承默认是 public 继承。

75. inline 与宏定义的关系？

    C 语言使用预处理器语句 #define 来提供宏来实现内联代码，但是需要注意其仅仅是完成文本替换，可能存在问题如 `SQUARE(i++)`，inline 则具有返回值检查等功能。

76. 成员函数定义在类定义内部或者外部有什么区别？

    在类定义中定义的成员函数把函数声明为**内联**的，即便没有使用 inline 标识符。inline 作用是消除函数调用过程，提高运行速度，适用于函数体较小的成员函数。

    > 内联声明只是建议，是否内联由编译器决定，所以实际并不可控。

77. C++ 类访问修饰符有哪些？

    + public：**公有**成员在程序中类的外部是可访问的。
    + private：**私有**成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有类和友元函数可以访问私有成员。
    + protected：与私有成员十分相似，但有一点不同，protected（受保护）成员在派生类（即子类）中是可访问的。

78. C++ 类的三种继承方式有什么不同？

    | 继承方式  | 基类的public成员 | 基类的protected成员 | 基类的private成员 | 继承引起的访问控制关系变化概括       |
    | :-------- | :--------------- | :------------------ | :---------------- | :----------------------------------- |
    | public    | public           | protected           | 不可见            | 基类的非私有成员在子类的访问属性不变 |
    | protected | protected        | protected           | 不可见            | 基类的非私有成员都为子类的保护成员   |
    | private   | private          | private             | 不可见            | 基类的非私有成员都为子类的私有成员   |

79. C++ 类构造函数和析构函数的作用，有何不同？

    类的**构造函数**是类的一种特殊的成员函数，它会在每次创建类的新对象时执行，用于执行一些初始化的工作；类的**析构函数**是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行，用于清理资源。

    构造函数可以存在多个，但是析构函数只能存在一个。

80. 为什么基类的析构函数一定是 virtual 声明的？

    为了防止内存泄漏。 由于类的多态性，基类指针可以指向派生类的对象，如果删除该基类的指针，就会调用该指针指向的派生类析构函 数，而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放。如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样 就会造成派生类对象析构不完全，造成内存泄漏。所以将析构函数声明为虚函数是十分必要的。在实现多态时，当用基类操作派生类，在析构时防止只析构基类而不析构派生类的状况发生，要将基类的析构函数声明为虚函数。

81. 构造函数和析构函数能抛出异常吗？

    + 从语法的角度来说，构造函数可以抛出异常，但从逻辑和风险控制的角度来说，尽量不要抛出异常，否则可能导致内存泄漏。
    + 析构函数不可以抛出异常，如果析构函数抛出异常，则异常点之后的程序，比如释放内存等操作，就不会被执行，从而造成内存泄露的问题；而且当异常发生时，C++ 通常会调用对象的析构函数来释放资源，如果此时析构函数也抛出异常，即前一个异常未处理又出现了新的异常，从而造成程序崩溃的问题。

82. C++ 为成员变量初始化的方式？

    + 声明时初始化：C++11 开始支持
    + 初始化列表：和书写顺序无关，按照**成员声明顺序进行初始化**的
    + 构造函数初始化

83. C++ 列表初始化有什么优点？

    C++11 将使用大括号的初始化称为初始化列表（list-initialization），因为这种初始化常用于给复杂的数据类型提供值列表。它对类型转换的要求更严格。具体地说，列表初始化不允许缩窄（narrowing），即不允许实参向形参的隐式缩窄转换。

84. 结构化绑定有何作用？

    配合 std::pair，std::tuple，以及使用 auto 类型推导，可以方便获取元组里面的每个变量：`auto& [a, b] = student_pair`。

85. 列表初始化和 std::initializer_list 关系？

    如果类有接受 initializer_list 作为唯一参数的构造函数（或者有其他默认参数），则列表初始化语法就只能用于该构造函数。

86. 拷贝构造函数的作用？

    是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。通常用于：

    + 通过使用另一个同类型的对象来初始化新创建的对象。
    + 复制对象，把它作为参数传递给函数。
    + 复制对象，并从函数返回这个对象（尽管编译器可能优化为移动构造）。

87. 为什么拷贝构造函数传递的是引用，而不是值？

    如果传入的是值，将会引起无限递归调用，另外还声明了 const，用于确保在复制构造过程中不修改被复制的对象。

88. 关于为什么当类成员中含有指针类型成员且需要对其分配内存时，一定要定义拷贝构造函数？

    默认的拷贝构造函数实现的只能是浅拷贝，即直接将原对象的非静态数据成员值依次复制给新对象中对应的数据成员，并没有为新对象另外分配内存资源。这样，如果对象的数据成员是指针，两个指针对象实际上指向的是同一块内存空间。就可能会导致释放相同空间两次而产生问题。

89. 如何防止默认拷贝发生？

    + **声明一个私有的拷贝构造函数**，这样因为拷贝构造函数是私有的，如果用户试图按值传递或函数返回该类的对象，编译器会报告错误，从而可以避免按值传递或返回对象。
    + 或者使用 `=delete` 来显式说明。

90. 友元函数/类有何作用？

    类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。

91. this 指针指代的是什么，当调用成员函数的时候，this 如何传入的？

    this 指向的是调用成员函数的对象，当调用成员函数的时候，this 被当作第一个参数进行传入，从而达到在函数中使用的目的，另外，this 可以当作是一个 const 指针，当执行 `obj.method(a, b)` 时，编译器会将其转换为 `method(this, a, b)` ，其中 this 指向的就是 obj 对象。

    > 静态成员函数第一个参数则不是 this 指针，其属于类层次的

92. C++ 中的静态成员变量和函数与普通的成员变量和函数有何不同？

    当我们声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本。静态成员可以看作是类成员而不是对象成员。

93. 派生类不继承基类中的哪些方法？

    - 基类的构造函数、析构函数和拷贝构造函数。
    - 基类的重载运算符。
    - 基类的友元函数。

    > 注意派生类可以继承基类的移动构造函数，移动赋值函数

94. 派生类在继承基类的成员变量时，是如何实现的？

    派生类在继承基类的成员变量时，会单独开辟一块内存保存基类的非静态成员变量，因此派生类自己的成员变量即使和基类的成员变量重名，但是也不会引起冲突。

95. 派生类中的变量与基类变量重名时，如何获取基类变量？

    可以通过 `derivedObj.Base::name` 进行获取。

96. 多继承存在什么问题？如何消除多继承中的二义性？

    + 增加程序的复杂度，使得程序的编写和维护比较困难，容易出错
    + 在继承时，基类之间或基类与派生类之间发生成员同名时，将出现对成员访问的不确定性，即同名二义性：可以通过 `::` 限定派生类使用那个基类成员，或者在派生类中定义同名成员，覆盖基类中的相关成员；
    + 当派生类从多个基类派生，而这些基类又从同一个基类派生，则在访问此共同基类的成员时，将产生另一种不确定性，即路径二义性：使用虚继承，使共同基类在内存中只有一份拷贝

97. 若存在环状继承时，需要如何处理？

    可以通过虚拟继承方式实现，这样得到顶层基类对象只有一个，符合语义，如下：

    ```cpp
    class A{......};
    class B: virtual public A{......};
    class C: virtual public A{......};
    class D: public B, public C{.....};
    ```

98. 重载运算符时，其被当作成员函数和非成员函数在参数上有何不同？

    当作成员函数时，默认的第一个参数是 this 指针，非成员函数时则需要显式定义该参数。常见的运算符重载技巧：

    + 重载前缀 ++ 和后缀 ++ 是不同的，重载后缀需要额外增加一个 int 参数
    + 重载加法时，如果两个对象类型不同（如 A 和 int），则需要额外定义一个友元函数来保证加法的交换律
    + 输入输出运算符重载时，最好定义为友元函数，同时返回对应的输入输出的引用
    + 重载函数调用运算符时，可以将其当作是函数对象使用，可以重载接收任意参数
    + 还可以定义 new，delete 等空间申请和释放操作符

99. 如何进行自定义字面量？

    重载双引号后缀运算符实现：

    ```cpp
    std::string operator"" _wow1(const char *wow1, size_t len) {
        return std::string(wow1)+"woooooooooow, amazing";
    }
    std::string operator"" _wow2 (unsigned long long i) {
        return std::to_string(i)+"woooooooooow, amazing";
    }
    ```

100. 哪些运算符不能进行重载？

     - .：成员运算符。
     - . *：成员指针运算符。
     - ::：作用域解析运算符。
     - ?:：条件运算符。
     - sizeof：sizeof 运算符。
     - typeid：一个 RTTI 运算符。
     - 类型转换：static_cast，dynamic_cast，reinterpret_cast，const_cast

101. typeid 的作用是什么？

     typeid 运算符能够获取对象的类型，其能够确定两个对象是否为同种类型，可以接受两种参数，类名和结果为对象的表达式，其返回值是 type_info 类对象，其重载了 `==`。

102. 如何为对象声明 << 重载符号以输出对象内容？

     `ostream& operator<<(ostream& out, Type a)` 可以实现重载。

103. 转换函数如何定义？

     `operator type_name()`，可以实现类的转换，添加关键字 explict 可以防止隐式转换。

104. 多态的实现有哪几种？

     多态分为静态多态和动态多态。其中，静态多态是通过重载和模板技术实现的，在编译期间确定；动态多态是通过虚函数和继承关系实现的，执行动态绑定，在运行期间确定。

105. 动态多态的实现？

     **虚函数** 是在基类中使用关键字 **virtual** 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为**动态链接**，或**后期绑定**。也可以通过`virtual void fun() = 0` 来定义纯虚函数，注意含有纯虚函数的对象不可被实例化，其为抽象类，只是定义了一个接口。

     每个含有虚函数的类都有各自的一张虚函数表 **VTABLE**。每个派生类的 VTABLE 继承了它各个基类的 VTABLE，如果基类 VTABLE 中包含某一项（虚函数的入口地址），则其派生类的 VTABLE 中也将包含同样的一项，但是两项的值可能不同。如果派生类中重载了该项对应的虚函数，则派生类 VTABLE 的该项指向重载后的虚函数，如果派生类中没有对该项对应的虚函数进行重新定义，则使用基类的这个虚函数地址。

     在创建含有虚函数的类的对象的时候，编译器会在每个对象的内存布局中增加一个 vptr 指针项，该指针指向本类的 VTABLE。在通过指向基类对象的指针（设为 bp）调用一个虚函数时，编译器生成的代码是先获取所指对象的 vtb1 指针，然后调用 vtb1 所指向类的 VTABLE 中的对应项（具体虚函数的入口地址）。

     > C++ 中**, 虚函数**可以为 private, 并且可以被子类覆盖（因为虚函数表的传递），但子类不能调用父类的 private 虚函数。虚函数的重载性和它声明的权限无关。

     <img src="Cpp-面试题目汇总/image-20230322135441948.png" alt="image-20230322135441948" style="zoom:67%;" />

106. 类对象大小是如何计算的？

     类对象所占内存大小是由成员变量（静态变量除外），虚函数表指针，虚基类指针以及基类成员大小决定的，成员函数是不计算在内的，成员函数可以被所有的类对象共享。需要注意：

     + 空类大小为 1 而不是 0，可以使这个空类的不同实例拥有独一无二的地址
     + 需要注意内存对齐问题
     + 静态变量不计入对象大小中

107. 为什么基类的构造函数不能定义为虚函数？

     虚函数的调用依赖于虚函数表，而指向虚函数表的指针 vptr 需要在构造函数中进行初始化，所以无法调用定义为虚函数的构造函数。

108. 继承时如何显式对基类对象进行初始化？

     使用初始化列表：`derived(x, y, z) : base(x, y)`进行初始化即可。

109. final 关键字有何作用？

     + 应用在虚函数上，表示不再允许该虚函数被子类重写
     + 应用在类上，表示不允许类被继承

110. C++ 是如何进行异常处理的？

     主要通过 `try catch throw` 实现，所有的异常继承自 std::exception，其中包含了一个 virtual 方法 what，派生类可以重写该方法来自定义异常产生的原因。

111. 什么是栈解退？

     假设函数由于出现异常（而不是由于返回）而终止，则程序也将释放栈中的内存，但不会在释放栈的第一个返回地址后停止，而是继续释放栈，直到找到一个位于 try 块中的返回地址。随后，控制权将转到块尾的异常处理程序，而不是函数调用后面的第一条语句。这个过程被称为栈解退。引发机制的一个非常重要的特性是，和函数返回一样，**对于栈中的自动类对象，类的析构函数将被调用**。

     ![image-20230322144747939](Cpp-面试题目汇总/image-20230322144747939.png)

112. noexcept 作用？

     C++11 后，给函数增加 noexcept 表示不会发生异常，否则表示可能会发生任意的异常。在 C++ 以前版本，也有通过 throw(E1, E2) 的方式来声明，但是现在很少使用。

113. new 和 malloc 内部的实现方式有什么区别？

     new 的功能是在堆区新建一个对象，并返回该对象的指针。所谓的**【新建对象】**的意思就是，将调用该类的构造函数，因为如果不构造的话，就不能称之为一个对象。而 malloc 只是机械的分配一块内存，如果用 malloc 在堆区创建一个对象的话，是不会调用构造函数的。malloc 只是申请了一块内存用于存放对象，而 new 不仅申请了内存，还会将对象初始化放入该内存中。

114. new，oprator new 和 placement new 操作符的区别？

     + new ：不能被重载，其行为总是一致的。它先调用 operator new 分配内存，然后调用构造函数初始化那段内存，最后返回对应指针
     + operator new：要实现不同的内存分配行为，应该重载 operator new，而不是 new。
     + placement new：只是 operator new 重载的一个版本。它并不分配内存，只是返回指向已经分配好的某段内存的一个指针。

     通常，new 负责在堆（heap）中找到一个足以能够满足要求的内存块，并进行初始化工作，placement new 让您能够指定要使用的内存位置，可以将其与初始化结合使用。

115. delete 与 delete[] 区别？

     针对简单类型，使用 new 分配后的不管是数组还是非数组形式内存空间用两种方式均可；但是使用类对象数组，则只能通过 delete[] 来进行释放，否则的话只会释放对象数组的第一个指针指向的内存。

116. override 作用是什么？

     在 C++11 中，可使用说明符 override 指出您要重写一个虚函数：将其放在参数列表后面。如果声明与基类方法不匹配，编译器将视为错误。

117. C++ 命名空间作用？

     可作为附加信息来区分不同库中相同名称的函数、类、变量等。使用了命名空间即定义了上下文。本质上，命名空间就是定义了一个范围。通常，使用在已命名的名称空间中声明的变量，而不是使用外部全局变量和静态全局变量。

118. C++ 中 typename 和 class 在模板定义中区别？

     最初使用 class 在模板中定义类型，为了避免混淆，引入了 typename 关键词，在模板定义语法中关键字 class 与 typename 的作用完全一样。但是 typename 另外一个作用为：使用嵌套依赖类型(nested depended name)，如下所示：`typedef typename T::LengthType LengthType;` 。

119. 模板中的非类型参数的作用？

     `template <typename T, int max_size>`：其中的 max_size 便是非类型参数，表达式参数可以是整型、枚举、引用或指针。可以使用 auto 代替 int 以进行参数推导。构造函数方法使用的是通过 new 和 delete 管理的堆内存，而表达式参数方法使用的是为**自动变量维护的内存栈**。这样，执行速度将更快，尤其是在使用了很多小型数组时。

120. 智能指针模板类有哪些，分别有何作用？

     智能指针的作用是管理一个指针（RAII），因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域时，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。

     + auto_ptr：采用所有权转让方式实现赋值运算，避免了两次释放相同地址空间的问题，但是 `auto_ptr<string> a = b` 会导致 b 丢失所有权，后面再次使用可能导致异常，在函数值传参经常会遇到，因此被 deprecated
     + unique_ptr：和 auto_ptr 类似，但是不支持拷贝语义，确保安全，编译时发现错误，但是支持移动语义
     + shared_ptr：采用引用计数的方式实现，计数为 0 时自动释放内存，可以通过 make_shared 来消除显式使用的 new
     + weak_ptr：为了配合 shared_ptr 而引入的一种智能指针，它指向一个由 shared_ptr 管理的对象而不影响所指对象的生命周期，也就是将一个weak_ptr 绑定到一个 shared_ptr 不会改变 shared_ptr 的引用计数。用于解决循环引用的问题，可以和 shared_ptr 相互转换，使用前通过 lock 即可转换为 shared_ptr 对象

121. shared_ptr 是如何实现的？

     通过引用计数的方式来实现多个 shared_ptr 对象之间共享资源，引用计数是多个智能指针对象共享的（通过 int* 实现）：

     1. 构造函数中计数初始化为 1；
     2. 拷贝构造函数中计数值加 1；
     3. 赋值运算符中，左边的对象引用计数减 1，右边的对象引用计数加 1；
     4. 析构函数中引用计数减 1；
     5. 在赋值运算符和析构函数中，如果减 1 后为 0，则调用 delete 释放对象。

122. decltype 作用？

      它允许求一切合法表达式的类型。从而，让从类型到值，从值到类型形成了一个闭环， 极大的扩展了泛型编程的能力。通过 decltype 来确定对应的变量类型，如 `decltype(expr) var`，还可以被用于后置返回类型中，确保模板正常实例化。

123. decltype 双括号和单括号版本的区别？

     对于双括号，语意是简单而统一的：它站在表达式类别的角度求类型：

     1. 如果表达式属于 **纯右值** ，结果必然是 **非引用** 类型；
     2. 如果表达式属于 **泛左值** ，结果必然是 **引用** 类型；
        - 如果表达式属于 **左值** ，结果必然是 **左值引用** ；
        - 如果表达式属于 **速亡值** ，结果必然是 **右值引用** ；

     对于单括号，除了一种例外，其它情况下，都与双括号场景一致：这个例外就是对于变量（包括常量）名字的直接求类型。这种情况，会返回变量被定义时的类型。

     之所以会出现有括号，无括号两种用法，正是因为每一个被定义的变量，都面临着两种需求：

     1. 它们被定义时的类型
     2. 整体做为一个表达式的类型（一定是泛左值）

     正是对于变量有这两种需求的存在，而其它表达式没有这样的问题，所以，才专门为变量定义了两种求类型的方法。而对于其它表达式则两种方式无差别。

124. auto 类型推演的语义是什么？

     在 C++17 之前，使用的都是 `copy/move` 语意，因此，对于任意表达式：`auto v = expr` ：

     + 首先，`auto` 不可能是一个 **引用** ，无论是 **左值引用** ，还是 **右值引用** ，所以，如果 `expr` 返回类型里包含任何引用，都会被舍弃。
     + 其次，所有对值所修饰的 `const` 都会被丢弃。

     到了 `C++17` 之后， 并非所有的场景下，都是 `copy/move` 语意， 比如 `auto v = Foo{1}` ， 其行为完全等价于： `Foo v{1}` 。因而，更准确的说，这不是 `copy/move` 语意，而属于**构造初始化语意**。

125. 如果想要使得自动类型推演得到引用或者 const 语义？

     希望让新定义的变量属于引用类型，或具备 `const` ，则需要明确指定。如 `const auto& ref = foo`，或者使用 `decltype(auto) a = expr` 来实现。

126. 通用引用指的是什么？

     更为特殊的是 `auto&& v = expr` 的表达式。这并不必然导致 `v` 是一个右值引用。而是取决于 `expr` 的类别。

     - 如果 `expr` 是一个 **左值** 表达式，那么 `v` 将是左值引用类型；
     - 如果 `expr` 是一个 **右值** 表达式，那么 `v` 将会是右值引用类型。

127. `auto i{1}` 和 `auto v = {1}`  有何区别？

     前者表示 `auto i = 1`，后者等价于 `std::initializer_list<int> v = {1}` 。

     > 因此，auto 不能用于推到数组类型，vector 类型等推导

128. `decltype(auto)` 有何作用？

     由于 `auto` 推演总是会丢弃 **引用** 及 `const` 信息，明确给出 **引用** 又总是得到一个引用。明确给出 `const` ， 则总是得到一个 `const` 类型。这对于想精确遵从等号后面类型的情况非常不便，尤其在进行泛型编程时，很难通过 auto 符合通用的情况。而 `decltype` 恰恰相反，它总是能准确捕捉右侧表达式的类型，`decltype(auto)` ， 其中 `auto` 是一个自动占位符，代表等号右侧的表达式。

129. auto 关键字还有何作用？

     除了用于**类型推演**，还可以用于对于普通函数的**返回值自动推演**，甚至可以**使用 auto 参数简化模板**，但是 auto 不保证变量类型的一致性。

130. C++ 初始化方式有哪些？

     + 直接初始化：使用 **圆括号** 初始化（构造）一个对象，或者，用 **圆括号** 或 **花括号** 来初始化一个 non-class 类型的数据时（基本类型，指针，枚举等，因而只可能是单参）时，参数允许窄向转换和隐式转换
     + 列表初始化：对于类来说，列表初始化（使用 **花括号** ），相对于直接初始化（使用 **圆括号** ），其差异主要体现在两个方面：如果类存在一个单一参数是 `std::initializer_list<T>` ，或者第一个参数是 `std::initializer_list<T>` ，但后续参数都有默认值， 使用 **花括号** 构造，总是会优先匹配初始化列表版本的构造函数。**花括号** 不允许窄向转换。
     + 值初始化：简单来说，就是用户不给出任何参数，直接用 **圆括号** 或者 **花括号** 进行的初始化，无论你是一个对象，还是一个基本类型或指针，你总是可以得到初始化。对于基本类型和指针，**直接清零**。
     + 默认初始化：如果一个类有非平凡的默认构造函数，则会直接调用。否则什么都不做，让那些没有非平凡构造的成员的内存状态留在它们被分配时内存(无论是在堆中还是栈中)的状态。和值初始化相比，更节省性能，但也更加危险。
     + 拷贝初始化：拷贝初始化并不意味着必然发生拷贝，随着历史的车轮滚滚向前，曾经以为属于拷贝语义的表达式，如今早已面目全非。
     + 零初始化：对于 static 变量，即使不初始化，其也会被放入 bss 段，程序加载时，会被清 0

131. C++ 按照有参数和无参数对初始化进行分类？

     - 无参数初始化有两种形式： **值初始化** （带有 `()` 或 `{}` ）和 **默认初始化** （无 `()` 或 `{}` )。前者会保证进行初始化（调用默认构造，或清零，或混合）；后者只会调用默认构造（如果是平凡的，则什么都不做）。
     - 有参数初始化，可以通过 `()` 或者 `{}` 的方式进行，两者的差异在于后者更优先匹配初始化列表，以及窄向转换的约束。
     - 在不使用 `()` 或者 `{}` 的场景下，使用 `=` 进行的初始化，属于 **拷贝初始化** 。如果被初始化对象是一个 class 类型， **copy构造** 或 **move构造** 会被调用；在使用 `()` 或 `{}` 的场景下，在 C++ 17 之后，除了 `explicit` 的约束之外，和 **直接初始化** 没有任何语义上的差异。

132. C++ 类主要有哪几种特殊函数，隐式生成时其默认行为如何？

     1. default 构造：隐式生成的 default 构造，调用父类和所有非静态成员的默认构造，和 `T() {}` 相比，在值初始化过程中，default 构造会先将内存清零，再进行构造调用
     2. copy 构造：隐式生成的拷贝构造，会依次调用所有父类和非静态成员的copy构造。
     3. move 构造：隐式生成的 move 构造，会依次调用所有父类和非静态成员的move 构造。
     4. copy 赋值：隐式生成的move构造，会依次调用所有父类和非静态成员的move构造。
     5. move 赋值：隐式生成的move赋值，会依次调用所有父类和非静态成员的move赋值。
     6. 析构：系统自动生成的析构，会依次调用父类以及所有非静态成员的析构。
     7. & 和 const & 取地址运算符：用于获取对象的指针

133. C++ 特殊函数什么情况下才会自动生成？

     1. default 构造：只要用户 **显式声明** 了构造函数列表（包括 **copy/move 构造** ），系统就不会隐式定义 **默认构造**
     2. copy 构造：如果用户没有显式声明任何构造函数列表，或者用户显式声明了构造函数列表，但是其中查不到 **copy 构造** ，只要 **move 家族** 的所有成员都没有被明确声明， 编译器也会尽力生成一个 **copy 构造** 。
     3. move 构造：如果用户明确声明 copy 构造，copy 赋值，move 赋值，析构函数，那么系统都不会自动生成 move 构造
     4. copy 赋值：**copy 赋值** 与 **copy构造** 的处境一致。
     5. move 赋值：**move 赋值** 与 **move构造** 的处境一致。
     6. 析构：除非用户显式声明了析构函数，否则就会自动生成。

     > 当编译器决定隐式定义某个特殊函数( `=defalt` )，但此时，依然会面临无法生成的困境。比如，其某个父类将那个特殊函数删除了，或者访问被禁止了，则系统也会放弃对此特殊函数的生成，而隐式的将其声明为 `delete` 。

134. 可变参数模板有何作用？

     提供了更强的模板功能，可以用于处理不定长，类型不尽相同的数据：

     ```cpp
     template<typename T>
     void log(const T& t) {
     		cout << t << endl;
     }
     template<typename T, typename... Args>
     void log(const T& t, const Args&... args) {
     		cout << t << " ";
       	log(args...);
     }
     ```

135. std::function 有何作用？

     封装可调用对象，提供统一的接口，可将 lambda 表达式，函数指针，函数对象赋值给 function 对象，提高程序的封装程度，可以将其当作是函数容器。

136. std::bind 和 std::placeholder 作用？

     而 `std::bind` 则是用来绑定函数调用的参数的， 它解决的需求是我们有时候可能并不一定能够一次性获得调用某个函数的全部参数，通过这个函数， 我们可以将部分调用参数提前绑定到函数身上成为一个新的对象，然后在参数齐全后，完成调用，可以用于实现柯里化。

137. C++ 如何确保在同一个文件中只能将同一个头文件包含一次？

     + ifndef-define-endif：移植性高
     + #pragma once：通用，不是标准的预处理器
     + _Pragma("once")：C99 中定义，标准，但是使用较少

138. 条件编译有何作用，与直接使用 if 语句有何区别？

     可以在不同硬件架构上实现条件编译，虽然不用条件编译命令而直接用 if 语句也能达到要求，但那样做目标程序长（因为所有语句都编译）， 运行时间长（因为在程序运行时间对if 语句进行测试）。而采用条件编译，可以减少被编译的语句，从而减少目标程序的长度，减少运行时间。

139. C++11 新增的库有哪些？

     random，chrono，tuple，ratio，regex，atomic，thread，mutex，condition_variable，future，function 等。

140. C++ 并行与并发涉及到哪些库？

     + thread：创建一个**执行**的线程实例，所以它是一切并发编程的基础。
     + mutex：
       + 直接调用成员函数 lock & unlock，构建临界区
       + 使用 lock_guard 确保 mutex 在发生异常时能够自动调用 unlock，确保安全
       + 使用 unique_lock 更加灵活，能够在声明后的任意位置调用 unlock/lock， 可以缩小锁的作用范围，提供更高的并发度
     + future：提供了一个访问异步操作结果的途径，可以当作一个 barrier 使用
     + condition_variable：是为了解决死锁而生，当互斥操作不够用而引入的。 比如，线程可能需要等待某个条件为真才能继续执行， 而一个忙等待循环中可能会导致所有其他线程都无法进入临界区使得条件为真时，就会发生死锁。所以，`condition_variable` 实例被创建出现主要就是用于唤醒等待线程从而避免死锁。其中的 notify_one/notify_all 用于唤醒等待线程
     + atomic：可以借此创建原子变量，最小化临界区大小，提高并发效率

141. 一致性模型分为哪些？

     + 线性一致性：又称强一致性或原子一致性。它要求任何一次读操作都能读到某个数据的最近一次写的数据，并且所有线程操作的顺序与全局时钟下的顺序是一致的。
     + 顺序一致性：同样要求任何一次读操作都能读到数据最近一次写入的数据，但未要求与全局时钟的顺序一致。
     + 因果一致性：它的要求进一步降低，只需要有因果关系的操作顺序得到保障，而非因果关系的操作顺序则不做要求。
     + 最终一致性：是最弱的一致性要求，它只保障某个操作在未来的某个时间节点上会被观察到，但并未要求被观察到的时间。

142. C++ 如何实现不同的一致性模型？

     主要通过定义的 6 种 std::memory_order 来实现，表达了四种同步模型：

     + 宽松模型：在此模型下，单个线程内的原子操作都是顺序执行的，不允许指令重排，但不同线程间原子操作的顺序是任意的。通过 `std::memory_order_relaxed` 指定。
     + 释放/消费模型：在此模型中，我们开始限制进程间的操作顺序，如果某个线程需要修改某个值，但另一个线程会对该值的某次操作产生依赖，即后者依赖前者。则当 `A` 主动 `x.release()` 时候（即使用 `std::memory_order_release`），选项 `std::memory_order_consume` 能够确保 `B` 在调用 `x.load()` 时候观察到 `A` 中第三次对 `x` 的写操作。
     + 释放/获取模型：在此模型下，我们可以进一步加紧对不同线程间原子操作的顺序的限制，在释放 `std::memory_order_release` 和获取 `std::memory_order_acquire` 之间规定时序，即发生在释放（release）操作之前的**所有**写操作，对其他线程的任何获取（acquire）操作都是可见的，亦即发生顺序（happens-before）。
     + 顺序一致模型：在此模型下，原子操作满足顺序一致性，进而可能对性能产生损耗。可显式的通过 `std::memory_order_seq_cst` 进行指定。

143. alignof 和 alignas 的作用？

     C++11 引入的关键字`alignof`，可直接获取类型`T`的内存对齐要求。`alignof`的返回值类型是`size_t`，用法类似于`sizeof`。

     alignas 则用于定义一个结构体或者类的对其方式，GCC 规定了 aligned 属性也可用于规定结构体或者类的对齐方式。

144. constexpr 作用？

     constexpr 限定编译期常量，const 并未区分出编译期常量和运行期常量。在 C++11 以后，建议凡是「常量」语义的场景都使用 constexpr，只对「只读」语义使用 const。在较早的版本中，下列语句非法：

     ```cpp
     [constexpr] int foo {return 10;}
     int arr[foo()];
     ```

     通过添加 constexpr 让用户显式的声明函数或对象构造函数在编译期会成为常量表达式。

     > 现在大部分编译器其实都带有自身编译优化，很多非法行为在编译器优化的加持下会变得合法，若需重现编译报错的现象需要使用老版本的编译器。

145. `if constexpr` 有何作用？

     让代码在编译时就完成分支判断，提高程序执行效率。

146. 外部模板有何作用？

     传统 C++ 中，模板只有在使用时才会被编译器实例化。换句话说，只要在每个编译单元（文件）中编译的代码中遇到了被完整定义的模板，都会实例化。这就产生了重复实例化而导致的编译时间的增加。为此，C++11 引入了外部模板，扩充了原来的强制编译器在特定位置实例化模板的语法，使我们能够显式的通知编译器何时进行模板的实例化。使用 extern 语法。

147. C++ 如何进行信号处理的？

     通过 signal(registered signal, signal handler) 来进行注册，handler 便是实际处理的程序，也可以在程序中通过 raise(signal sig) 来生成信号。 

148. C++ thread join 和 detach 的区别？

     join 表示主线程需要等待从线程结束之后才能继续执行，而 detach 则表示让从线程在后台运行，即说明主线程不会等待子线程运行结束才结束。一般来说，当程序没有使用共享变量或引用之类的话，可以使用 detach 函数，分离线程。否则需要使用 join 来确保共享变量的安全析构。

149. C++ 标准模板库主要有那三个组件？

     | 组件   | 描述                                                         |
     | :----- | :----------------------------------------------------------- |
     | 容器   | 容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等。 |
     | 算法   | 算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。 |
     | 迭代器 | 迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。 |

150. 迭代器类型有哪些？

     + 输入迭代器：来自容器的信息被视为输入，就像来自键盘的信息对程序来说是输入一样。因此，输入迭代器可被程序用来读取容器中的信息。
     + 输出迭代器：用于将信息从程序传输给容器的迭代器，因此程序的输出就是容器的输入。
     + 单向迭代器：与输入迭代器和输出迭代器相似，正向迭代器只使用 ++ 运算符来遍历容器，所以它每次沿容器向前移动一个元素
     + 双向迭代器：同时支持两种（前缀和后缀）递减运算符
     + 随机访问迭代器：随机访问迭代器具有双向迭代器的所有特性，同时添加了支持随机访问的操作（如指针增加运算）和用于对元素进行排序的关系运算符。

151. vector 底层是如何实现的？

     vector 底层是一个动态数组，start 和 finish 之间是已经被使用的空间范围，end_of_storage 是整块连续空间，其包括备用空间的尾部。当空间不够装下数据（vec.push_back(val)）时，会自动申请另一片更大的空间（1.5 倍或者 2 倍），然后把原来的 数 据拷贝到新的内存空间，接着释放原来的那片空间，这便是 vector 内存增长机制。

     当释放或者删除（vec.clear()）里面的数据时，其存储空间不释放，仅仅是清空了里面的数据。因此，对 vector 的任何操作一旦引起了空间的重新配置，指向原 vector 的所有迭代器会都失效。

152. vector 中的 reserve 和 resize 的区别？

     + reserve 是直接扩充到已经确定的大小，可以减少多次开辟、释放空间的问题（优化push_back），就可以提高效率，其次还可以减少多次要拷贝数据的问题。
     + resize() 可以改变有效空间的大小，capacity 的大小可能也会随着改变

153. vector 的元素类型可以是引用吗？

     vector 的底层实现要求连续的对象排列，引用并非对象，没有实际地址，因此 vector 的元素类型不能是引用。

154. vector 迭代器失效的情况？

     + 当插入一个元素到 vector 中，由于引起了内存重新分配，所以指向原内存的迭代器全部失效。
     + 当删除容器中一个元素后,该迭代器所指向的元素已经被删除，那么也造成迭代器失效。erase 方法会返回下一个有效的迭代器，所以当我们要删除某个元素时，需要it=vec.erase(it)。

155. 容器内部如何删除一个元素，确保根据迭代器可以继续执行？

     + 顺序容器：erase 迭代器不仅使所指向被删除的迭代器失效，而且使被删元素之后的所有迭代器失效，所以不能使用 erase(it++) 的方式，但是 erase 的返回值是下一个有效迭代器 `it = c.erase(it)`；
     + 关联容器：erase迭代器只是被删除元素的迭代器失效，但是返回值是void，所以要采用 `erase(it++)` 的方式删除迭代器；

156. map 中 [] 与 find 的区别？

     + map 的下标运算符 [] 的作用是：将关键码作为下标去执行查找，并返回对应的值；如果不存在这个关键码，就 将 一个具有该关键码和值类型的默认值的项插入这个 map。
     + map 的 find 函数：用关键码执行查找，找到了返回该位置的迭代器；如果不存在这个关键码，就返回尾迭代器。

157. list 底层原理？

     list 的底层是一个双向链表，以结点为单位存放数据，结点的地址在内存中不一定连续，每次插入或删除一个元 素， 就配置或释放一个元素空间。list 不支持随机存取，适合需要大量的插入和删除，而不关心随机存取的应用场景。

158. deque 底层原理？

     deque 在实现上实现了分段的概念，每段是一个缓冲区，用于存储数据，为了统一每段的地址，采用数组将每段首地址保存，这样就能实现遍历整个双向队列的功能了。

159. 为何 map 和 set 的插入删除效率比其他序列容器高，而且每次 insert 之后，以前保存的iterator 不会失效？

     因为存储的是结点，不需要内存拷贝和内存移动。因为插入操作只是结点指针换来换去，结点内存没有改变。而 iterator 就像指向结点的指针，内存没变，指向内存的指针也不会变。

160. unordered_map 与 map 的区别？使用场景？

     + 构造函数：unordered_map 需要 hash 函数，等于函数; map 只需要比较函数
     + 存储结构：unordered_map 采用 hash 表存储，map 一般采用红黑树 (RB Tree) 实现。因此其 memory 数据结构是 不一样的。

     总体来说，unordered_map 查找速度会比 map 快，而且查找速度基本和数据数据量大小，属于常数级别;而 map 的查找速度是 log(n) 级别。并不一定常数就比 log(n) 小，hash 还有hash 函数的耗时，明白了吧，如果你考虑效率，特别是在元素达到一定数量级时，考虑考虑 unordered_map 。但若你对内存使用特别严格，希望程序尽可能少消耗内 存，那么一定要小心，unordered_map 可能会让你陷入尴尬，特别是当你的 unordered_map 对象特别多时， 你 就更无法控制了，而且 unordered_map 的构造速度较慢。

     > Java 中，对于对象的 hashcode 使用缓存计数，可以减少重复计算 hashcode 的开销

161. 迭代器的底层原理？

     迭代器是连接容器和算法的一种重要桥梁，通过迭代器可以在不了解容器内部原理的情况下遍历容器。它的底层实 现包含两个重要的部分：萃取技术和模板偏特化。

     + 萃取技术（traits）可以进行类型推导，根据不同类型可以执行不同的处理流程，比如容器是 vector，那么 traits 必须推导出其迭代器类型为随机访问迭代器，而 list 则为双向迭代器。
     + 使用萃取技术（traits）进行类型推导的过程中会使用到模板偏特化。模板偏特化可以用来推导参数，如果我们自 定义了多个类型，除非我们把这些自定义类型的特化版本写出来，否则我们只能判断他们是内置类型，并不能判断 他们具体属于是个类型。

162. vector 如何释放空间？

     由于 vector 的内存占用空间只增不减，比如你首先分配了 10,000 个字节，然后 erase 掉后面 9,999 个，留下一个有效 元 素，但是内存占用仍为 10,000 个。所有内存空间是在 vector 析构时候才能被系统回收。clear() 可以清空所有元素。但是即使 clear()，vector 所占用的内存空间依然如故，无法保证内存的回收。如果需要空间动态缩小，可以考虑使用 deque。如果 vector，可以用 swap() 来帮助你释放内存 `vector().swap(vec)`。

163. emplace_back 和 push_back 区别？

     **push_back**() 向容器尾部添加元素时，首先会创建这个临时元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）；而**emplace_back**() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。

164. 为什么要引入 `std::array` 而不是直接使用 `std::vector`？

     与 `std::vector` 不同，`std::array` 对象的大小是固定的，如果容器大小是固定的，那么可以优先考虑使用 `std::array` 容器。 另外由于 `std::vector` 是自动扩容的，当存入大量的数据后，并且对容器进行了删除操作， 容器并不会自动归还被删除元素相应的内存，这时候就需要手动运行 `shrink_to_fit()` 释放这部分内存。

165. 已经有了传统数组，为什么要用 `std::array`?

     使用 `std::array` 能够让代码变得更加“现代化”，而且封装了一些操作函数，比如获取数组大小以及检查是否非空，同时还能够友好的使用标准库中的容器算法，比如 `std::sort`。

166. std::forward_list 有何作用？

     是一个列表容器，使用方法和 `std::list` 基本类似，通过单向链表实现， 提供了 `O(1)` 复杂度的元素插入，不支持快速随机访问，不支持 size() 方法。当不需要双向迭代时，具有比 `std::list` 更高的空间利用率。

167. STL 是如何进行内存空间优化的？

     STL 使用二级内存配置器：

     + 第一级配置器：以 malloc()，free()，realloc() 等 C 函数执行实际的内存配置、释放、重新配置等操作，并且能在内存 需求不被满足的时候，调用一个指定的函数。一级空间配置器分配的是大于 128 字节的空间，如果分配不成功，调用句柄释放一部分内存，如果还不能分配成功，抛出异常。
     + 第二级配置器：如果分配的区块小于 128bytes，则以内存池管理，第二级配置器维护了一个自由链表数组，每次需要分配内存时， 直接从相应的链表上取出一个内存节点就完成工作，效率很高。
       + 自由链表数组：指针数组，数组中的每个指针元素指向一个链表的起始节点。数组大小为 16， 链表的每个节点就是实际的内存块，相同链表上的内存块大小都相同，不同链表的内存块大小不同，从 8 一直到 128。
       + 内存分配：allocate 函数内先判断要分配的内存大小，若大于 128 字节，直接调用第一级配置器，否则根据要分配 的内存大小从 16 个链表中选出一个链表，取出该链表的第一个节点。若相应的链表为空，则调用refill函数填充该链 表。 默认是取出20个数据块。
       + 填充链表 refill：若 allocate 函数内要取出节点的链表为空，则会调用 refill 函数填充该链表。refill 函数内会先调用 chunk_alloc 函数从内存池分配一大块内存，该内存大小默认为 20 个链表节点大小，当内存池的内存也不足时，返 回的内存块节点数目会不足 20 个。接着 refill 的工作就是将这一大块内存分成20份相同大小的内存块，并将各内存 块 连接起来形成一个链表。
       + 内存池：chunk_alloc 函数内管理了一块内存池，当 refill 函数要填充链表时，就会调用 chunk_alloc 函数，从内存池取出相应的内存。如何内存池没有空间，则首先合并其他空闲链表，以获取空间，若还是不行，则调用第一级分配器

     > 自由链表数组类似 Linux 中的伙伴系统，但是伙伴系统是按照 2 的幂次增长的

168. C++ 中类对象只能在堆上分配吗？

     不是的，在 C++ 中，类的对象建立分为两种，一种是静态建立，如`A a`；另一种是动态建立，如`A* ptr=new A`；

     + 静态建立一个类对象，是由编译器为对象在栈空间中分配内存，是通过直接移动栈顶指针，挪出适当的空间，然后在这片内存空间上调用构造函数形成一个栈对象。使用这种方法，**直接调用类的构造函数**。
     + 动态建立类对象，是使用new运算符将对象建立在堆空间中。这个过程分为两步，第一步是执行operator new()函数，在堆空间中搜索合适的内存并进行分配；第二步是调用构造函数构造对象，初始化这片内存空间。这种方法，**间接调用类的构造函数**。

169. 如何定义一个只能在堆上（栈上）生成对象的类？

     + 只能建立在堆上：将析构函数设置为私有，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。缺点是不能作为基类，另外缺点是使用不方便，使用 new 创建对象，但是使用 destory 公开函数释放对象
     + 只能建立在栈上：将 operator new 和 operator delete 重载为私有。只有使用 new 运算符，对象才会建立在堆上，因此，只要禁用 operator new 就可以实现类对象只能建立在栈上。

170. lambda 表达式在内部是如何实现的？

     其实，编译器会把我们写的 lambda 表达式翻译成一个类，并重载 operator() 来实现。也就是将 lambda 表达式转换为函数对象，并且在传值和传引用时进行初始化即可。









## 参考资料

1. [Understanding Modern C++](https://github.com/godsme/understand_modern_cpp)：https://github.com/godsme/understand_modern_cpp
2. [现代 C++ 教程](https://changkun.de/modern-cpp/zh-cn/00-preface/)：https://github.com/changkun/modern-cpp-tutorial
3. [Effective Modern C++](https://cntransgroup.github.io/EffectiveModernCppChinese/1.DeducingTypes/item1.html)：https://github.com/CnTransGroup/EffectiveModernCppChinese











