---
title: 《算法》备忘录
date: 2022-05-12 22:37:18
tags: [Algorithm]
mathjax: true
---

本文用于在算法学习过程中，总结相关算法套路以及算法编写经验，以备查阅。

<!-- More -->



## 01 算法复杂度及其分析

算法复杂度表示方法：

+ $O$：表示算法的渐进上界
+ $\Omega$：表示算法的渐进下界
+ $\Theta$：表示算法的渐进紧确界

递归算法复杂度分析：

+ 递归树方法

+ 代入检测法

+ 主方法：令 $a \ge 1, b > 1$ 是常数，$f(n)$​ 是一个函数，T(n) 是非负整数上的递推式：
    $$
    T(n) = aT(\frac{n}{b}) + f(n)
    $$
    T(n) 有以下方法紧确界：

    + 如果存在 $\epsilon > 0$，使得 $f(n) = O(n^{log_ba - \epsilon})$，则 $T(n) = \Theta(n^{log_ba})$   
    + 如果 $f(n) = O(n^{log_ba})$，则 $T(n) = \Theta(n^{log_ba}lgn)$  
    + 如果存在 $\epsilon > 0$，使得 $f(n) = O(n^{log_ba + \epsilon})$，并且存在 $c < 1$ 和足够大的 n，满足 $af(n/b) \le  cf(n)$，则 $T(n) = \Theta(f(n))$   



## 02 排序算法

常见排序算法：

|   名称   |    平均复杂度    |   最坏复杂度    | 原地算法 | 是否稳定 |
| :------: | :--------------: | :-------------: | :------: | :------: |
| 冒泡排序 |  $\Theta(n^2)$   |  $\Theta(n^2)$  |   原地   |   稳定   |
| 插入排序 |  $\Theta(n^2)$   |  $\Theta(n^2)$  |   原地   |   稳定   |
| 选择排序 |  $\Theta(n^2)$   |  $\Theta(n^2)$  |   原地   |  不稳定  |
| 归并排序 |  $\Theta(nlgn)$  | $\Theta(nlgn)$  |   O(n)   |   稳定   |
| 快速排序 |  $\Theta(nlgn)$  |  $\Theta(n^2)$  |   原地   |  不稳定  |
|  堆排序  |  $\Theta(nlgn)$  | $\Theta(nlgn)$  |   原地   |  不稳定  |
| 希尔排序 |  $\Theta(nlgn)$  | $O(n^s), 1<s<2$ |   原地   |  不稳定  |
| 计数排序 |  $\Theta(k+n)$   |                 |  非原地  |   稳定   |
|  桶排序  |  $\Theta(k+n)$   |                 |  非原地  |   稳定   |
| 基数排序 | $\Theta(d(k+n))$ |                 |  非原地  |   稳定   |



## 03 数据结构

基本数据结构：

+ 数组：存取速度快；插入删除元素效率低下，需要大块连续的内存块
+ 链表：插入删除操作快，不需要大块连续的空间；访问操作慢

扩展数据结构：

+ 散列表：使用哈希函数进行位置索引，快速查找，冲突处理有链接法，开放寻址法
+ 队列：FIFO 结构，变体如单调队列，主要用于处理滑动窗口最大值最小值问题
+ 栈：FILO 结构，变体如单调栈，可以找到第一个小于大于当前元素的数字，如接雨水
+ 树：
  + 遍历方式：先序遍历，中序遍历，后序遍历，层次遍历
  + 搜索方式：BFS + DFS
  + 动态查找树：
    + 二叉搜索树（BST）：左子树中的值都小于根节点，右子树中的值都大于根节点
    + 平衡二叉树（AVT）：解决 BST 退化成链表的问题，保证左右子树高度差小于 1 
    + 红黑树：降低 AVT 插入和删除的旋转开销，调整为最长路径不超过最短路径的二倍
    + 哈夫曼树：主要用于编码，使用最少的字符串进行信息的编码
  + 多路查找树：
    + Trie 树：常用于字符串匹配中
    + B 树：常用于文件磁盘系统
    + B+ 树：只有叶子节点才存储真实数据，用于 MySQL 索引，降低 IO 开销
    + R 树：空间数据存储的树状数据结构

二叉搜索树：

+ 前驱节点：左子树最大值，向左走一步，再一直向右走
+ 后继节点：右子树最小值，先右走一步，再一直向左走

平衡二叉树：

+ 旋转：

  + LL 旋转：

    ![img](《算法》备忘录/alg-tree-avl-4.jpg)

  + RR 旋转：

    ![img](《算法》备忘录/alg-tree-avl-5.jpg)

  + LR 旋转：转化为 LL 不平衡形式

    ![img](《算法》备忘录/alg-tree-avl-6.jpg)

  + RL 旋转：转化为 RR 不平衡形式

    ![img](《算法》备忘录/alg-tree-avl-7.jpg)

红黑树：

+ 性质：
  + 每个节点颜色或者红色，或者黑色
  + 根节点是黑色的，NULL 节点也是黑色的
  + 如果一个节点是红色的，那么它的两个子节点就是黑色的
  + 对于每个节点，从该节点到其后代叶节点的简单路径上，均包含相同数目的黑色节点
+ 应用场景：
  + Java HashMap & TreeMap
  + C++ STL: map & set
  + linux 进程调度 Completely Fair Scheduler，用红黑树管理进程控制块
  + epoll 在内核中的实现，用红黑树管理事件块
  + nginx 中，用红黑树管理 timer 等







## 04 编程方法

分治：将问题划分为互不相交的小问题，递归地解决小问题，再进行组合来解决原问题

动态规划：和分治类似，不过其应用于具有重叠子问题的情况，关键在于找到递归解定义，然后使用备忘录或者自底向上方法进行解决

贪心算法：和动态规划类似，不过其在解决问题的过程中，每一步都选择最优解，即小问题的最优解构成了大问题的最优解

































