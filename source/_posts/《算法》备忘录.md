---
title: 《算法》备忘录
date: 2022-05-12 22:37:18
tags: [Algorithm]
mathjax: true
---

本文用于在算法学习过程中，总结相关算法套路以及算法编写经验，以备查阅。

<!-- More -->



## 01 算法复杂度及其分析

算法复杂度表示方法：

+ $O$：表示算法的渐进上界
+ $\Omega$：表示算法的渐进下界
+ $\Theta$：表示算法的渐进紧确界

递归算法复杂度分析：

+ 递归树方法

+ 代入检测法

+ 主方法：令 $a \ge 1, b > 1$ 是常数，$f(n)$​ 是一个函数，T(n) 是非负整数上的递推式：
    $$
    T(n) = aT(\frac{n}{b}) + f(n)
    $$
    T(n) 有以下方法紧确界：

    + 如果存在 $\epsilon > 0$，使得 $f(n) = O(n^{log_ba - \epsilon})$，则 $T(n) = \Theta(n^{log_ba})$   
    + 如果 $f(n) = O(n^{log_ba})$，则 $T(n) = \Theta(n^{log_ba}lgn)$  
    + 如果存在 $\epsilon > 0$，使得 $f(n) = O(n^{log_ba + \epsilon})$，并且存在 $c < 1$ 和足够大的 n，满足 $af(n/b) \le  cf(n)$，则 $T(n) = \Theta(f(n))$   



## 02 排序算法

常见排序算法：

|   名称   |    平均复杂度    |   最坏复杂度    | 原地算法 | 是否稳定 |
| :------: | :--------------: | :-------------: | :------: | :------: |
| 冒泡排序 |  $\Theta(n^2)$   |  $\Theta(n^2)$  |   原地   |   稳定   |
| 插入排序 |  $\Theta(n^2)$   |  $\Theta(n^2)$  |   原地   |   稳定   |
| 选择排序 |  $\Theta(n^2)$   |  $\Theta(n^2)$  |   原地   |  不稳定  |
| 归并排序 |  $\Theta(nlgn)$  | $\Theta(nlgn)$  |   O(n)   |   稳定   |
| 快速排序 |  $\Theta(nlgn)$  |  $\Theta(n^2)$  |   原地   |  不稳定  |
|  堆排序  |  $\Theta(nlgn)$  | $\Theta(nlgn)$  |   原地   |  不稳定  |
| 希尔排序 |  $\Theta(nlgn)$  | $O(n^s), 1<s<2$ |   原地   |  不稳定  |
| 计数排序 |  $\Theta(k+n)$   |                 |  非原地  |   稳定   |
|  桶排序  |  $\Theta(k+n)$   |                 |  非原地  |   稳定   |
| 基数排序 | $\Theta(d(k+n))$ |                 |  非原地  |   稳定   |



## 03 数据结构

基本数据结构：

+ 数组：存取速度快；插入删除元素效率低下，需要大块连续的内存块
+ 链表：插入删除操作快，不需要大块连续的空间；访问操作慢

扩展数据结构：

+ 散列表：使用哈希函数进行位置索引，快速查找，冲突处理有链接法，开放寻址法
+ 队列：FIFO 结构，变体如单调队列，主要用于处理滑动窗口最大值最小值问题
+ 栈：FILO 结构，变体如单调栈，可以找到第一个小于大于当前元素的数字，如接雨水
+ 树：
  + 遍历方式：先序遍历，中序遍历，后序遍历，层次遍历
  + 遍历方式：BFS + DFS
  + 动态查找树：
    + 二叉搜索树（BST）：左子树中的值都小于根节点，右子树中的值都大于根节点
    + 平衡二叉树（AVT）：解决 BST 退化成链表的问题，保证左右子树高度差小于 1 
    + 红黑树：降低 AVT 插入和删除的旋转开销，调整为最长路径不超过最短路径的二倍
    + 哈夫曼树：带权路径长度最短的二叉树，主要用于编码
  + 多路查找树：
    + Trie 树：常用于前缀匹配中，词频统计
    + B 树：常用于文件磁盘系统
    + B+ 树：只有叶子节点才存储真实数据，用于 MySQL 索引，降低 IO 开销
    + R 树：空间数据存储的树状数据结构
+ 堆：通常看作是一棵完全二叉树的数组对象，插入时采用上浮，删除时采用下沉操作
+ 图：
  + 图的存储结构：邻接矩阵，邻接链表
  + 遍历方式：BFS + DFS
  + 拓扑排序：需要统计入度，只有入度为 0 的节点才能进入队列
  + 并查集：使用数组表示每个节点的根节点，用于两个节点间的连通性判断
  + 最短路径：
    + Dijkstra 算法：单源最短路径算法，不能处理带有负权边的图
    + Floyd 算法：计算所有点到所有点的最短路径的算法，相当于将每个点当作是中转站
  + 最小生成树：
    + Kruskal 算法：边加法，每次都挑选最小权值的边，并且该边属于两棵树
    + Prim 算法：点加法，从某个点开始，每次挑选树外最小权值的边对应的顶点

二叉搜索树：

+ 前驱节点：左子树最大值，向左走一步，再一直向右走
+ 后继节点：右子树最小值，先右走一步，再一直向左走

平衡二叉树：

+ 旋转：

  + LL 旋转：

    ![img](《算法》备忘录/alg-tree-avl-4.jpg)

  + RR 旋转：

    ![img](《算法》备忘录/alg-tree-avl-5.jpg)

  + LR 旋转：转化为 LL 不平衡形式

    ![img](《算法》备忘录/alg-tree-avl-6.jpg)

  + RL 旋转：转化为 RR 不平衡形式

    ![img](《算法》备忘录/alg-tree-avl-7.jpg)

红黑树：

+ 性质：
  + 每个节点颜色或者红色，或者黑色
  + 根节点是黑色的，NULL 节点也是黑色的
  + 如果一个节点是红色的，那么它的两个子节点就是黑色的
  + 对于每个节点，从该节点到其后代叶节点的简单路径上，均包含相同数目的黑色节点
+ 应用场景：
  + Java HashMap & TreeMap
  + C++ STL: map & set
  + linux 进程调度 Completely Fair Scheduler，用红黑树管理进程控制块
  + epoll 在内核中的实现，用红黑树管理事件块
  + nginx 中，用红黑树管理 timer 等



## 04 算法思想

分治：将问题划分为互不相交的小问题，递归地解决小问题，再进行组合来解决原问题

动态规划：和分治类似，不过其应用于具有重叠子问题的情况，关键在于找到递归解定义，然后使用备忘录或者自底向上方法进行解决

贪心算法：和动态规划类似，不过其在解决问题的过程中，每一步都选择最优解，即小问题的最优解构成了大问题的最优解

二分法：分治思想的一种，要求原数据是按照关键字有序的

搜索算法：

+ BFS：使用队列辅助，一层一层搜索，可用于边权相同的最短路径长度
+ DFS：通常使用递归方式实现，可以用于可达性问题
  + 回溯：当前路径不可达时，返回上层，再次进行 DFS



## 05 领域算法

安全算法：

+ 摘要算法：主要用在数字签名上，能够产生长度相同的消息摘要，相关算法有 MD5，SHA 系列算法
+ 加密算法：将普通的文本和一串数字（密钥）进行结合，产生不可理解的密文的步骤
  + 对称加密算法：加密密钥和解密密钥相同，如 DES 算法
  + 非对称加密算法：加密密钥和解密密钥不同，称为公开密钥和私有密钥，如 RSA 算法

字符串匹配算法：指在文本中找到模式出现位置的算法，通常包括预处理和匹配两个步骤

+ 









































