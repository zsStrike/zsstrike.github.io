---
title: Java 面试题目汇总
date: 2023-02-07 14:05:16
tags: ["Java"]
---





本文用于记录学习 Java 中遇到的问题，以备查阅。

<!-- More -->



1. Java 中对象和对象引用的区别？

   对象存储在堆内存中，对象引用一般存储在栈内存中，程序员直接操作的是对象引用，对象引用指向实际的对象。

2. JVM 中存在寄存器吗，若不存在该如何进行表达式计算呢？

   并不存在寄存器的概念，JVM 使用操作数栈来进行计算。

3. boolean 基本类型占用空间？

   Java 虚拟机规范中并没有明确指出 boolean 类型的内存占用，需要看虚拟机的具体实现，1 个字节或 4 个字节都是可能的。

4. static 关键字的作用？

   可以解释位类字段或者类方法，可以在不创建对象的时候直接使用，并且类变量在所有对象中共享。

5. 创建数组时，默认值是多少？

   全 0，对于对象数组则为 null。

6. 局部变量会被默认初始化吗？

   不会，对象字段会被默认初始化。

7. `i = i++` 和 `i = ++i` 的区别，i  初始值为 0？

   每个方法在执行时，都有一个栈帧与之对应，其中包含了局部变量，操作数栈以及其他数据。`i = i++` 表示先将 i 的值入栈，然后执行自增，这时局部变量 i 就变为 1，最后执行赋值操作，也就是将栈顶数据写回给 i，得到的最终值为 0；`i = ++i` 则是先执行自增操作，这是局部变量 i 为 1，接着将 i 入栈，最后执行出栈操作，得到最终值为 1。

8. Java 中浮点数强制转换为整型的规则？

   直接去掉浮点数，向 0 靠近。

9. Java 中如何跳出多重循环？

   使用标签和 break 即可。

10. Java 中的 switch case 语句支持字符串吗，原理如何？

    从 Java 7 开始支持字符串，JVM 虚拟机首先检查字符串的 hashCode，然后再对里面的字符串执行 equals，判断是否确实是对应的字符串，再决定是否跳转。

11. 方法重载的时候，返回值能否用于区分被重载的方法？

    不能，方法重载看的是方法签名，方法签名由方法名和方法参数类型构成。

12. 在构造器中调用本对象构造器时，需要注意什么？

    可以通过 this(param) 实现，但是只能调用一次，并且只能在构造器首行调用。

13. 在 Java 中为什么调用构造方法只能一次，并且在第一行？

    只能一次的原因是只需要创建一个对象就可以了，放在第一行可以保证其父类被安全创建。

    > JVM 规定：若构造器首行中没有构造器调用，则会插入 super() 调用，用于保证父类对象创建

14. 如何看待 Java 中 Object 对象提供的 finalize 方法？

    虽然该方法最初用于清理对象，但是现在一般不使用该方法，因为其可能导致对象意外复活；另外，无论是”垃圾回收”还是”终结”，都不保证一定会发生。如果 Java 虚拟机（JVM）并未面临内存耗尽的情形，它可能不会浪费时间执行垃圾回收以恢复内存。

15. 垃圾回收器工作方法？

    + 引用计数：对每个对象进行计数，每次有引用指向该对象时，引用计数加 1，而当引用被置为 null 时，引用计数减 1。垃圾回收器遍历对象，对那些引用计数为 0 的对象进行回收即可。该机制存在缺点，不能解决循环引用的问题。
    + 自适应的垃圾回收技术：对于任意“活”的对象，总是可以追溯到其存活在栈或者静态区的引用，从栈或者静态存储区出发，将会发现所有的活的对象。在垃圾对象较多的时候，可以采用停止-复制（stop-and-copy）算法，该算法需要阻塞主程序，并且需要两个堆，不适用于垃圾对象较少的情况；为此可以使用标记-清除（mark-and-sweep），每找到一个或对象，标记其即可，之后清除所有未标记的对象。

16. 不考虑继承，假设有个 Dog 类，当用户首次创建对象时，JVM 采取了哪些操作？

    + JVM 搜索类路径，找到 Dog.class，将其进行加载，即装入内存
    + 随后，执行静态初始化
    + 接着，当调用 `new Dog()` 时，首先需要在堆上为 Dog 对象分配足够的内存
    + 分配的内存首先会被清零
    + 执行出现在字段定义处的初始化动作，再接着执行实例初始化块
    + 最后执行对应的构造器

17. 考虑继承，假设 `Dog extends Animal`，当用户首次创建 Dog 对象时，初始化顺序？

    + 首先，JVM 查找 Dog.class，接着在加载过程中发现有一个父类，于是，转去先执行 Animal 类初始化的类加载和静态初始化操作，加载完成后再加载子类 Dog 和执行其静态初始化
    + 接着 new Dog 语句，执行对应的构造器，构造器首行一般有 JVM 插入的 super() 语句，于是先执行 Animal 类的实例初始化操作和构造器，接着再执行 Dog 类的实例初始化操作和构造器操作

    > JVM 会将对象初始化代码段里面的内容复制到所有构造器代码之前，super 调用之后，因此，在执行完子类的 static 代码段后，先去执行父类的初始化代码和构造器代码，再来执行子类的对象代码段和构造器代码段

18. 代码执行顺序分析？

    ```java
    class Test {
        int a = 1;
        {
            a = 2;
        }
        Test() {
            a = 3;
        }
    }
    ```

    通过 Java 字节码反编译，可以知道编译后的代码如下：

    ```java
    class Test {
        int a;
        Test() {
            super();    // jvm 插入的隐式调用父类构造器
            a = 1;		// jvm 移动初始赋值语句
            a = 2;		// jvm 移动实例初始化代码
            a = 3;		// 用户定义的构造器代码
        }
    }
    ```

    

19. enum 类型的 JVM 实现？

    enum 最终会编译为 class 对象，其继承 Enum 对象，并且里面的枚举值会被定义为对应的私有静态变量。

20. Java 访问权限修饰符？

    + public：当使用 public 关键字的时候，意味着 public 后声明的成员对于每个人都是可用的
    + protected：继承的类可以访问父类中对应的成员，同时也提供了包访问权限
    + default：指不加修饰符定义的成员，可以被相同包下的文件访问
    + private：除了包含成员的类，其他任何类都无法访问这个成员

21. 组合和继承的选择？

    当想要在新类中包含一个已有类的功能时，使用组合，而非继承；当使用继承时，使用一个现有类并开发出它的新版本，通常这意味着使用一个通用类，并为了某个特殊需求将其特殊化。组合用来表达“有一个”的关系，而继承则是“是一个”的关系。

22. 当父类没有无参构造器时，子类在构造器中需要显式指定父类的构造器，为什么？

    JVM 会为没有适用构造器调用的构造器加入 super() 语句，用于父类的初始化，但当父类没有无参构造器时，super() 就不能找到对应的构造器方法，从而产生报错。

23. final 关键字的作用？

    + final 数据：对于基本类型，final 使得数值恒定不变，对于对象引用，final 则是使得引用恒定不变
    + final 参数：在参数列表中，将参数声明为 final 意味着在方法中不能改变参数指向的对象或基本变量
    + final 方法：给方法上锁，防止子类通过覆写改变方法的行为，**类中所有的 private 方法都隐式地指定为 final**
    + final 类：当说一个类是 final ，就意味着它不能被继承

24. 类初始化和加载指什么？

    在 Java 中，每个类的编译代码都存在于它自己独立的文件中，该文件只有在使用程序代码时才会被加载。一般可以说“类的代码在首次使用时加载”。这通常是指创建类的第一个对象，或者是访问了类的 static 属性或方法。构造器也是一个 static 方法尽管它的 static 关键字是隐式的。因此，准确地说，一个类当它任意一个 static 成员被访问时，就会被加载。

25. 方法重载和方法重写区别？

    方法重载是指在同一个类中定义相同方法名，但是签名不同的方法；

    方法重写是指子类重写父类的方法（签名相同），可以借此实现多态特性。

26. Java 中的多态是如何实现的？

    当派生类重写父类方法后，并且使用向上转型后，调用重写方法后，编译器依旧会**动态绑定**到派生类中被重写的方法，执行方法调用。Java 中除了 static，final，private 方法是静态绑定，其他方法都是动态绑定的。

27. Java 中的多态能否实现对象属性的多态？

    不能，只有方法才能后期绑定，属性是根据引用类型来编译的，向上转型后，只能使用基类的属性。

28. Java 构造器内部多态方法的行为？

    如果在构造器中调用了正在构造的对象的动态绑定方法，就会用到那个方法的重写定义。

    ```java
    class Glyph {
        void draw(){System.out.println("Glyph.draw()");}
    
        Glyph() {
            System.out.println("Glyph() before draw()");
            draw();
            System.out.println("Glyph() after draw()");
        }
    }
    
    class RoundGlyph extends Glyph {
        private int radius = 999;
    
        RoundGlyph(int r) {
            draw();
            radius = r;
            System.out.println("RoundGlyph.RoundGLyph(), radius = " + radius);
        }
    
        void draw() {
            System.out.println("RoundGlyph.draw(), radius = " + radius);
        }
    }
    ```

    输出是：

    ```
    Glyph() before draw()
    RoundGlyph.draw(), radius = 0
    Glyph() after draw()
    RoundGlyph.draw(), radius = 999
    RoundGlyph.RoundGLyph(), radius = 5
    ```

29. 协变返回类型指什么？

    派生类在重写方法时，可以返回基类方法返回类型的派生类型。

30. Java8 后，接口中可以定义静态方法和默认方法，这些特性有什么作用？

    静态方法用于将工具功能置于接口中，使其成为通用的工具类；默认方法则是为那些没有实现接口方法提供的默认实现，可以在不破坏已有接口的结构下，在接口中中增加新的方法。

31. 抽象类和抽象方法？

    包含有抽象方法的类便是抽象类，抽象方法适用 abstract 关键词，不含有方法体。对于继承抽象类的派生类，需要实现所有的抽象方法，否则其也是一个抽象类，不可用于实例化。

32. 接口中定义的字段属于接口还是属于实现类的？

    接口中的字段自动是 static final 的，属于接口，可以使用其定义一堆常量，但在 Java8 中推荐使用 enum。

33. 抽象类和接口的异同点有哪些？

    相同点：提供了一种将接口与实现分离的更加结构化的方法

    不同点：

    + 类可以实现多个接口，但只能继承一个基类
    + 接口中不包含对象属性，抽象类中可以包含对象属性和类属性
    + 非抽象类可以不实现接口中的默认方法，但是必须实现抽象类中的抽象方法
    + 接口没有构造器，抽象类可以有构造器
    + 接口的可见形隐式 public，而抽象类可以有 protected 和 default 包访问权限

34. 接口可以被继承吗？

    可以，可以用于扩展原接口中的方法，另外，接口还支持多继承。

35. 内部类的创建方式？

    若在外部类的非静态方法里面，可以直接使用 new InnerClass 进行创建；否则的话必须使用 new OuterClass().new InnerClass() 语法进行创建。

36. 为什么当创建一个内部类的对象时，该对象能够访问到外部对象的所有成员，而不需要其他权限？

    当某个外部类的对象创建了一个内部类对象时，此内部类对象必定会秘密地捕获一个指向那个外部类对象的引用。编译器通过修改内部类的构造器实现，编译后内部类第一个参数便是外部类对象的引用。因此，在构造内部类时，经常需要先创建外部类对象。

37. `.this ` 和 `.new` 语法的作用？

    在内部类中，如果你需要生成对外部类对象的引用，可以使用外部类的名字后面紧跟圆点和 this；

    有时你可能想要告知某些其他对象，去创建其某个内部类的对象，此时可以使用 `.new` 语法。

38. 什么是嵌套类？

    实际上就是静态内部类，此时将内部类声明位 static 即可，此时内部类并不包含有指向外部类对象的引用，因此，可以直接通过 `new OuterClass.StaticInnerClass()` 方式进行创建，并且，嵌套类不能访问非静态的外部类对象的属性。另外，接口中的内部类默认是嵌套类。

39. 匿名内部类的作用？

    通常使用 `New ClassOrInterfaceName(params) {...}`，另外，如果匿名类内部希望使用一个定义在其外部的对象，那么编译器要求其参数引用必须是 final 的，或者必须是 effective final 的，但是注意在实例化匿名类的时候，可以使用非 final 修饰的变量。匿名内部类与正规的继承相比有些受限，因为匿名内部类既可以扩展类，也可以实现接口，但是不能两者兼备。而且如果是实现接口，也只能实现一个接口。

40. 如何实现继承内部类？

    因为内部类的构造器必须连接到指向其外部类对象的引用，所以在继承内部类的时候，事情会变得有点复杂。问题在于，那个指向外部类对象的“秘密的”引用必须被初始化，而在派生类中不再存在可连接的默认对象。因此需要创建一个包含构造器，构造器的参数需要有一个外部类的对象引用，然后通过 `outerObj.super()` 进行初始化。

41. Java 集合类库的两个概念?

    集合（Collection）和映射（Map）。

42. 迭代器工作原理？

    在 Java 中所有的集合类都实现了 iterable 接口，iterable 接口只有一个 iterator() 方法，具体的 iterator 则由集合类自己定义，通常是内部类（private），通过提供如 hasNext，next 等方法实现目的。也可以为了实现其他功能修改 iterator，如 ListIterator 就提供了前后遍历的方式。

43. 如何在遍历 List 的时候删除元素？

    + 使用迭代器提供的 remove 方法进行删除
    + 使用普通的 for 循环删除，但是需要注意删除后需要修改索引值（不推荐）
    + Java8 后，可以使用 removeIf 方法进行删除

44. LinkedList 实现了 Queue 接口和继承了 List 接口实现，peek 和 element 方法有什么不同？

    peek 在没有元素的时候会返回 null，但是 element 则会抛出异常。

45. Map 下主要有几类实现类？

    HashMap，TreeMap，LinkedHashMap。

46. ArrayDeque 的实现和作用？

    通过循环数组实现，可以当作栈，队列，双端队列使用。



