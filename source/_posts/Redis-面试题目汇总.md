---
title: Redis 面试题目汇总
date: 2022-12-05 16:09:03
tags: ["Redis"]
---



本文整理了 Redis 的相关问题，以便更深入掌握 Redis。

<!-- More -->



1. Redis 介绍？

   Redis 是一个内存数据库，不过和传统的 RDBM 不同，Redis 属于 NoSQL，其存储类型为 KV。Redis 被广泛用于缓存方向，同时也可用于分布式锁，高速消息队列和事件发布与订阅等方面。Redis 提供了多种数据类型来支持不同的业务场景，还支持持久化、Lua 脚本、多种集群（主从复制模式，分布式切片集群）方案。

2. Redis 使用场景？

   + 热点数据的缓存
   + 限时业务应用，通过 expire 设置 key 的过期时间
   + 计数器相关问题
   + 分布式锁，通过 setnx 实现，通过 lua 脚本实现原子性
   + 延时操作，下单 10 分钟后无操作自动取消订单，通过 Zset 实现
   + 排行榜相关问题，使用 Zset 实现
   + 点赞，好友等相互关系存储，使用 Set 的集合命令实现
   + 队列，通过 list 可以实现简单队列，可以使用 Stream 提供消息队列支持，存在局限性

3. 那 NoSQL 的 BASE 理论是什么？

   BASE 理论是 CAP 理论中对一致性的妥协，和传统事务的 ACID 截然不同，BASE 不追求强一致性，而是允许数据在一段时间内是不一致的，但最终达到一致状态，从而获得更高的可用性和性能。

4. 分布式缓存常见的技术选型方案有哪些？

   使用比较多的是 Memcached 和 Redis，Memcached 是分布式缓存最开始兴起的那会，比较常用的，现在基本使用 Redis。

5. Redis 和 Memcached 的区别和共同点？

   共同点：内存数据库，过期策略，性能高。

   区别：

   + Redis 支持更丰富的数据类型，Memcached 只支持最简单的 k/v 数据类型
   + Redis 支持数据的持久化，灾难恢复机制，原生集群模式，Lua 脚本
   + Redis 采用的是 IO 多路复用模型，Memcached 使用多线程，非阻塞 IO 复用的网络模型
   + Redis 支持惰性删除和定期删除，但是 Memcached 只支持惰性删除

6. 为什么使用 Redis 作为 MySQL 缓存？

   高性能：将热点数据放在缓存中，就不用访问数据库了，提升用户体验

   高并发：数据在缓存中，支持更高级别的并发

7. Redis 对象机制解析？

   通过 void* ptr 指向实际的数据结构，使用 type 可以检查命令是否能够执行，检查 encoding 来选择合适的函数执行命令，实现了命令的多态；通过 lru 统计上一次访问时间，或者是 lfu 的相关信息，用于内存淘汰策略实现；通过 refcount 实现对象计数，便于进行对象共享（默认共享 10000 以内的整数）和内存回收。

8. Redis 是单线程吗？

   Redis 单线程指的是其处理用户指令，解析请求，进行数据读写，发送数据给客户端任务都是一个线程内执行的，但是 Redis 程序并不是单线程的：

   + Redis 2.6 版本之前，启动 2 个后台线程，用于关闭文件和 AOF 刷盘
   + Redis 4.0 版本之后，新增了一个后台线程（lazyfree），用来异步释放 Redis 内存。使用 del 会同步释放内存，处理大 key 的时候，可能造成卡顿，可以使用 unlink 命令

9. Redis 单线程模型详解？

   Redis 基于 Reactor 单线程实现，通过 IO 多路复用程序来监听来自客户端的大量连接，减少了资源的消耗，Redis 服务器本身是一个事件驱动程序，主要分为时间事件和文件事件。当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时，与操作相对应的文件事件就会产生，对应的文件事件处理器就会被调用。

10. Redis 没有使用多线程？为什么不使用多线程？

    Redis 其实在 4.0 之后就加入了对多线程的支持，在 6.0 后才算是使用了多线程，之前未使用的原因有：单线程编程容易维护，Redis 的性能瓶颈在内存和网络，多线程会带来上下文切换的开销等。

11. Redis 6.0 之后为何引入了多线程？

    主要是为了提高网络 IO 读写性能，因为这是其一个性能瓶颈，但是执行命令仍然是单线程顺序执行。因此，该版本之后，在 Redis 启动的时候，会创建以下线程：

    + Redis-server：主线程，主要负责执行命令
    + bio_close_file，bio_aof_fsync，bio_lazy_free：后台线程，处理耗时任务
    + io_thd_1，io_thd_2，io_thd_3：三个 IO 多线程，分担 Redis 的网络 IO 的压力

12. Redis 大 key 如何处理？

    大 key：指 key 对应的 value 很大，如 String 类型值大于 10KB，或者元素个数大于 5000 个

    大 key 影响：

    + 客户端超时阻塞
    + 引发网络阻塞
    + 阻塞工作线程
    + 内存分布不均（Slot 平均分配）
    + AOF 写回策略为 Always 时，每次写大 key 都会阻塞较长时间
    + AOF 重写和 RDB 快照时，都会进行 fork，fork 中需要复制父进程的页表，此过程耗时并且阻塞主进程，另外，如果开启了内存大页会产生写放大的问题

    通过以下方法找到大 key：

    + redis-cli --bigkeys：最好在从节点上执行，只能返回每种类型的最大一个 bigkey
    + 使用 SCAN 命令查找：使用 SCAN 扫描，使用 TYPE 查看类型，最后统计值大小
    + 使用 RdbTools 工具查找大 key

    删除大 key 的方式：

    + 分批次删除：hscan，pop，sranmember，zremrangebyrank
    + 异步删除：使用 unlink 代替 del 进行删除，不会造成阻塞

13. Redis 管道技术作用？

    是客户端提供的批处理技术，用于一次处理多个 Redis 命令，从而提升交互性能，可以解决多个命令执行时的网络等待。

14. Redis 给缓存数据设置过期时间有啥用？

    内存是有限的，节省内存资源；像 token 这类的数据存在时效性，如果利用传统数据库处理的话，这样更麻烦并且性能更差；在实现分布式锁的时候，可以防止获取了锁资源的进程意外宕机而造成锁资源一直没有释放的问题。

15. Redis 是如何判断数据是否过期的呢？

    Redis 通过过期字典来保存数据过期的事件，对应键值保存着其过期时间戳。

16. 过期的数据的删除策略了解么？

    惰性删除：只会在取出 key 的时候检查，对 CPU 友好，但是可能有太多过期 key 存在于缓存中

    定期删除：每隔一段时间抽取一批 key 执行删除过期 key 操作

    定时删除：设置过期时间的同时，创建一个定时器，定时器超时时执行删除操作

    Redis 采用的是定期删除 + 惰性删除，但是仍然存在定期删除和惰性删除漏掉了很多过期 key 的情况，可能导致 OOM，为了解决该问题，使用 Redis 内存淘汰机制。

17. Redis 如何做内存优化？

    缩减键和值的长度，共享对象池，字符串优化，编码优化，控制 key 的数量。

18. Redis 内存淘汰机制了解么？

    一共有 8 种：volatile-lru，volatile-lfu，volatile-ttl，volatile-random，allkeys-lru，allkeys-lfu，allkeys-random，no-eviction。通过 maxmemory_policy 配置。

19. Redis 持久化机制(怎么保证 Redis 挂掉之后再重启数据可以进行恢复)？

    支持 RDB 和 AOF 两种持久化机制，最好使用**混合持久化**（aof-use-rdb-preamble）。RDB 优点是文件紧凑，占用空间小，恢复速度快，AOF 优点是发生故障时，丢失的数据比 RDB 更少。

20. AOF 文件会越来越大，最后磁盘都装不下？

    当文件体积过大时，会自动创建子进程，专门对 AOF 进行重写。重写过程中，还需要将命令记录在 AOF 重写缓冲区，重写完成后，AOF 重写缓冲区的内容会被追加进去。

    > AOF 重写是通过读取数据库中的键值对来实现的

21. Redis 持久化时，对过期键如何处理？

    RDB 格式：

    + 生成阶段：会提前检查 key，过期的将将不会保存在新的 RDB 文件中
    + 加载阶段：
      + 如果是主服务器，会对其中的键检查，过期键不会被载入
      + 如果是从服务器，不会进行检查

    AOF 格式：

    + 写入阶段：会保存对应的过期键，在删除后会追加 DEL 命令
    + 重写阶段：会检查过期时间，已过期的键不会保存到重写后的 AOF 文件中

22. Redis 事务？

    并不支持原子性和持久性，实际上可以理解为将多个命令的请求打包，然后再顺序执行其中所有命令，该过程不会被打断。即使命令产生错误，也不会进行回滚，其原因：

    + Redis 事务执行时，错误通常是编程错误造成的，这种错误基本不会出现在生产环境中
    + 不支持事务回滚是因为这种复杂功能和 Redis 追求的简单高效设计主旨不符

23. 那Redis字符串有什么特点？

    Redis 的字符串如果保存的对象是整数类型，那么就用 int 存储。如果不能用整数表示，就用 SDS 来表示，SDS 通过记录长度，和预分配空间，可以高效计算长度，进行 append 操作。

24. Hash 扩容过程是怎样的？

    当装载因子超过阈值时，就会进行 rehash 过程，将 0 号表上的每个桶慢慢移动到 1 号表，所以叫渐进式 rehash。

25. 能详细说下Rehash过程吗？

    首先，生成新哈希表 ht[1]，为 ht[1] 分配空间。

    然后，迁移 ht[0] 数据到 ht[1]。在 Rehash进行期间，每次对字典执行增删查改操作，程序会顺带迁移一个 ht[0] 上的数据，并更新偏移索引。

    最后，ht[1] 和 ht[0] 指针对象交换。

26. 如果字典正在 Rehash，此时有请求过来，Redis 会怎么处理？

    针对新增 Key，是往 ht[1] 里面插入。针对读请求，先从 ht[0] 读，没找到再去 ht[1] 找。删除和更新操作和读操作类似。

27. 跳表的实现？

    本质上是对链表的一种优化，通过逐层跳步采样的方式构建索引，以加快查找速度。

28. 跳表的每个节点有多少层？

    使用概率均衡的思路，确定新插入节点的层数。Redis 使用随机函数决定层数。直观上来说，默认1层，和丢硬币一样，如果是正面就继续往上，这样持续迭代，最大层数 32 层。

29. Redis 的 Zset 为什么同时需要字典和跳表来实现？

    Zset 是一个有序列表，字典和跳表分别对应两种查询场景，字典用来支持按成员查询数据，跳表则用以实现高效的范围查询，这样两个场景，性能都做到了极致。

30. 为什么使用跳表而不是平衡树？

    + 内存占用上，平衡树每个节点 2 个指针，跳表每个节点 1/(1 - p) 个指针，Redis 中 p 为 0.25
    + 做范围查找的时候，跳表比平衡树操作更加简单
    + 算法实现上，跳表比平衡树简单

31. Redis 如何实现延迟队列？

    延迟队列指的是把当前要执行的任务，往后推迟一段时间再执行，如淘宝下单后超过一定时间未付款则自动取消订单任务。可以通过 Zset 实现，使用 score 当作执行时间戳，消费者通过 zrangebyscore 进行轮询处理。

32. Redis 机器挂掉怎么办？

    可以用主从模式部署，即有一个或多个备用机器，备用机会作为 Slave 同步 Master 的数据，在 Redis 出现问题的时候，把 Slave 升级为 Master。

33. 主从可以自动切换吗？

    本身是不能，但是 Redis 已经有了解决方案，即哨兵模式。哨兵来监测Redis服务是否正常，异常情况下，由哨兵代理切换。为避免哨兵成为单点，哨兵也需要多机部署。

34. 如果 Master 挂掉，会选择哪个 Slave 呢？

    当哨兵集群选举出哨兵 Leader 后，由哨兵 Leader 从 Redis 从节点中依次选择一个作为主节点

    + 优先级最高的节点
    + 复制偏移量最大的节点
    + runid 最小的节点

35. 前面你提到了哨兵 Leader，那它是怎么来的呢？

    当一个哨兵节点确认Redis集群的主节点主观下线后，会请求其他哨兵节点要求将自己选举为 Leader。如果一个哨兵节点获得的选举票数超过节点数的一半，且大于 quorum 配置的值，则该哨兵节点选举为Leader；否则重新进行选举。

36. 为什么 Redis 集群的哈希槽是 16384（2 的 14 次方）？

    Redis 在发送心跳包的时候需要将哈希槽的指派信息一起进行发送，如果使用 CRC16 原始范围，会造成心跳包过大，另一方面，Redis 集群一般不超过 1000 个节点，所以 16k 的槽位是个不错的选择。

37. 为什么 Redis 集群中不建议使用发布订阅？

    在集群模式下，所有的 publish 命令都会向所有节点（包括从节点）进行广播，造成网络带宽的严重消耗。

38. Redis 集群会有写操作丢失吗？

    会，Redis 并不保证数据的强一致性，在 failover 过程中可能存在数据丢失。

39. Redis 性能这么高，那它是协程模型，还是多线程模型？

    Redis 是单线程 Reactor 模型，通过高效的 IO 复用以及内存处理实现高性能。6.0 之后虽然加入了多线程来进行 IO 解包，但是处理逻辑依旧是单线程。

    另外，如果考虑到 RDB 的 Fork，一些定时任务的处理，那么 Redis 也可以说多进程，这没有问题。但是 Redis 对数据的处理，至始至终，都是单线程。

40. 可以详细说下6.0版本发布的多线程功能吗？

    多线程功能，主要用于提高解包的效率。和传统的 Multi Reactor 多线程模型不同，Redis 的多线程只负责处理网络 IO 的解包和协议转换，一方面是因为 Redis 的单线程处理足够快，另一方面也是为了兼容性做考虑。

41. 如果数据太大，Redis 存不下了怎么办？

    使用集群模式，也就是将数据分片，不同的 Key 根据 Hash 路由到不同的节点。集群索引是通过一致性Hash 算法来完成，这种算法可以解决服务器数量发生改变时，所有的服务器缓存在同一时间失效的问题。

42. 一致性Hash能详细讲一下吗？

    传统的 Hash 分片，在节点扩容或者缩容的时候，需要重新哈希。一致性Hash是说将数据和服务器，以相同的 Hash 函数，映射到同一个 Hash 环上，针对一个对象，在哈希环上顺时针查找距其最近的机器，这个机器就负责处理该对象的相关请求。这样在节点数量增加时，只有少量的数据需要重新哈希。

43. 如何设计一个缓存策略，可以动态缓存热点数据呢？

    通过数据最新访问时间来做排名，并过滤掉不常访问的数据，只留下经常访问的数据

    + 通过缓存系统做一个排序队列（存放 1000 个商品），系统根据访问时间进行排序
    + 系统定期删除排名最后的 200 个商品，并且从数据库中随机读取 200 个商品加入队列中

44. Redis 经常用作缓存，那数据一致性怎么保证？

    从设计思路来说，有 Cache Aside 和 Read/Write Through 两种模式，前者是把缓存责任交给应用层，后者是将缓存的责任，放置到服务提供方。

45. 如果数据发生变化，你会怎样去更新缓存？

    一般有四种方式：

    + 数据存到数据库中，成功后，再让缓存失效，等到读缓存不命中的时候，再加载进去；
    + 通过消息队列更新缓存；
    + 先更新缓存，再更新服务，这种情况相当于把 Cache 也做 Buffer 用；
    + 启动一个同步服务，作为 MySQL 一个从节点，通过解析 binlog 同步重要缓存

46. 说一下布隆过滤器的实现吧？

    底层是一个 64 位的整型，将字符串用多个 Hash 函数映射不同的二进制位置，将整型中对应位置设置为1。布隆过滤器优缺点都很明显，优点是空间、时间消耗都很小，缺点是结果不是完全准确，其能提供的信息是某样东西一定不存在或者可能存在。

47. 那 Redis 可以做消息队列吗？

    可以，但是并不合适，Redis 本身没有支持 AMQP 规范，消息队列该有的能力缺胳膊少腿，消息可靠性不强。甚至 Redis 作者都看不下去了，开源了 Disque 来专事专做。

48. 那你能谈谈 Redis 在秒杀场景的应用吗？

    Redis 主要是起到选拔流量的作用，记录商品总数，还有就是已下单数，等达到总数之后拦截所有请求。可以多放些请求进来，然后塞入消息队列。

49. 你能继续说说 Redis 在分布式锁中的应用吗？

    分布式锁也依赖存储组件，针对请求量的不同，可以选择 Etcd、MySQL、Redis  等。前两者可靠性更强，Redis 性能更高。

50. 基于 Redis 实现分布式锁有什么优缺点？

    优点：性能高效，实现方便，避免单点故障

    缺点：

    + 超时时间不好设置
    + 主从复制模式中的数据是异步复制的，这样导致分布式锁的不可靠性，可以使用 RedLock，其基本思路是让客户端和多个独立的 Redis 节点依次请求申请加锁，如果客户端能够和半数以上的节点成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁，否则加锁失败

51. 那我们再聊聊 Redis 在限流场景的应用吧？

    在微服务架构下，限频器也需要分布式化。在分布式令牌桶中，Redis 负责管理令牌，微服务需要进行函数操作，就向 Redis 申请令牌，如果 Redis 当前还有令牌，就发放给它。拿到令牌，才能进行下一步操作。另一方面，令牌不光要消耗，还需要补充，出于性能考虑，可以使用懒生成的方式：使用令牌时，顺便生成令牌。这样子还有个好处：令牌的获取，和令牌的生成，都可以在一个 Lua 脚本中，保证了原子性。
