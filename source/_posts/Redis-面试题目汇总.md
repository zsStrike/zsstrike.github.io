---
title: Redis 面试题目汇总
date: 2022-12-05 16:09:03
tags: ["Redis"]
---



本文整理了 Redis 的相关问题，以便更深入掌握 Redis。

<!-- More -->



1. Redis 有哪些数据结构？

   简单动态字符串，双向链表，压缩链表，哈希表，整数集合，跳表，在 3.2 版本后新增 quicklist，用于降低双向链表空间浪费的现象，在 5.0 版本后新增 listpack，用于解决级联更新问题。

2. Redis 数据结构中的哈希表内部实际存在几张哈希表，为什么？

   实际存在两张哈希表，用于实现渐进式 rehash 策略。

3. Redis 数据结构中的整数集合何时会升级，是否能够降级？

   在存储元素的字节长度大于编码长度时，就会执行升级操作，升级后不能降级。

4. Redis 数据结构中的跳表实现原理？

   跳表实际上是多层的有序链表，通常越高层的跨度越大，在每个节点维护一个 32 层的指针，通过 0.25 的概率来决定上层是否存在指针，使得得到的跳表更加扁平。

5. 为什么需要 quicklist 和 listpack？

   前者为了解决双向链表空间浪费问题，后者则主要为了解决压缩链表级联更新的问题。

6. Redis 是如何存储某个数据库中的数据的？

   本身使用了哈希表来保存所有的数据，哈希桶存放的是键值对的指针，指针的类型都通过对象结构来解码，但是键的指针只能是 String 对象。

7. Redis 是如何解析 RedisObject 的？

   其中包含了 type 和 encoding 两个属性，前者表示对象的类型，后者表示使用的编码，通过 void* ptr 指向对应的真实数据类型。

8. Redis 存在哪些数据类型？

   主要存在五种数据类型：String，List，Hash，Set，Zset。还存在四种复合类型：BitMap，Hyperloglog，GEO，Stream 类型。

9. Hyperloglog 类型的主要目的是？

   提供不精确的去重计数，误差率大约是 0.81%，可以节省大量的内存。

10. Redis 如何实现分布式锁？

    `SET lock_key unique_value NX PX 10000`，设置过期时间是为了防止 Redis 崩溃而不能及时释放资源，解锁可以通过 DEL 命令实现，但是需要先检查是否是自己的锁，可以配合 LUA 脚本。

11. 如何使用 List 实现消息队列，为什么还推出 Stream？List 实现消息队列：LPUSH/RBPOP，但是存在的问题是需要生产者实现消息唯一 ID，不是很方便；Stream 则是专门为消息队列设计的数据类型，支持自动生成全局唯一 ID，并且以消费组消费数据

12. Stream 如何保证消息确实被消费了？

    Stream 会使用 PENDING LIST 留存消费组每个消费者读取的消息，直到收到对应的 ACK，消费者在重启后，可以通过 XPENDING 来查看已读取，但尚未确认的消息，从而保证消息确实被消费了。

13. Stream 存在哪些问题？

    存在数据丢失问题，主要原因在 AOF 先执行命令，后写日志；主从复制在进行主从切换时，也会发生数据丢失问题；面对消息挤压，内存资源紧张。

14. RDB 快照存储格式以及生成方式？

    RDB 快照采用二进制文件保存，因此其恢复速度很快；生成方式主要有两种，save 和 bgsave，前者会阻塞主线程，一般使用 bgsave。由于采用的是子进程处理，并且采用写时复制技术，当有新的命令到来时，此时原来的主进程会复制一块内存用于修改，而子进程读到的还是原来的数据。

15. AOF 日志存储格式？

    里面保存的是一条条用户的指令，在恢复时，只需要按顺序执行即可。

16. 为什么 Redis 选择先执行写操作，再将其写入 AOF 日志？

    避免恢复时的检查开销，不会阻塞当前写操作命令的执行。

17. AOF 日志落盘策略（appendfsync）有哪些？

    Always，Everysec 和 No。Always 能够最大程度保证数据完成性，但是存在性能上的问题。

18. AOF 日志时，当 appendfsync 为 always，是否可能会丢失数据？

    仍然可能会，在 Redis 的事件循环中，是先将对应的 AOF 数据写入 aof_buf 中，在结束本次循环前，会执行 flushAppendOnlyFile 函数，因此，若出现故障停机，可能会丢失一个事件循环中所产生的命令数据。

19. 如何解决 AOF 文件随时间流逝越来越大的问题？

    AOF 重写机制，对于相同键的写命令，可以将它们合并为一个命令，达到节省内存的作用。一般通过 bgrewriteaof 后台子进程完成。

20. AOF 重写机制（bgrewriteaof）是怎样的？

    为了记录重写过程中新到来的指令，存在一个 AOF 重写缓冲区，用于保存重写过程中的用户指令，该 AOF 缓冲区最终将会追加到新的 AOF 文件中，最终原子替换原来的 AOF 日志文件。

21. AOF 缓冲区和 AOF 重写缓冲区的异同点？

    都是暂时保存日志的缓冲区；前者目的在于保证 AOF 日志的完整性，通过 appendfsync 策略控制，后者则是为了保证重写 AOF 日志替换现有 AOF 日志后没有数据丢失。

22. 混合持久化存在的意义？

    RDB 快照恢复速度快，但是发生崩溃时会丢失上次 RDB 快照至今的命令数据；AOF 方式虽然解决了大量数据丢失的问题，但是在文件很大时，恢复过程缓慢。因此，可以考虑使用混合持久化，只需要配置 `aof-use-rdb-preamble` 参数即可。

23. 主从复制的意义是什么？

    避免单点故障，为 Redis 服务提供高可用所必须的操作。

24. 主从复制的具体过程？

    主要分为三个阶段：

    + 从服务器执行 replicaof 命令，其会向主服务器建立连接，协商得到 runID 和 offset 等信息
    + 主服务器在后台执行 bgsave 命令，在此过程中执行的写命令会被记录到 replication buffer 中，生成完成 RDB 后，通过网络传送到从服务器从服务器接收到 RDB 文件后载入即可
    + 主服务器将 replication buffer 中的新到来的写操作发送给从服务器，从服务器执行其即可

25. 增量复制发生的时机，以及对应的原理？

    增量复制发生在主从服务器网络发生断开，之后又重新连接的场景下。此时服务器根据 `psync {runid} {offset}` 来进行增量复制。该实现过程通过环形缓冲区 repl_backlog_buffer 实现，主从服务器分别记录自己的 offset，从而实现增量同步，如果从服务器 offset 对应的数据已经被覆盖，则通过全量复制实现，可以通过 repl_backlog_size 设置该环形缓冲区大小。

26. replication buffer 和 repl_backlog_buffer 的区别？

    前者指写操作数据传送到从服务器时通信所需的缓冲区，若存在多个从服务器，则其中的数据不一定相同；后者指的是增量复制发生时，从何处开始进行增量复制操作，主要用于找到主从差异数据而设计的环形缓冲区。

27. 主从同步时，主服务器不进行持久化时存在那些安全隐患？

    若主服务器没有开启持久化，应该将其配置为避免自动重启，否则自动重启后主节点上只有一个空数据集，并且会复制到其它从节点上。

28. 为什么还存在从库的从库，这种架构模式？

    若所有的从库连接到相同主库上，会给主库带来网络和磁盘上的消耗，容易造成单点故障。

29. Redis 中的无磁盘复制模式？

    Redis 默认使用磁盘复制，但是其性能收到磁盘速度的限制，无磁盘复制模式即创建一个新进程直接 dump RDB 到 slave 的 socket，不经过硬盘，适用于网络较快的情况。

30. 从库是否会检查数据是否过期？

    在主从复制中，从节点不会主动删除数据，而是通过主节点控制从节点来删除过期数据；在 Redis 3.2 后，从节点在读取数据的时候，增加了对数据是否过期的判断（惰性删除）。

31. 哨兵机制的意义？

    通过部署一系列的哨兵节点，让其时刻监视主从服务节点，在主从节点发生故障时，能够自动进行故障转移的功能。

32. 哨兵节点的作用是什么？

    主要作用有三点：监控，选主，通知。

    + 监控：通过 ping 命令判断主从节点是否发生故障，一旦检测到主观下线，就会和其他哨兵节点协商，达到 quorum 值便可确定其为客观下线
    + 选主：
      + 在已下线主节点的所有从节点中选取一个从节点，将其当作新的主节点：`SLAVEOF no one`
      + 让已下线主节点的所有其他从节点修改复制目标，修改其为新的主节点：`SLAVEOF`
      + 将新主节点的 IP 地址和信息，通过发布订阅机制通知给客户端：` +switch-master `
      + 继续监视原来的旧主节点，但这个旧主节点重新上线时，修改其为从节点

33. 哨兵节点发现客观下线后，选主的依据是什么？

    首先过滤网络状态不好的节点，其次按照优先级，复制进度和 ID 号挑选新从节点作为新的主节点。

34. 哨兵节点发送的 INFO 命令的作用？

    用于获取该节点的角色信息，如其对应的从节点列表等。

35. 通常哨兵机制中使用了哨兵集群，如何让哨兵之间互相发现彼此（哨兵发现）？

    通过命令 `sentinel monitor <master-name> <ip> <redis-port> <quorum>` 进行哨兵配置，主节点中存在 `__sentinel__:hello` 频道，其他哨兵可以通过订阅该频道，用以发现其他哨兵并进行连接。

36. 哨兵集群中的哨兵节点如何发现主节点下的从节点？

    通过 INFO 命令，主节点会返回所有的从节点信息。

37. 什么是主从集群脑裂现象，产生原因和解决方案？

    产生原因：由于网络问题，导致集群节点之间失去联系，主从节点间数据不同步，哨兵重新选举，产生两个主节点，等待网络恢复，旧主节点会降级为从节点，由于其与新节点进行同步复制的时候，会清空自己的缓冲区，导致之前客户端写入的数据被丢失。

    解决方案：当主节点发现从节点下线或者通信延迟过大时，那么禁止主节点进行写数据，直接把错误返回给客户端，以减少数据丢失，可以通过以下两个参数控制

    + min-slaves-to-write x，主节点必须要有至少 x 个从节点连接，如果小于这个数，主节点会禁止写数据
    + min-slaves-max-lag x，主从数据复制和同步的延迟不能超过 x 秒，如果超过，主节点会禁止写数据

38. 为什么需要切片集群模式？

    当 Redis 缓存数据量大到一台服务器无法缓存时，就需要使用切片集群模式，其将数据分布在不同的服务器上，以此降低系统对单节点的依赖，提高读写性能，实际上就是服务器 Sharding 技术。

39. Redis 中，切片集群模式的实现？

    采用哈希槽来处理数据和节点之间的映射关系，一个切片集群共有 16384 个哈希槽，通过 CRC16 和取模实现 key 到哈希槽的映射。可以平均分配哈希槽到服务节点，也可以手动进行分配。

40. 哈希槽和一致性哈希？

    + 哈希槽指的是先将用户数据划分到槽里面，然后将槽划分到不同服务器节点上，可以为不同硬件服务器自定义槽数目大小
    + 一致性哈希则是将服务器节点划分在一个哈希环上，主要目的是减少新增节点导致的重新哈希的问题，容易产生数据倾斜问题，可以引入虚拟节点映射减轻该问题

41. 什么是缓存雪崩，如何应对？

    大量缓存数据在同一时间过期，或者 Redis 故障宕机时，此时大量的请求访问数据库，从而导致数据库压力骤增，严重的会造成数据库宕机，而造成系统崩溃。对于大量数据在同一时间过期，可以均匀设置过期时间，后台更新缓存；对于 Redis 宕机，可以采用服务熔断，请求限流或者构建 Redis 高可用集群。

42. 什么是缓存击穿，如何应对？

    如果缓存中的某个热点数据过期，此时大量的请求访问该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮。可以采用互斥锁来保证同一时间内只有一个请求来构建缓存，同时设置超时时间防止死锁，或者采取永远不过期策略，让后台线程定时更新，抑或是进行缓存预热。

43. 什么是缓存穿透，如何应对？

    当用户访问的数据，既不在缓存中，也不在数据库中，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，没办法构建缓存数据，来服务后续的请求，就到导致服务器的压力骤增。可以采取限制非法请求，缓存默认值，或者使用布隆过滤器快速判断数据是否存在。

44. 布隆过滤器工作原理？

    使用使用位图和多个哈希函数快速判断数据是否存在数据库中，查询布隆过滤器说数据存在，并不一定证明数据库中存在这个数据，但是查询到数据不存在，则数据库中一定就不存在这个数据。

45. 使用 Redis 作为缓存时，如果采用 Write Update 方式，可能存在哪些问题？

    更新数据时，不论是先更新数据库，再更新缓存，还是先更新缓存，再更新数据库，都可能会产生不一致现象。

46. 使用 Redis 作为缓存时，一般使用的缓存策略是什么？

    Cache Aside：在更新数据时先更新数据库，再删除缓存中的数据；而在读取数据时，发现缓存中没了数据之后，直接从数据库中读取数据，并更新到缓存中。注意写操作时不能先删除缓存中的数据，再更新数据库，这在写读并发可能带来不一致现象。而在读写并发时，存在极小概率会产生不一致，原因是缓存的写入通常远远快于数据库的写入。

47. Cache Aside 策略会对命中率产生影响，如何缓解？

    + 更新数据时同样更新缓存，不过需要加分布式锁；
    + 更新数据时同样更新缓存，不过需要加过期时间，保证最终一致性

48. 如何保证 Cache Aside 策略中先更新数据库，再更新缓存的操作都能成功？

    + 重试机制：引入消息队列，如果删除缓存的操作未成功，那就重试
    + 订阅 MySQL binlog，再操作缓存：阿里巴巴开源 Canal 中间件的实现方式

49. Redis 作为数据库缓存时，能否采用 Write Back 策略？

    Write Back 写策略则只需标记缓存数据为脏数据之后，直接返回即可，在写未命中时，采用 Write Allocate 方式。读策略在未命中的情况下如果发现被置换的缓存块是脏块，则需要将其写入数据库。该策略不能被应用到我们常用的数据库和缓存的场景中，因为缓存一般是非持久化的，如果缓存机器掉电，脏块数据就会丢失。

50. Redis 如何实现分布式锁？

    + 最简化版本：使用 setnx key value 和 delete key 实现加锁和释放锁
    + 支持过期时间：防止获取了锁的服务挂掉而没有释放锁资源，使用 set key value nx ex seconds
    + 加上 owner：防止其他服务删除该服务已获取到的锁，可以设置不同的 value 表示不同的 owner
    + 整合原子操作：加上 owner 后需要先检查，如果是自己的锁再释放，该过程不是原子性的，使用 Lua

51. Redis 如何保证分布式锁的可靠性？

    + 容灾考虑：
      + 主从容灾：Redis 的哨兵模式可以灵活切换，但是存在同步时延的问题
      + 多机部署：使用 Redis 中的 RedLock，只有超过半数同意才能算请求成功
    + 没有完全可靠的分布式锁，存在三大困境：网络延迟，进程暂停，时钟漂移

52. Redis 为什么这么快？

    + 基于内存实现，没有 IO 开销
    + 高效的数据结构：如 SDS，快表，跳跃表
    + 合理的数据编码：如 String 对象存储数字的时候，采用 int 类型编码，非数字采用 SDS 编码
    + 合适的线程模型：采用 Reactor 单线程模型，省去了上下文切换的开销（执行命令是单线程）

53. Redis 介绍？

    Redis 是一个内存数据库，不过和传统的 RDBM 不同，Redis 属于 NoSQL，其存储类型为 KV。Redis 被广泛用于缓存方向，同时也可用于分布式锁，高速消息队列和事件发布与订阅等方面。Redis 提供了多种数据类型来支持不同的业务场景，还支持持久化、Lua 脚本、多种集群（主从复制模式，分布式切片集群）方案。

54. Redis 使用场景？

    + 热点数据的缓存
    + 限时业务应用，通过 expire 设置 key 的过期时间
    + 计数器相关问题
    + 分布式锁，通过 setnx 实现，通过 lua 脚本实现原子性
    + 延时操作，下单 10 分钟后无操作自动取消订单，通过 Zset 实现
    + 排行榜相关问题，使用 Zset 实现
    + 点赞，好友等相互关系存储，使用 Set 的集合命令实现
    + 队列，通过 list 可以实现简单队列，可以使用 Stream 提供消息队列支持，存在局限性

55. 那 NoSQL 的 BASE 理论是什么？

    BASE 理论是 CAP 理论中对一致性的妥协，和传统事务的 ACID 截然不同，BASE 不追求强一致性，而是允许数据在一段时间内是不一致的，但最终达到一致状态，从而获得更高的可用性和性能。

56. 分布式缓存常见的技术选型方案有哪些？

    使用比较多的是 Memcached 和 Redis，Memcached 是分布式缓存最开始兴起的那会，比较常用的，现在基本使用 Redis。

57. Redis 和 Memcached 的区别和共同点？

    共同点：内存数据库，过期策略，性能高。

    区别：

    + Redis 支持更丰富的数据类型，Memcached 只支持最简单的 k/v 数据类型
    + Redis 支持数据的持久化，灾难恢复机制，原生集群模式，Lua 脚本
    + Redis 采用的是 IO 多路复用模型，Memcached 使用多线程，非阻塞 IO 复用的网络模型
    + Redis 支持惰性删除和定期删除，但是 Memcached 只支持惰性删除

58. 为什么使用 Redis 作为 MySQL 缓存？

    高性能：将热点数据放在缓存中，就不用访问数据库了，提升用户体验

    高并发：数据在缓存中，支持更高级别的并发

59. Redis 对象机制解析？

    通过 void* ptr 指向实际的数据结构，使用 type 可以检查命令是否能够执行，检查 encoding 来选择合适的函数执行命令，实现了命令的多态；通过 lru 统计上一次访问时间，或者是 lfu 的相关信息，用于内存淘汰策略实现；通过 refcount 实现对象计数，便于进行对象共享（默认共享 10000 以内的整数）和内存回收。

60. Redis 是单线程吗？

    Redis 单线程指的是其处理用户指令，解析请求，进行数据读写，发送数据给客户端任务都是一个线程内执行的，但是 Redis 程序并不是单线程的：

    + Redis 2.6 版本之前，启动 2 个后台线程，用于关闭文件和 AOF 刷盘
    + Redis 4.0 版本之后，新增了一个后台线程（lazyfree），用来异步释放 Redis 内存。使用 del 会同步释放内存，处理大 key 的时候，可能造成卡顿，可以使用 unlink 命令

61. Redis 单线程模型详解？

    Redis 基于 Reactor 单线程实现，通过 IO 多路复用程序来监听来自客户端的大量连接，减少了资源的消耗，Redis 服务器本身是一个事件驱动程序，主要分为时间事件和文件事件。当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时，与操作相对应的文件事件就会产生，对应的文件事件处理器就会被调用。

62. Redis 没有使用多线程？为什么不使用多线程？

    Redis 其实在 4.0 之后就加入了对多线程的支持，在 6.0 后才算是使用了多线程，之前未使用的原因有：单线程编程容易维护，Redis 的性能瓶颈在内存和网络，多线程会带来上下文切换的开销等。

63. Redis 6.0 之后为何引入了多线程？

    主要是为了提高网络 IO 读写性能，因为这是其一个性能瓶颈，但是执行命令仍然是单线程顺序执行。因此，该版本之后，在 Redis 启动的时候，会创建以下线程：

    + Redis-server：主线程，主要负责执行命令
    + bio_close_file，bio_aof_fsync，bio_lazy_free：后台线程，处理耗时任务
    + io_thd_1，io_thd_2，io_thd_3：三个 IO 多线程，分担 Redis 的网络 IO 的压力

64. Redis 大 key 如何处理？

    大 key：指 key 对应的 value 很大，如 String 类型值大于 10KB，或者元素个数大于 5000 个

    大 key 影响：

    + 客户端超时阻塞
    + 引发网络阻塞
    + 阻塞工作线程
    + 内存分布不均（Slot 平均分配）
    + AOF 写回策略为 Always 时，每次写大 key 都会阻塞较长时间
    + AOF 重写和 RDB 快照时，都会进行 fork，fork 中需要复制父进程的页表，此过程耗时并且阻塞主进程，另外，如果开启了内存大页会产生写放大的问题

    通过以下方法找到大 key：

    + redis-cli --bigkeys：最好在从节点上执行，只能返回每种类型的最大一个 bigkey
    + 使用 SCAN 命令查找：使用 SCAN 扫描，使用 TYPE 查看类型，最后统计值大小
    + 使用 RdbTools 工具查找大 key

    删除大 key 的方式：

    + 分批次删除：hscan，pop，sranmember，zremrangebyrank
    + 异步删除：使用 unlink 代替 del 进行删除，不会造成阻塞

65. Redis 管道技术作用？

    是客户端提供的批处理技术，用于一次处理多个 Redis 命令，从而提升交互性能，可以解决多个命令执行时的网络等待。

66. Redis 给缓存数据设置过期时间有啥用？

    内存是有限的，节省内存资源；像 token 这类的数据存在时效性，如果利用传统数据库处理的话，这样更麻烦并且性能更差；在实现分布式锁的时候，可以防止获取了锁资源的进程意外宕机而造成锁资源一直没有释放的问题。

67. Redis 是如何判断数据是否过期的呢？

    Redis 通过过期字典来保存数据过期的事件，对应键值保存着其过期时间戳。

68. 过期的数据的删除策略了解么？

    惰性删除：只会在取出 key 的时候检查，对 CPU 友好，但是可能有太多过期 key 存在于缓存中

    定期删除：每隔一段时间抽取一批 key 执行删除过期 key 操作

    定时删除：设置过期时间的同时，创建一个定时器，定时器超时时执行删除操作

    Redis 采用的是定期删除 + 惰性删除，但是仍然存在定期删除和惰性删除漏掉了很多过期 key 的情况，可能导致 OOM，为了解决该问题，使用 Redis 内存淘汰机制。

69. Redis 如何做内存优化？

    缩减键和值的长度，共享对象池，字符串优化，编码优化，控制 key 的数量。

70. Redis 内存淘汰机制了解么？

    一共有 8 种：volatile-lru，volatile-lfu，volatile-ttl，volatile-random，allkeys-lru，allkeys-lfu，allkeys-random，no-eviction。通过 maxmemory_policy 配置。

71. Redis 持久化机制(怎么保证 Redis 挂掉之后再重启数据可以进行恢复)？

    支持 RDB 和 AOF 两种持久化机制，最好使用**混合持久化**（aof-use-rdb-preamble）。RDB 优点是文件紧凑，占用空间小，恢复速度快，AOF 优点是发生故障时，丢失的数据比 RDB 更少。

72. AOF 文件会越来越大，最后磁盘都装不下？

    当文件体积过大时，会自动创建子进程，专门对 AOF 进行重写。重写过程中，还需要将命令记录在 AOF 重写缓冲区，重写完成后，AOF 重写缓冲区的内容会被追加进去。

    > AOF 重写是通过读取数据库中的键值对来实现的

73. Redis 持久化时，对过期键如何处理？

    RDB 格式：

    + 生成阶段：会提前检查 key，过期的将将不会保存在新的 RDB 文件中
    + 加载阶段：
      + 如果是主服务器，会对其中的键检查，过期键不会被载入
      + 如果是从服务器，不会进行检查

    AOF 格式：

    + 写入阶段：会保存对应的过期键，在删除后会追加 DEL 命令
    + 重写阶段：会检查过期时间，已过期的键不会保存到重写后的 AOF 文件中

74. Redis 事务？

    并不支持原子性和持久性，实际上可以理解为将多个命令的请求打包，然后再顺序执行其中所有命令，该过程不会被打断。即使命令产生错误，也不会进行回滚，其原因：

    + Redis 事务执行时，错误通常是编程错误造成的，这种错误基本不会出现在生产环境中
    + 不支持事务回滚是因为这种复杂功能和 Redis 追求的简单高效设计主旨不符

75. 那Redis字符串有什么特点？

    Redis 的字符串如果保存的对象是整数类型，那么就用 int 存储。如果不能用整数表示，就用 SDS 来表示，SDS 通过记录长度，和预分配空间，可以高效计算长度，进行 append 操作。

76. Hash 扩容过程是怎样的？

    当装载因子超过阈值时，就会进行 rehash 过程，将 0 号表上的每个桶慢慢移动到 1 号表，所以叫渐进式 rehash。

77. 能详细说下Rehash过程吗？

    首先，生成新哈希表 ht[1]，为 ht[1] 分配空间。

    然后，迁移 ht[0] 数据到 ht[1]。在 Rehash进行期间，每次对字典执行增删查改操作，程序会顺带迁移一个 ht[0] 上的数据，并更新偏移索引。

    最后，ht[1] 和 ht[0] 指针对象交换。

78. 如果字典正在 Rehash，此时有请求过来，Redis 会怎么处理？

    针对新增 Key，是往 ht[1] 里面插入。针对读请求，先从 ht[0] 读，没找到再去 ht[1] 找。删除和更新操作和读操作类似。

79. 跳表的实现？

    本质上是对链表的一种优化，通过逐层跳步采样的方式构建索引，以加快查找速度。

80. 跳表的每个节点有多少层？

    使用概率均衡的思路，确定新插入节点的层数。Redis 使用随机函数决定层数。直观上来说，默认1层，和丢硬币一样，如果是正面就继续往上，这样持续迭代，最大层数 32 层。

81. Redis 的 Zset 为什么同时需要字典和跳表来实现？

    Zset 是一个有序列表，字典和跳表分别对应两种查询场景，字典用来支持按成员查询数据，跳表则用以实现高效的范围查询，这样两个场景，性能都做到了极致。

82. 为什么使用跳表而不是平衡树？

    + 内存占用上，平衡树每个节点 2 个指针，跳表每个节点 1/(1 - p) 个指针，Redis 中 p 为 0.25
    + 做范围查找的时候，跳表比平衡树操作更加简单
    + 算法实现上，跳表比平衡树简单

83. Redis 如何实现延迟队列？

    延迟队列指的是把当前要执行的任务，往后推迟一段时间再执行，如淘宝下单后超过一定时间未付款则自动取消订单任务。可以通过 Zset 实现，使用 score 当作执行时间戳，消费者通过 zrangebyscore 进行轮询处理。

84. Redis 机器挂掉怎么办？

    可以用主从模式部署，即有一个或多个备用机器，备用机会作为 Slave 同步 Master 的数据，在 Redis 出现问题的时候，把 Slave 升级为 Master。

85. 主从可以自动切换吗？

    本身是不能，但是 Redis 已经有了解决方案，即哨兵模式。哨兵来监测Redis服务是否正常，异常情况下，由哨兵代理切换。为避免哨兵成为单点，哨兵也需要多机部署。

86. 如果 Master 挂掉，会选择哪个 Slave 呢？

    当哨兵集群选举出哨兵 Leader 后，由哨兵 Leader 从 Redis 从节点中依次选择一个作为主节点

    + 优先级最高的节点
    + 复制偏移量最大的节点
    + runid 最小的节点

87. 前面你提到了哨兵 Leader，那它是怎么来的呢？

    当一个哨兵节点确认Redis集群的主节点主观下线后，会请求其他哨兵节点要求将自己选举为 Leader。如果一个哨兵节点获得的选举票数超过节点数的一半，且大于 quorum 配置的值，则该哨兵节点选举为Leader；否则重新进行选举。

88. 为什么 Redis 集群的哈希槽是 16384（2 的 14 次方）？

    Redis 在发送心跳包的时候需要将哈希槽的指派信息一起进行发送，如果使用 CRC16 原始范围，会造成心跳包过大，另一方面，Redis 集群一般不超过 1000 个节点，所以 16k 的槽位是个不错的选择。

89. 为什么 Redis 集群中不建议使用发布订阅？

    在集群模式下，所有的 publish 命令都会向所有节点（包括从节点）进行广播，造成网络带宽的严重消耗。

90. Redis 集群会有写操作丢失吗？

    会，Redis 并不保证数据的强一致性，在 failover 过程中可能存在数据丢失。

91. Redis 性能这么高，那它是协程模型，还是多线程模型？

    Redis 是单线程 Reactor 模型，通过高效的 IO 复用以及内存处理实现高性能。6.0 之后虽然加入了多线程来进行 IO 解包，但是处理逻辑依旧是单线程。

    另外，如果考虑到 RDB 的 Fork，一些定时任务的处理，那么 Redis 也可以说多进程，这没有问题。但是 Redis 对数据的处理，至始至终，都是单线程。

92. 可以详细说下6.0版本发布的多线程功能吗？

    多线程功能，主要用于提高解包的效率。和传统的 Multi Reactor 多线程模型不同，Redis 的多线程只负责处理网络 IO 的解包和协议转换，一方面是因为 Redis 的单线程处理足够快，另一方面也是为了兼容性做考虑。

93. 如果数据太大，Redis 存不下了怎么办？

    使用集群模式，也就是将数据分片，不同的 Key 根据 Hash 路由到不同的节点。集群索引是通过一致性Hash 算法来完成，这种算法可以解决服务器数量发生改变时，所有的服务器缓存在同一时间失效的问题。

94. 一致性Hash能详细讲一下吗？

    传统的 Hash 分片，在节点扩容或者缩容的时候，需要重新哈希。一致性Hash是说将数据和服务器，以相同的 Hash 函数，映射到同一个 Hash 环上，针对一个对象，在哈希环上顺时针查找距其最近的机器，这个机器就负责处理该对象的相关请求。这样在节点数量增加时，只有少量的数据需要重新哈希。

95. 如何设计一个缓存策略，可以动态缓存热点数据呢？

    通过数据最新访问时间来做排名，并过滤掉不常访问的数据，只留下经常访问的数据

    + 通过缓存系统做一个排序队列（存放 1000 个商品），系统根据访问时间进行排序
    + 系统定期删除排名最后的 200 个商品，并且从数据库中随机读取 200 个商品加入队列中

96. Redis 经常用作缓存，那数据一致性怎么保证？

    从设计思路来说，有 Cache Aside 和 Read/Write Through 两种模式，前者是把缓存责任交给应用层，后者是将缓存的责任，放置到服务提供方。

97. 如果数据发生变化，你会怎样去更新缓存？

    一般有四种方式：

    + 数据存到数据库中，成功后，再让缓存失效，等到读缓存不命中的时候，再加载进去；
    + 通过消息队列更新缓存；
    + 先更新缓存，再更新服务，这种情况相当于把 Cache 也做 Buffer 用；
    + 启动一个同步服务，作为 MySQL 一个从节点，通过解析 binlog 同步重要缓存

98. 说一下布隆过滤器的实现吧？

    底层是一个 64 位的整型，将字符串用多个 Hash 函数映射不同的二进制位置，将整型中对应位置设置为1。布隆过滤器优缺点都很明显，优点是空间、时间消耗都很小，缺点是结果不是完全准确，其能提供的信息是某样东西一定不存在或者可能存在。

99. 那 Redis 可以做消息队列吗？

    可以，但是并不合适，Redis 本身没有支持 AMQP 规范，消息队列该有的能力缺胳膊少腿，消息可靠性不强。甚至 Redis 作者都看不下去了，开源了 Disque 来专事专做。

100. 那你能谈谈 Redis 在秒杀场景的应用吗？

     Redis 主要是起到选拔流量的作用，记录商品总数，还有就是已下单数，等达到总数之后拦截所有请求。可以多放些请求进来，然后塞入消息队列。

101. 你能继续说说 Redis 在分布式锁中的应用吗？

     分布式锁也依赖存储组件，针对请求量的不同，可以选择 Etcd、MySQL、Redis  等。前两者可靠性更强，Redis 性能更高。

102. 基于 Redis 实现分布式锁有什么优缺点？

     优点：性能高效，实现方便，避免单点故障

     缺点：

     + 超时时间不好设置
     + 主从复制模式中的数据是异步复制的，这样导致分布式锁的不可靠性，可以使用 RedLock，其基本思路是让客户端和多个独立的 Redis 节点依次请求申请加锁，如果客户端能够和半数以上的节点成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁，否则加锁失败

103. 那我们再聊聊 Redis 在限流场景的应用吧？

     在微服务架构下，限频器也需要分布式化。在分布式令牌桶中，Redis 负责管理令牌，微服务需要进行函数操作，就向 Redis 申请令牌，如果 Redis 当前还有令牌，就发放给它。拿到令牌，才能进行下一步操作。另一方面，令牌不光要消耗，还需要补充，出于性能考虑，可以使用懒生成的方式：使用令牌时，顺便生成令牌。这样子还有个好处：令牌的获取，和令牌的生成，都可以在一个 Lua 脚本中，保证了原子性。
