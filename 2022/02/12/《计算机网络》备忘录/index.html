<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;zh-HK&quot;,&quot;zh-TW&quot;,&quot;default&quot;]" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>《计算机网络》备忘录 | zsStrike</title><meta name="keywords" content="计算机网络"><meta name="author" content="zsStrike"><meta name="copyright" content="zsStrike"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="计算机网络相关知识，用作备忘录，以备查阅。">
<meta property="og:type" content="article">
<meta property="og:title" content="《计算机网络》备忘录">
<meta property="og:url" content="http://blog.zsstrike.xyz/2022/02/12/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E5%A4%87%E5%BF%98%E5%BD%95/index.html">
<meta property="og:site_name" content="zsStrike">
<meta property="og:description" content="计算机网络相关知识，用作备忘录，以备查阅。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://blog.zsstrike.xyz/assets/default_cover.png">
<meta property="article:published_time" content="2022-02-12T12:35:53.000Z">
<meta property="article:modified_time" content="2022-05-16T07:41:46.255Z">
<meta property="article:author" content="zsStrike">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://blog.zsstrike.xyz/assets/default_cover.png"><link rel="shortcut icon" href="/assets/avatar.jpg"><link rel="canonical" href="http://blog.zsstrike.xyz/2022/02/12/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E5%A4%87%E5%BF%98%E5%BD%95/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":5000,"languages":{"author":"作者: zsStrike","link":"链接: ","source":"来源: zsStrike","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '《计算机网络》备忘录',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-05-16 15:41:46'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/assets/avatar.jpg" onerror="onerror=null;src='/assets/default_cover.png'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">43</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">zsStrike</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">《计算机网络》备忘录</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-02-12T12:35:53.000Z" title="发表于 2022-02-12 20:35:53">2022-02-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-05-16T07:41:46.255Z" title="更新于 2022-05-16 15:41:46">2022-05-16</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>25分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="《计算机网络》备忘录"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"><p>计算机网络相关知识，用作备忘录，以备查阅。</p>
<span id="more"></span>



<h2 id="01-网络协议的分层结构"><a href="#01-网络协议的分层结构" class="headerlink" title="01 网络协议的分层结构"></a>01 网络协议的分层结构</h2><p>OSI 分层模型：</p>
<ul>
<li>自上而下分为应用层，表示层，会话层，传输层，网络层，数据链路层，物理层七层</li>
<li>会话层，表示层，应用层称为资源子网(用来数据处理)，物理层，数据链路层，网络层称为通信子网(实现数据通信)，传输层是通信子网和资源子网的通信接口</li>
</ul>
<p>五层模型：</p>
<ul>
<li>应用层：进行应用数据处理，封装后交给传输层</li>
<li>传输层：对应用层数据进行封装，如 TCP 和 UDP 协议</li>
<li>网络层：对传输层数据封装，如 IP 协议，其会提供寻址能力</li>
<li>数据链路层：每台设备有唯一的 MAC 地址（通过 ARP 协议），为网络层提供链路级别传输的服务</li>
<li>物理层：提供二进制传输的服务</li>
</ul>
<p>网络包封装过程：</p>
<p><img src="/64002.webp" alt="64002"></p>
<h2 id="02-数据在网络中的封装"><a href="#02-数据在网络中的封装" class="headerlink" title="02 数据在网络中的封装"></a>02 数据在网络中的封装</h2><p>一个常见的问题：当在浏览器中输入网址后，到网页显示，其间发生的过程？</p>
<ol>
<li>浏览器对 URL 进行解析</li>
<li>查询 URL 中的服务器对应的 IP 地址，客户端对本地 DNS 服务器采用递归查询，本地 DNS 服务器对 DNS 根服务器进行迭代查询</li>
<li>浏览器通过调用 Socket 库，来委托操作系统的 TCP&#x2F;IP 协议栈进行相应的数据操作</li>
<li>TCP 封装：通过 MSS 分割应用层数据，添加对应包头，主要包含源端口号，目的端口号，序号，确认序列，状态位（SYN，ACK，RST，FIN），在传输数据之前，需要先进行三次握手</li>
<li>IP 封装：主要包含源 IP 地址和目标 IP 地址，如果服务器存在多个网卡，需要通过网络和子网掩码来确认对应的 IP</li>
<li>MAC 封装：两点间的传输，主要包含发送方 MAC 地址和接收方目标 MAC 地址，协议类型主要有 IP 协议和 ARP 协议，ARP 协议会在以太网中用广播的方式来询问 IP 地址对应的 MAC 地址</li>
<li>网卡：出口，将数字信息转换为电信号，网卡驱动从 IP 模块获取到包之后，会将其复制到网卡内的缓存区中，接着会其开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列</li>
<li>交换机：二层网络设备，其端口不包含 MAC 地址，根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口</li>
<li>路由器：三层网络设备，路由器的各个端口具有 MAC 地址和 IP 地址，每次传输都需要修改 MAC 地址，但是源 IP 和目标 IP 始终是不会变动</li>
<li>请求达到服务器端：解包，获取应用层数据，返回相应的响应报文</li>
<li>响应到达客户端：解包出来响应的 html 数据交给浏览器进行渲染</li>
<li>客户端断开连接：通过 TCP 四次握手（亦可通过 keep-alive 保持连接）</li>
</ol>
<p>网络包报文图解：</p>
<p><img src="/640-16446774877932.webp" alt="图片"></p>
<h2 id="03-ICMP-协议及其应用"><a href="#03-ICMP-协议及其应用" class="headerlink" title="03 ICMP 协议及其应用"></a>03 ICMP 协议及其应用</h2><p>ICMP 协议：</p>
<ul>
<li>功能：确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置</li>
<li>报文格式：被封装在 IP 包中，主要包含类型和代码，主要类型有<ul>
<li>查询报文类型：回送应答和回送请求</li>
<li>差错报文类型：目标不可达，原点抑制消息，重定向消息，超时消息（TTL）</li>
</ul>
</li>
</ul>
<p>ping 命令的过程：</p>
<ol>
<li>构建回送请求数据包，此时类型为 8，序号为 1，同时插入发送时间</li>
<li>系统根据回送请求数据包构建 IP 包，修改协议为 1，表示 ICMP </li>
<li>将 IP 包交给下层，将其发送到目标主机</li>
<li>目标主机获取到回送请求数据包，构建对应的回送响应数据包，此时类型为 0，委托 IP 层发送给源主机</li>
</ol>
<p>traceroute 命令实现（通过 UDP 或者 ICMP）：</p>
<ul>
<li>故意设置特殊的 TTL，来追踪去往目的地时沿途经过的路由器</li>
<li>故意设置不分片，从而确定路径的 MTU</li>
</ul>
<p>ICMP 报文格式：</p>
<p><img src="/640-16447226068886.webp" alt="图片"></p>
<h2 id="04-HTTP-协议的变迁"><a href="#04-HTTP-协议的变迁" class="headerlink" title="04 HTTP 协议的变迁"></a>04 HTTP 协议的变迁</h2><p>HTTP 状态码：</p>
<ul>
<li>1xx：表示目前是协议的中间状态</li>
<li>2xx：成功，如 200，204，206</li>
<li>3xx：重定向，如 301，302，304</li>
<li>4xx：客户端错误，如 400，403，404</li>
<li>5xx：服务器错误，如 500，501，502，503</li>
</ul>
<p>HTTP 首部常见字段：Host，Content-Length，Connection，Content-Type，Content-Encoding</p>
<p>HTTP 特性：</p>
<ul>
<li>优点：报文格式简单，灵活和易于扩展，应用广泛和跨平台</li>
<li>不足：无状态双刃剑，明文传输不安全</li>
</ul>
<p>HTTPS：在原来的 TCP 和 HTTP 层之间加入了 SSL&#x2F;TLS 层，保证信息的加密传输</p>
<ul>
<li>混合加密保证了信息的机密性</li>
<li>摘要算法用来实现完整性</li>
<li>通过数字证书的方式保证服务器公钥的身份，解决冒充的风险</li>
</ul>
<p>HTTP 协议的演变：</p>
<ul>
<li>HTTP&#x2F;1.1：增加了长连接，支持管道网络传输，但是可能会存在队头阻塞问题</li>
<li>HTTP&#x2F;2：基于 HTTPS，保障安全性，头部压缩，二进制格式，支持数据流，多路复用，服务器推送</li>
<li>HTTP&#x2F;3：在 HTTP&#x2F;2.0 多路复用时，如果某个请求发生丢包，会触发 TCP 重传机制，而阻塞其他请求，HTTP&#x2F;3 基于 UDP，上层的 QUIC 协议可以实现类似 TCP 的可靠性传输，同时 QUIC 合并了 TCP 三次握手和 TLS 四次握手</li>
</ul>
<p>HTTP 各种协议栈：</p>
<p><img src="/640-164475121315412.webp" alt="图片"></p>
<h2 id="05-TLS-协议"><a href="#05-TLS-协议" class="headerlink" title="05 TLS 协议"></a>05 TLS 协议</h2><p>TLS 握手过程：</p>
<ul>
<li>Client Hello：发送支持的密码套件列表，以及生成的随机数等</li>
<li>Server Hello 消息给出随机数和选择的密码套件，Server Certificate 消息给出服务器的数字证书，Server Hello Done 结束</li>
<li>客户端进行证书验证，可能涉及到证书链，验证证书通过检查证书的签名</li>
<li>Change Cipher Key Exchange 消息加密 pre-master，将其发送到服务器；Change Cipher Spec 消息用于告诉服务端开始使用加密方式发送消息；Finishd 消息会把之前的消息做个摘要，防止篡改</li>
<li>服务器发送 Change Cipher Spec 和 Encrypted Handshake Message 消息给客户端</li>
</ul>
<p>RSA 算法：用于进行密钥协商，但是不支持前向保密，一旦服务端的私钥泄漏了，<strong>过去</strong>被第三方截获的所有 TLS 通讯密文都会被破解，可以改用 ECDHE 密钥协商算法。</p>
<p>HTTPS 建立连接的过程：</p>
<p><img src="/640-16447502279268.webp" alt="图片"></p>
<h2 id="06-HTTPS-优化"><a href="#06-HTTPS-优化" class="headerlink" title="06 HTTPS 优化"></a>06 HTTPS 优化</h2><p>HTTPS 性能损耗：</p>
<ul>
<li>TLS 握手过程最长需要 2 RTT</li>
<li>后续的应用数据需要使用对称加密密钥进行加密和解密</li>
</ul>
<p>HTTPS 优化方式：</p>
<ul>
<li>硬件优化：选择支持 AES-NI 特性的 CPU，否则可以将对称加密算法改为 ChaCha20</li>
<li>软件升级：升级 Linux 内核，更新 OpenSSL</li>
<li>协议优化：<ul>
<li>TLS 1.2 可以使用 ECDHE 密钥交换算法，客户端可以在 TLS 协议的第 3 次握手后，第 4 次握手前，可以发送加密的应用数据，减少了 1 个 RTT</li>
<li>TLS 1.3 把 Hello 和公钥交换这两个消息合并成了一个消息，于是这样就减少到只需 1 RTT 就能完成 TLS 握手</li>
</ul>
</li>
<li>证书优化：<ul>
<li>选择椭圆曲线（ECDSA）证书，相同安全强度下，其密钥长度比 RSA 短的多</li>
<li>证书验证协议优化：CRL，OCSP（CA 服务器成为瓶颈），OCSP Stapling</li>
</ul>
</li>
<li>会话复用：不仅不具备前向安全，而且有重放攻击的风险，设置合理的过期时间<ul>
<li>Session ID：双方缓存会话密钥，并用唯一的 Session ID 标识，服务器的内存压力增大</li>
<li>Session Ticket：服务器会加密会话密钥作为 Ticket 发给客户端，交给客户端缓存该 Ticket</li>
<li>Pre-shared Key：TLS 1.3 使用，原理和 Ticket 类似，只不过在重连时，客户端会把 Ticket 和 HTTP 请求一同发送给服务端</li>
</ul>
</li>
</ul>
<p>ECDHE 交换算法：</p>
<p><img src="/640-16448221212513.webp" alt="图片"></p>
<h2 id="07-密钥交换算法"><a href="#07-密钥交换算法" class="headerlink" title="07 密钥交换算法"></a>07 密钥交换算法</h2><p>HTTPS 中常见的密钥交换算法有 RSA 和 ECDHE 算法，由于前者不支持前向安全性，ECDHE 被广泛使用。</p>
<p>ECDHE 算法发展：</p>
<ul>
<li>DH 算法：基于离散对数</li>
<li>DHE 算法：让双方的私钥在每次密钥交换通信时，都是随机生成的、临时的</li>
<li>ECDHE 算法：在 DHE 算法的基础上利用了 ECC 椭圆曲线，用更少的计算量计算出公钥和会话密钥</li>
</ul>
<p>DH 算法过程：</p>
<p><img src="/64003.webp" alt="64003"></p>
<h2 id="08-HTTP-x2F-1-1-优化"><a href="#08-HTTP-x2F-1-1-优化" class="headerlink" title="08 HTTP&#x2F;1.1 优化"></a>08 HTTP&#x2F;1.1 优化</h2><p>HTTP&#x2F;1.1 优化方式：</p>
<ul>
<li>减少 TCP 握手时间：使用 KeepAlive 将短连接修改为长连接，注意其不同于 TCP 的 keepalive</li>
<li>避免发送 HTTP 请求：使用缓存</li>
<li>减少 HTTP 请求次数：减少重定向请求次数，合并多个请求，懒加载</li>
<li>减少 HTTP 响应的数据大小：无损压缩和有损压缩</li>
</ul>
<p>客户端缓存过程：</p>
<p><img src="/640-16448245304655.webp" alt="图片"></p>
<h2 id="09-HTTP-x2F-2-带来的优化"><a href="#09-HTTP-x2F-2-带来的优化" class="headerlink" title="09 HTTP&#x2F;2 带来的优化"></a>09 HTTP&#x2F;2 带来的优化</h2><p>HTTP&#x2F;1.1 面临的问题：</p>
<ul>
<li>HTTP 头部巨大并且存在重复</li>
<li>并发连接有限，如 Chrome 浏览器最大并发数是 6</li>
<li>HTTP&#x2F;1.x 协议导致的队头阻塞问题</li>
<li>不支持服务器推送</li>
</ul>
<p>HTTP&#x2F;2 向下兼容 HTTP&#x2F;1.1，其特性：</p>
<ul>
<li>头部压缩 HPACK 算法：由静态字典，动态字典和 Huffman 编码构成</li>
<li>二进制帧：对于一条 HTTP 响应，划分成了两个帧（HEADER + DATA）来传输</li>
<li>并发传输：多个 Stream 复用一条 TCP 连接，达到并发的效果，不同 Stream 的帧是可以乱序发送的，同一 Stream 内部的帧必须是严格有序的，还可以设置优先级</li>
<li>服务器主动推送：如在客户端请求 index.html 的时候主动推送 index.js 和 index.css</li>
<li>TCP 协议导致的队头阻塞问题：TCP 需要等待前面的字节到达内核后才能将其传输到应用层</li>
</ul>
<p>Stream 示意图：</p>
<p><img src="/640-16448331732297.webp" alt="图片"></p>
<h2 id="10-HTTP-x2F-3-带来的优化"><a href="#10-HTTP-x2F-3-带来的优化" class="headerlink" title="10 HTTP&#x2F;3 带来的优化"></a>10 HTTP&#x2F;3 带来的优化</h2><p>HTTP&#x2F;2 缺点：</p>
<ul>
<li>TCP 队头阻塞</li>
<li>TCP 和 TLS 的握手时延需要 3 RTT</li>
<li>网络迁移后需要重新进行连接</li>
</ul>
<p>HTTP&#x2F;3 使用 UDP 传输协议，在应用层使用 QUIC 保证其可靠：</p>
<ul>
<li>无 TCP 产生的队头阻塞，如果 QUIC 连接中某个数据包丢失了，其只会阻塞该流，其他流不受影响</li>
<li>更快的连接建立：QUIC 可以在 1 个 RTT 内同时完成建立连接与密钥协商，在第二次连接时，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果</li>
<li>只需要通过连接 ID 来标记通信的两个端点，不涉及 IP 地址，切换网络后（弱网环境）不需要重新连接</li>
<li>HTTP&#x2F;3 的 QPACK 通过两个特殊的单向流来同步双方的动态表，解决 HTTP&#x2F;2 的 HPACK 队头阻塞问题</li>
<li>QUIC 使用 UDP 传输，大部分路由器在网络繁忙的时候，会丢 UDP 包</li>
</ul>
<p>HTTP 不同协议的连接示意图：</p>
<p><img src="/640-16448408675899.webp" alt="图片"></p>
<h2 id="11-TCP-三次握手和四次挥手"><a href="#11-TCP-三次握手和四次挥手" class="headerlink" title="11 TCP 三次握手和四次挥手"></a>11 TCP 三次握手和四次挥手</h2><p>TCP 基本认识：</p>
<ul>
<li>TCP 是面向连接的、可靠的、基于字节流的传输层通信协议</li>
<li>头部格式包含：序列号，确认应答号，控制位</li>
<li>最大 TCP 连接数：客户端 IP 数 × 客户端端口数，但实际受限于文件描述符和内存大小</li>
<li>TCP 和 UDP 区别：连接，服务对象，可靠性，拥塞控制和流量控制，首部开销，应用场景</li>
</ul>
<p>TCP 三次握手：</p>
<ul>
<li><p>第三次握手是可以携带数据的，前两次握手是不可以携带数据的</p>
</li>
<li><p>为什么是三次握手：</p>
<ul>
<li>三次握手才可以阻止历史重复连接的初始化（防止服务器一收到 SYN 包直接进入 ESTABLISH 状态，消耗资源）</li>
<li>三次握手才可以同步双方的初始序列号</li>
<li>三次握手才可以避免资源浪费</li>
</ul>
</li>
<li><p>IP 层也会进行分片，为啥 TCP 层还需要 MSS：如果只交给 IP 层分片，发生丢包后，TCP 会重传整个 TCP 报文，而如果 TCP 采用 MSS，则只需要传送 MSS 单位的数据即可</p>
</li>
<li><p>SYN 攻击：通过伪造 SYN 报文，占满服务器的 SYN 接收队列，使得服务器不能正常工作</p>
</li>
</ul>
<p>TCP 四次挥手：</p>
<ul>
<li>需要四次挥手：客户端发送 FIN 报文表示客户端不再发送数据给服务器，服务器接收到 FIN 报文后，可能还需要发送响应数据给客户端，因此服务器 ACK 和 FIN 报文不会一起发送给客户端</li>
<li>为什么需要 TIME_WAIT 状态：<ul>
<li>防止 TCP 重连后接收到旧的数据包</li>
<li>保证最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭</li>
</ul>
</li>
<li>为什么 TIME_WAIT 需要 2MSL：保证最后的 ACK 可能丢失时，依旧能够收到服务器的 FIN 报文</li>
<li>TIME_WAIT 过高的危害：消耗内存资源和端口资源</li>
</ul>
<p>TCP 三次握手过程图：</p>
<p><img src="/640-164489841945413.webp" alt="图片"></p>
<p>TCP 四次挥手过程图：</p>
<p><img src="/640-164490010690415.webp" alt="图片"></p>
<h2 id="12-TCP-相关机制"><a href="#12-TCP-相关机制" class="headerlink" title="12 TCP 相关机制"></a>12 TCP 相关机制</h2><p>TCP 重传机制：</p>
<ul>
<li>超时重传：超时重传时间 RTO 的值应该略大于报文往返  RTT 的值，发生重传时，会加倍 RTO</li>
<li>快速重传：收到三次相同 ACK，触发重传</li>
<li>SACK：在 TCP 头部选项中加入 SACK，告知发送方哪些数据已经被接收</li>
<li>D-SACK：使用了 SACK 来告诉发送方有哪些数据被重复接收了，让发送方知道是丢数据包还是 ACK 包</li>
</ul>
<p>滑动窗口：</p>
<ul>
<li>改善 TCP 每发送一个数据包就进行一次确认应答的性能</li>
<li>接收窗口和发送窗口构成，接收窗口的大小是约等于发送窗口的大小</li>
</ul>
<p>流量控制：</p>
<ul>
<li>通过滑动窗口，可以让发送方根据接收方的实际接收能力控制发送的数据量</li>
<li>如果窗口大小为 0 时，就会阻止发送方给接收方传递数据，只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器，如果超时，就会发送窗口探测报文</li>
<li>糊涂窗口综合症：通过 TCP 发送少量数据给接收方，可以<ul>
<li>让接收方不通告小窗口给发送方</li>
<li>让发送方避免发送小数据</li>
</ul>
</li>
</ul>
<p>拥塞控制：</p>
<ul>
<li>防止网络出现拥堵时，发送方还继续发送大量数据包，导致网络更加拥堵</li>
<li>引入拥塞窗口后，发送窗口的值为 swnd &#x3D; min(cwnd, rwnd)，只要网络没有拥塞，cwnd 就会增大，反之，cwnd 就会减少</li>
<li>一旦发生了重传，就会认为网络出现了拥塞，拥塞算法如下<ul>
<li>慢启动：cwnd 呈现指数型增长</li>
<li>拥塞避免：一旦到达慢启动门限，cwnd 呈现线性增长</li>
<li>拥塞发生：<ul>
<li>超时重传：ssthresh &#x3D; cwnd &#x2F; 2，cwnd &#x3D; 1，也就是进入慢启动</li>
<li>快速重传 + 快速恢复：ssthresh &#x3D; cwnd &#x2F; 2，cwnd &#x3D; ssthresh + 3，进入拥塞避免</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>发送窗口和接收窗口：</p>
<p><img src="/640-164491229805017.webp" alt="图片"></p>
<p><img src="/640-164491230518019.webp" alt="图片"></p>
<h2 id="13-IP-层"><a href="#13-IP-层" class="headerlink" title="13 IP 层"></a>13 IP 层</h2><p>IP 层工作在第三层，实现两个主机间的通信，而 MAC 作用是实现两个直连设备之间的通信</p>
<p>IP 地址的分类：</p>
<ul>
<li>传统分类：A，B，C，D，E，但存在同一网络下没有地址层次，不能很好的与现实网络匹配等问题</li>
<li>CIDR：表示为 <code>a.b.c.d/x</code> ，前 x 位表示网络号，后 32 - x 位表示主机号，类似子网掩码，还可以对其进行子网划分</li>
</ul>
<p>IP 分片和重组：当 IP 数据包超过 MTU 大小时，IP 数据包就会被分片，但是由于分片后的 IP 数据包只能在目标主机进行重组，一旦丢失某个分片数据，则需要重传整个 IP 数据包，为此引入了 TCP 的 MSS</p>
<p>IPv4 和 IPv6 区别：</p>
<ul>
<li>地址位数及其表示方法</li>
<li>IPv6 即使没有 DHCP 服务器也可以自动分配 IP 地址</li>
<li>IPv6 包头固定长度为 40 字节，提高了传输性能</li>
<li>IPv6 能够防止线路窃听，提高了安全性</li>
</ul>
<p>IP 相关协议：DNS，ARP，RARP，DHCP，NAT，NAPT，ICMP</p>
<h2 id="14-TCP-抓包分析"><a href="#14-TCP-抓包分析" class="headerlink" title="14 TCP 抓包分析"></a>14 TCP 抓包分析</h2><p>抓包工具：tcpdump 和 wireshark</p>
<p>抓包到的 TCP 挥手是三次：当服务器受到客户端的 FIN 时，如果之后没有数据发送给客户端，就会合并 ACK 和 FIN 报文</p>
<p>TCP 三次握手异常：</p>
<ul>
<li>第一次的 SYN 包丢失：RTO 指数增长，tcp_syn_retries</li>
<li>第二次的 SYN + ACK 包丢失：RTO 指数增长，tcp_syn_retries，tcp_synack_retries</li>
<li>第三次的 ACK 丢包：RTO 指数增长，tcp_synack_retries，tcp_retries2</li>
</ul>
<p>TCP 四次挥手异常：</p>
<ul>
<li>第一次的 FIN 包丢失：RTO 指数增长，tcp_orphan_retries</li>
<li>第三次的 FIN 包丢失：RTO 指数增长，tcp_orphan_retries</li>
<li>第一次或者第四次 ACK 包丢失：不会重传 ACK 包，而是重传 FIN 包</li>
</ul>
<p>TCP Fast Open：第一次 TCP 连接时给客户端发送 Cookie，接下来的连接就可以直接带上 Cookie 和对应的 HTTP 请求，达到 1 RTT 的效果</p>
<p>TCP 延迟确认和 Nagle 算法：用于增加整个报文的有效负载</p>
<ul>
<li>延迟确认：没有携带数据的 ACK，其有效负载也是很低的，通过等待一定时间再发送 ACK 给客户端</li>
<li>Nagle 算法：没有已发送未确认报文时，立刻发送数据；存在未确认报文时，直到没有已发送未确认报文或数据长度达到 MSS 大小时，再发送数据</li>
<li>不能同时使用延迟确认和 Nagle 算法，其会造成额外的时延</li>
</ul>
<p>TCP Fast Open：</p>
<p><img src="/640-164497487449921.webp" alt="图片"></p>
<h2 id="15-TCP-半连接队列和全连接队列"><a href="#15-TCP-半连接队列和全连接队列" class="headerlink" title="15 TCP 半连接队列和全连接队列"></a>15 TCP 半连接队列和全连接队列</h2><p>当服务端受到客户端的 SYN 请求后，内核会把该连接存储到半连接队列；当服务端受到客户端的 ACK 响应后，内核会把连接从半连接队列移除，然后创建新的完全的连接，将其放入全连接队列中</p>
<p>TCP 全连接队列溢出：</p>
<ul>
<li>后续请求报文或者被丢弃，或者被发送 RST 报文，由 tcp_abort_on_overflow 控制</li>
<li>增大全连接队列：全连接队列最大值 min(somaxconn, backlog)</li>
</ul>
<p>TCP 半连接队列溢出：</p>
<ul>
<li>半连接队列最大值 max_qlen_log &#x3D; min(min(somaxconn, backlog), max_syn_backlog) × 2</li>
<li>当开启了 tcp_syncookies 功能后可以在不使用 SYN 半连接队列的情况下建立连接</li>
<li>防御 syn 攻击：开启 tcp_syncookies 功能，增大半连接队列，减少 SYN + ACK 重传次数</li>
</ul>
<p>TCP 连接队列示意图：</p>
<p><img src="/640-164499076874023.webp" alt="图片"></p>
<h2 id="16-TCP-调优"><a href="#16-TCP-调优" class="headerlink" title="16 TCP 调优"></a>16 TCP 调优</h2><p>TCP 三次握手：</p>
<ul>
<li>调整 SYN 报文的重传次数：tcp_syn_retries</li>
<li>调整 SYN 半连接队列长度：tcp_max_syn_backlog，somaxconn，backlog</li>
<li>调整 SYN + ACK 报文的重传次数：tcp_synack_retries</li>
<li>调整 accept 队列长度：somaxconn，backlog</li>
<li>绕过三次握手：tcp_fastopen</li>
</ul>
<p>TCP 四次挥手：</p>
<ul>
<li>调整 FIN 报文重传次数：tcp_orphan_retries</li>
<li>调整 FIN_WAIT2 状态的时间：tcp_fin_timeout</li>
<li>调整孤儿连接上限：tcp_max_orphans</li>
<li>复用 time_wait 状态的连接：tcp_tw_reuse</li>
</ul>
<p>TCP 传输优化：</p>
<ul>
<li>扩大窗口：tcp_window_scaling</li>
<li>调整发送缓冲区范围：tcp_wmem</li>
<li>调整接收缓冲区范围：tcp_rmem</li>
<li>调整内存范围：tcp_mem</li>
</ul>
<h2 id="17-TCP-和-UDP"><a href="#17-TCP-和-UDP" class="headerlink" title="17 TCP 和 UDP"></a>17 TCP 和 UDP</h2><p>TCP 是面向字节流的协议，而 UDP 是面向报文的协议：</p>
<ul>
<li><p>面向报文指的是每个 UDP 报文就是一个用户消息的边界，在收到 UDP 报文后，可以读取并解析，因此需要应用层控制报文的大小</p>
</li>
<li><p>面向字节流则是指操作系统可能会对用户的消息进行拆分，使其满足 MSS 等限制，这样可能会造成粘包问题，可以以下方式解决：</p>
<ul>
<li><p>固定长度的消息</p>
</li>
<li><p>特殊字符作为边界</p>
</li>
<li><p>自定义消息结构</p>
</li>
</ul>
</li>
</ul>
<h2 id="18-TCP-和-HTTP-的-keepalive-机制"><a href="#18-TCP-和-HTTP-的-keepalive-机制" class="headerlink" title="18 TCP 和 HTTP 的 keepalive 机制"></a>18 TCP 和 HTTP 的 keepalive 机制</h2><p>HTTP 的 Keep-Alive 也叫 HTTP 长连接，其目的为减少 HTTP 短连接中每次请求都需要 TCP 三次握手和四次挥手的开销，同时也使得 HTTP&#x2F;1.1 流水线技术得以实现</p>
<p>TCP 的 Keepalive 也叫 TCP 保活机制，当 TCP 层长时间没有数据交互时，内核为了确保该连接是否还有效，就会发送探测报文，来检测对方是否还在线，然后来决定是否要关闭该连接</p>
<h2 id="19-TCP-异常"><a href="#19-TCP-异常" class="headerlink" title="19 TCP 异常"></a>19 TCP 异常</h2><p>假设：客户端和服务端通过 TCP 连接，并且没有开启 TCP 的 keepalive，在下列情况下：</p>
<ul>
<li>一直没有数据交互下：<ul>
<li>主机崩溃（掉电）：服务器对此是无法感知的，服务端的 TCP 连接将会一直处于 ESTABLISHED 连接状态，直到重启</li>
<li>进程崩溃（kill）：操作系统会自动发送 FIN 报文，进行四次挥手</li>
</ul>
</li>
<li>存在数据交互下，客户端主机崩溃：<ul>
<li>迅速重启：在收到服务器重传的报文时，会回复 RST 报文，重置 TCP 连接</li>
<li>不重启：服务器端一直进行报文重传，由 tcp_retries2 控制</li>
</ul>
</li>
</ul>
<p>如果客户端在 TIME_WAIT 状态下，收到来自服务端的数据包时，客户端的内核会发送该数据包的 ACK 确认报文（防止服务端重传），然后直接丢掉该数据包，具体过程如下：</p>
<p><img src="/640-16450783041384.webp" alt="图片"></p>
<p>如果客户端在 FIN_WAIT_2 状态下，FIN 报文和服务器响应的数据乱序了，也就是如果客户端收到乱序的 FIN 报文，那么就被会加入到乱序队列，并不会进入到 TIME_WAIT 状态，等 FIN 之前的数据都被接收后自动进入 TIME_WAIT 状态：</p>
<p><img src="/640-16450791546536.webp" alt="图片"></p>
<h2 id="20-常用的网络命令"><a href="#20-常用的网络命令" class="headerlink" title="20 常用的网络命令"></a>20 常用的网络命令</h2><p>远程登陆和传输：ssh，scp</p>
<p>查看本地网络状态：ifconfig，netstat</p>
<p>网络测试：ping，telnet</p>
<p>DNS 查询：host，dig</p>
<p>HTTP 请求：curl</p>
<h2 id="21-信息风险与防范措施"><a href="#21-信息风险与防范措施" class="headerlink" title="21 信息风险与防范措施"></a>21 信息风险与防范措施</h2><p>HTTP 明文传输，并且没有身份认证，所以存在以下风险：</p>
<ul>
<li>窃听风险：中间人可以截获报文查看其中信息，通过对称加密防范</li>
<li>篡改风险：中间人可以截获报文并且修改后发送给收件人，可以用哈希函数来计算出内容的哈希值</li>
<li>冒充风险：虽然使用哈希可以保证报文不被篡改，但是不能防止中间人重新构建一个报文发送给收件人的情况。为此可以采用非对称加密方法，通过私钥加密，公钥解密的方式，来确认消息的身份，注意此时加密的是内容的哈希值。通过 CA 保证信任链的真实可靠，防止中间人伪造公私钥</li>
</ul>
<p>数字证书签发和验证流程：</p>
<p><img src="/64001.webp" alt="64001"></p>
<h2 id="22-TLS-协议"><a href="#22-TLS-协议" class="headerlink" title="22 TLS 协议"></a>22 TLS 协议</h2><p>TLS 1.2 和 TLS 1.3 协议的区别：</p>
<ul>
<li>TLS1.2 需要四次握手，握手完成后才能发送数据；TLS 1.3 只需要两次握手过程</li>
<li>TLS 1.3 会话恢复时握手过程只需要 0 RTT，通过 pre_shared_key 实现</li>
</ul>
<p>通常，不管 TLS 握手次数如何，都得先经过 TCP 三次握手后才能进行；但是如果在 TCP Fast Open + TLS 1.3 情况下，在第二次以后的通信过程中，TLS 和 TCP 的握手过程是可以同时进行的</p>
<p>TLS 会话恢复：</p>
<p><img src="/64006.webp" alt="64006"></p>
<h2 id="23-CDN"><a href="#23-CDN" class="headerlink" title="23 CDN"></a>23 CDN</h2><p>CDN 用于解决远距离导致的网络访问延迟问题，通常用于加速一些静态资源，CDN 加速策略分为：</p>
<ul>
<li>推模式：当用户就近访问的 CDN 节点没有缓存请求的数据时，CDN 会主动从源服务器下载数据，并更新到这个 CDN 节点的缓存中</li>
<li>拉模式：也称为 CDN 预热，通过 CDN 服务提供的 API 接口，把需要预热的资源地址和需要预热的区域等信息提交上去</li>
</ul>
<p>CDN 通过 GSLB 服务器找到最近的 CDN 服务器：</p>
<p><img src="/64007.webp" alt="64007"></p>
<h2 id="24-第三方-TCP-工具断开连接的实现"><a href="#24-第三方-TCP-工具断开连接的实现" class="headerlink" title="24 第三方 TCP 工具断开连接的实现"></a>24 第三方 TCP 工具断开连接的实现</h2><p>如果一个已经建立的 TCP 连接，客户端中途宕机了，而服务端此时也没有数据要发送，一直处于 establish 状态，客户端恢复后，向服务端建立连接，此时服务端会怎么处理：</p>
<ul>
<li>客户端的 SYN 报文里的端口号与历史连接不相同：服务器重新建立新连接，原来的 TCP 连接：<ul>
<li>如果服务端发送了数据包给客户端，此时客户的内核就会回 RST 报文，服务端收到后就会释放连接</li>
<li>如果服务端一直没有发送数据包给客户端，在超过一段时间后， TCP 保活机制就会启动</li>
</ul>
</li>
<li>客户端的 SYN 报文里的端口号与历史连接相同：由于序列号不同，服务器会回复一个携带了正确序列号和确认号的 ACK 报文，客户端收到该报文后，发现不是自己期待的，就会发回 RST 报文，此时，服务端释放该连接</li>
</ul>
<p>可以使用命令 <code>killcx &lt;IP地址&gt;:&lt;端口号&gt;</code> 来关闭某个特定的 TCP 连接，其利用 Challenge ACK 中的有效信息，构造出两个 RST 报文，用于终止双方的 TCP 连接：</p>
<p><img src="/64008.webp" alt="64008"></p>
<h2 id="25-序列化和反序列化"><a href="#25-序列化和反序列化" class="headerlink" title="25 序列化和反序列化"></a>25 序列化和反序列化</h2><p>序列化和反序列化：在应用程序中，对象如果想要通过网络传输到另一端上或者保存在文件中，就需要将其序列化，而如果想要将序列化的对象读取，则需要反序列化</p>
<p>常见的序列化：</p>
<ul>
<li>JDK 原生序列化：缺陷是不能跨语言</li>
<li>JSON：进行序列化的额外空间开销比较大</li>
<li>ProtoBuf：由 Google 出品的，是一种轻便、高效的结构化数据存储格式，可以用于结构化数据序列化，并且支持跨平台，使用前需要定义 IDL（Interface description language）文件</li>
</ul>
<h2 id="26-SYN-报文何时被丢弃"><a href="#26-SYN-报文何时被丢弃" class="headerlink" title="26 SYN 报文何时被丢弃"></a>26 SYN 报文何时被丢弃</h2><p>SYN 报文丢失的两种场景：</p>
<ul>
<li>开启 tcp_tw_recycle 参数，并且在 NAT 环境下，造成 SYN 报文被丢弃</li>
<li>accpet 队列满了，造成 SYN 报文被丢弃</li>
</ul>
<p>对于主动关闭方，最后一个状态是 TIME_WAIT，其作用是：</p>
<ul>
<li>防止具有相同四元组的旧数据包被收到，也就是防止历史连接中的数据，被后面的连接接受</li>
<li>保证被动关闭连接的一方能被正确的关闭，即保证最后的 ACK 能让被动关闭方接收</li>
</ul>
<p>Linux 提供了两个参数快速回收处于 TIME_WAIT 的状态：</p>
<ul>
<li>net.ipv4.tcp_tw_reuse：客户端在调用 connect() 函数时，内核会随机找一个 time_wait 状态超过 1 秒的连接给新的连接复用，所以该选项只适用于连接发起方</li>
<li>net.ipv4.tcp_tw_recycle：允许处于 TIME_WAIT 状态的连接被快速回收</li>
</ul>
<p>对于服务器来说，如果同时开启了 recycle 和 timestamps 选项，则会开启  per-host 的 PAWS 机制。</p>
<ul>
<li>PAWS 机制：开启了 tcp_timestamps 之后，该机制自动启动，它的作用是防止 TCP 包中的序列号发生绕回，因为 seq 位数 32，可能存在一次连接中，两次 seq 是相同值。PAWS 机制如果发现收到的数据包中时间戳不是递增的，则表示该数据包是过期的，就会直接丢弃这个数据包</li>
<li>per-host 的 PAWS 机制：per-host 是对<code>对端 IP</code> 做 PAWS 检查，而非对<code>IP + 端口</code>四元组做 PAWS 检查</li>
</ul>
<p>SYN 包丢失场景一：当客户端 A 通过 NAT 网关和服务器建立 TCP 连接，然后服务器主动关闭并且快速回收 TIME-WAIT 状态的连接后，客户端 B 也通过 NAT 网关和服务器建立 TCP 连接，注意客户端 A  和 客户端 B 因为经过相同的 NAT 网关，所以是用相同的 IP 地址与服务端建立 TCP 连接，如果客户端 B 的 timestamp 比 客户端 A 的 timestamp 小，那么由于服务端的 per-host 的 PAWS 机制的作用，服务端就会丢弃客户端主机 B 发来的 SYN 包。</p>
<p>SYN 包丢失场景二：在服务端并发处理大量请求时，如果 TCP accpet 队列过小，或者应用程序调用 accept() 不及时，就会造成 accpet 队列满了 ，这时后续的连接就会被丢弃，这样就会出现服务端请求数量上不去的现象。</p>
<p>Socket 连接过程：</p>
<p><img src="/64010.webp" alt="64010"></p>
<h2 id="27-TIME-WAIT-状态的作用"><a href="#27-TIME-WAIT-状态的作用" class="headerlink" title="27 TIME_WAIT 状态的作用"></a>27 TIME_WAIT 状态的作用</h2><p>TIME_WAIT 状态的作用：</p>
<ul>
<li><p>防止历史连接中的数据，被后面相同四元组的连接错误的接收</p>
<p><img src="/64011.webp" alt="64011"></p>
</li>
<li><p>保证「被动关闭连接」的一方，能被正确的关闭</p>
<p><img src="/64012.webp" alt="64012"></p>
</li>
</ul>
<p>tcp_tw_reuse 参数用于客户端 在调用 connect() 函数时，内核会随机找一个 TIME_WAIT 状态超过 1 秒的连接给新的连接复用，所以该选项只适用于连接发起方。</p>
<p>为了使得上述参数起作用，需要开启 tcp_timestamps 参数，起作用有：</p>
<ul>
<li>便于精确计算 RTT </li>
<li>能防止序列号回绕（PAWS）</li>
</ul>
<p>为什么 tcp_tw_reuse  默认是关闭的：</p>
<ul>
<li><p>开启 tcp_tw_reuse 后，对于 RST 报文，即使其时间戳过期了，只要 RST 报文的序列号在对方的接收窗口内，也是能被接受的</p>
<blockquote>
<p>RFC：建议 RST 段不携带时间戳，并且无论其时间戳如何，RST 段都是可接受的。老的重复的 RST 段应该是极不可能的，并且它们的清除功能应优先于时间戳</p>
</blockquote>
<p><img src="/64013.webp" alt="64013"></p>
</li>
<li><p>如果第四次挥手的 ACK 报文丢失了，有可能会导致被动关闭连接的一方不能被正常的关闭</p>
<p><img src="/64014.webp" alt="64014"></p>
</li>
</ul>
<p>tcp_tw_reuse 的作用是让客户端快速复用处于 TIME_WAIT 状态的端口，相当于跳过了 TIME_WAIT 状态，这可能会出现这样的两个问题：</p>
<ul>
<li>历史 RST 报文可能会终止后面相同四元组的连接，因为 PAWS 即使发现 RST 是过期的，也不会丢弃</li>
<li>如果第四次挥手的 ACK 报文丢失了，有可能被动关闭连接的一方不能被正常的关闭</li>
</ul>
<h2 id="28-DNS-解析"><a href="#28-DNS-解析" class="headerlink" title="28 DNS 解析"></a>28 DNS 解析</h2><p>客户端对本地 DNS 服务器采用递归查询，本地 DNS 服务器对 DNS 根服务器进行迭代查询。</p>
<p>IPv4 的根域名服务器一共有 13 个，其是由 UDP 包大小决定的，RFC 规定，DNS 报文要求被控制在 512 字节之内。</p>
<p>DNS 主根域名服务器在美国，如果美国终止 cn 后缀的解析，并不会导致中国国内的网络瘫痪，因为中国已经有很多台镜像的根域名服务器，可以让其继续支持 cn 后缀的解析，但是国外用户可能就无法访问 cn 后缀的网站了。</p>
<h2 id="29-异常情况下的-TCP-连接"><a href="#29-异常情况下的-TCP-连接" class="headerlink" title="29 异常情况下的 TCP 连接"></a>29 异常情况下的 TCP 连接</h2><p>在 Linux 中，TCP 连接信息会放在一个 struct socket 结构体中，拔掉网线并不会影响 TCP 的连接状态。如果之后进行下面不同操作：</p>
<ul>
<li>拔掉网线，有数据传输：客户端会触发超时重传，如果一直没有将网线插回去，达到重传次数上限或者最大超时时间时，就会停止重传，内核断开 TCP 连接</li>
<li>拔掉网线，无数据传输：如果没有开启 TCP keepalive 机制，该连接一直保存；如果开启了 TCP keepalive 机制，等待一段时间后，就会发送 TCP 保活报文到服务端，如果一直没有网络，最终达到最大保活探测次数后，TCP 会报告该连接已经死亡</li>
</ul>
<p>客户端宕机：跟拔掉网线是一样无法被服务端的感知的，所以如果在没有数据传输，并且没有开启 TCP keepalive 机制时，服务端的 TCP 连接将会一直处于 ESTABLISHED 连接状态，直到服务端重启进程</p>
<p>客户端杀死进程：杀死客户端的进程后，客户端的内核就会向服务端发送 FIN 报文，与服务端四次挥手</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://blog.zsstrike.xyz">zsStrike</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://blog.zsstrike.xyz/2022/02/12/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E5%A4%87%E5%BF%98%E5%BD%95/">http://blog.zsstrike.xyz/2022/02/12/《计算机网络》备忘录/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://blog.zsstrike.xyz" target="_blank">zsStrike</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></div><div class="post_share"><div class="social-share" data-image="/assets/default_cover.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/assets/avatar.jpg" onerror="this.onerror=null;this.src='/assets/default_cover.png'" alt="avatar"/></div><div class="author-info__name">zsStrike</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">43</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zsStrike"><i class="fab fa-github"></i><span>Github</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#01-%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">01 网络协议的分层结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02-%E6%95%B0%E6%8D%AE%E5%9C%A8%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%B0%81%E8%A3%85"><span class="toc-number">2.</span> <span class="toc-text">02 数据在网络中的封装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#03-ICMP-%E5%8D%8F%E8%AE%AE%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">03 ICMP 协议及其应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#04-HTTP-%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8F%98%E8%BF%81"><span class="toc-number">4.</span> <span class="toc-text">04 HTTP 协议的变迁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#05-TLS-%E5%8D%8F%E8%AE%AE"><span class="toc-number">5.</span> <span class="toc-text">05 TLS 协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#06-HTTPS-%E4%BC%98%E5%8C%96"><span class="toc-number">6.</span> <span class="toc-text">06 HTTPS 优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#07-%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">7.</span> <span class="toc-text">07 密钥交换算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#08-HTTP-x2F-1-1-%E4%BC%98%E5%8C%96"><span class="toc-number">8.</span> <span class="toc-text">08 HTTP&#x2F;1.1 优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#09-HTTP-x2F-2-%E5%B8%A6%E6%9D%A5%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">9.</span> <span class="toc-text">09 HTTP&#x2F;2 带来的优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-HTTP-x2F-3-%E5%B8%A6%E6%9D%A5%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">10.</span> <span class="toc-text">10 HTTP&#x2F;3 带来的优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">11.</span> <span class="toc-text">11 TCP 三次握手和四次挥手</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-TCP-%E7%9B%B8%E5%85%B3%E6%9C%BA%E5%88%B6"><span class="toc-number">12.</span> <span class="toc-text">12 TCP 相关机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-IP-%E5%B1%82"><span class="toc-number">13.</span> <span class="toc-text">13 IP 层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-TCP-%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90"><span class="toc-number">14.</span> <span class="toc-text">14 TCP 抓包分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-TCP-%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E5%92%8C%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97"><span class="toc-number">15.</span> <span class="toc-text">15 TCP 半连接队列和全连接队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-TCP-%E8%B0%83%E4%BC%98"><span class="toc-number">16.</span> <span class="toc-text">16 TCP 调优</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-TCP-%E5%92%8C-UDP"><span class="toc-number">17.</span> <span class="toc-text">17 TCP 和 UDP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-TCP-%E5%92%8C-HTTP-%E7%9A%84-keepalive-%E6%9C%BA%E5%88%B6"><span class="toc-number">18.</span> <span class="toc-text">18 TCP 和 HTTP 的 keepalive 机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-TCP-%E5%BC%82%E5%B8%B8"><span class="toc-number">19.</span> <span class="toc-text">19 TCP 异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4"><span class="toc-number">20.</span> <span class="toc-text">20 常用的网络命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E4%BF%A1%E6%81%AF%E9%A3%8E%E9%99%A9%E4%B8%8E%E9%98%B2%E8%8C%83%E6%8E%AA%E6%96%BD"><span class="toc-number">21.</span> <span class="toc-text">21 信息风险与防范措施</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-TLS-%E5%8D%8F%E8%AE%AE"><span class="toc-number">22.</span> <span class="toc-text">22 TLS 协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-CDN"><span class="toc-number">23.</span> <span class="toc-text">23 CDN</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-%E7%AC%AC%E4%B8%89%E6%96%B9-TCP-%E5%B7%A5%E5%85%B7%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">24.</span> <span class="toc-text">24 第三方 TCP 工具断开连接的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">25.</span> <span class="toc-text">25 序列化和反序列化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-SYN-%E6%8A%A5%E6%96%87%E4%BD%95%E6%97%B6%E8%A2%AB%E4%B8%A2%E5%BC%83"><span class="toc-number">26.</span> <span class="toc-text">26 SYN 报文何时被丢弃</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-TIME-WAIT-%E7%8A%B6%E6%80%81%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">27.</span> <span class="toc-text">27 TIME_WAIT 状态的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-DNS-%E8%A7%A3%E6%9E%90"><span class="toc-number">28.</span> <span class="toc-text">28 DNS 解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84-TCP-%E8%BF%9E%E6%8E%A5"><span class="toc-number">29.</span> <span class="toc-text">29 异常情况下的 TCP 连接</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2017 - 2022 By zsStrike</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5/instantpage.min.js" type="module"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>