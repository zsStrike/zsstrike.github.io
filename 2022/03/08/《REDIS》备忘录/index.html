<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;zh-HK&quot;,&quot;zh-TW&quot;,&quot;default&quot;]" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>《REDIS》备忘录 | zsStrike</title><meta name="keywords" content="Redis"><meta name="author" content="zsStrike"><meta name="copyright" content="zsStrike"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本文用于记录 Redis 相关知识，以备查阅。">
<meta property="og:type" content="article">
<meta property="og:title" content="《REDIS》备忘录">
<meta property="og:url" content="http://blog.zsstrike.tech/2022/03/08/%E3%80%8AREDIS%E3%80%8B%E5%A4%87%E5%BF%98%E5%BD%95/index.html">
<meta property="og:site_name" content="zsStrike">
<meta property="og:description" content="本文用于记录 Redis 相关知识，以备查阅。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://blog.zsstrike.tech/assets/default_cover.png">
<meta property="article:published_time" content="2022-03-08T02:04:29.000Z">
<meta property="article:modified_time" content="2022-12-06T05:25:37.333Z">
<meta property="article:author" content="zsStrike">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://blog.zsstrike.tech/assets/default_cover.png"><link rel="shortcut icon" href="/assets/avatar.jpg"><link rel="canonical" href="http://blog.zsstrike.tech/2022/03/08/%E3%80%8AREDIS%E3%80%8B%E5%A4%87%E5%BF%98%E5%BD%95/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":5000,"languages":{"author":"作者: zsStrike","link":"链接: ","source":"来源: zsStrike","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '《REDIS》备忘录',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-12-06 13:25:37'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/assets/avatar.jpg" onerror="onerror=null;src='/assets/default_cover.png'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">50</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/index"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">zsStrike</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/index"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">《REDIS》备忘录</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-08T02:04:29.000Z" title="发表于 2022-03-08 10:04:29">2022-03-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-06T05:25:37.333Z" title="更新于 2022-12-06 13:25:37">2022-12-06</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>22分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="《REDIS》备忘录"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><p>本文用于记录 Redis 相关知识，以备查阅。</p>
<span id="more"></span>



<h2 id="01-Redis-数据结构"><a href="#01-Redis-数据结构" class="headerlink" title="01 Redis 数据结构"></a>01 Redis 数据结构</h2><p>Redis 数据类型是其值的数据类型，这些数据类型会使用相应的数据结构来实现，对应关系如下：</p>
<p><img src="/2022/03/08/%E3%80%8AREDIS%E3%80%8B%E5%A4%87%E5%BF%98%E5%BD%95/6400101.png" alt="6400101"></p>
<p>Redis 本身使用了哈希表来保存所有的数据，哈希桶存放的是键值对的指针，指针的类型都通过对象结构来解码，里面包含了 type，encoding，ptr 等信息，整个映射过程如下：</p>
<p><img src="/2022/03/08/%E3%80%8AREDIS%E3%80%8B%E5%A4%87%E5%BF%98%E5%BD%95/640-16467067064022.png" alt="图片"></p>
<p>SDS：保存为 (len, alloc, flags, buf[]) ，其有以下优点：常量时间复杂度内获取字符串长度，二进制安全，不会发生缓冲区溢出，节省内存空间，另外为了节省空间，使用了 <code>__attribute__ ((packed))</code></p>
<p>双向链表：实现为具有头节点的双向链表，能够快速获取到头尾节点和链表长度等信息，但是存在无法很好利用 CPU 缓存和在数据较小时，内存开销较大的问题</p>
<p>压缩列表：内存紧凑型的数据结构，占用一块连续的内存空间，不仅可以利用 CPU 缓存，而且会针对不同长度的数据，进行相应编码，节省内存空间。但是其不能保存过多的元素，并且新增或者修改元素时，可能引发连锁更新的问题（通过 prevlen 长度改变造成）</p>
<img src="image-20221201154727512.png" alt="image-20221201154727512" style="zoom:67%;" />

<p>哈希表：内部保存有两张哈希表，采用链式哈希来解决哈希冲突，当 Redis 中的数据过大时，此时就会进行 rehash，其采用的是渐进式 rehash，即在 rehash 进行期间，每次哈希表元素进行查找或者删除操作时，Redis 除了会执行对应的操作之外，还会顺序将哈希表 1 中 rehashidx 位置上对应的桶中的 key-value 迁移到哈希表 2 上，rehash 触发条件和负载因子有关</p>
<p>整数集合：包含有 (enconding, length, contents) 信息，当 Set 对象只有整数，并且元素数量不大时，就会采用该数据结构，当新的数据远大于已存在的数据时，会执行升级操作，升级后不会降级</p>
<p>跳表：在 Redis 中只有 Zset 对象底层同时使用了两个数据结构，一个是哈希表，一个就是跳表。跳表实际上是多层的有序链表，通常越高层的跨度越大，跨度还有一个作用，就是计算该节点在跳表中的排位，Redis 实现中，为跳表增加了一个表头，其中有头尾节点，表长度和最大层数等信息，在新增节点的时候，会随机生成每个节点的层数，每层高度晋升机会是 0.25，得到的跳跃表更加扁平</p>
<p>quicklist：3.2 版本后，List 对象的底层数据结构。其实际上就是双向链表和压缩列表的组合，也就是每个链表节点数据元素是压缩列表，为了解决连锁更新的问题，其会控制每个链表节点中的压缩列表的大小或者元素个数（quicklist.fill 属性），也就是降低连锁更新带来的影响</p>
<p>listpack：quicklist 并没有完全解决连锁更新的影响，因为其还是用压缩列表来保存元素。listpack 的目的便是取代压缩列表，其最大不同就是每个内部节点不再包含前一个节点的长度，从而避免了连锁更新</p>
<p><img src="/2022/03/08/%E3%80%8AREDIS%E3%80%8B%E5%A4%87%E5%BF%98%E5%BD%95/640-16467127765796.png" alt="图片"></p>
<h2 id="02-Redis-数据类型"><a href="#02-Redis-数据类型" class="headerlink" title="02 Redis 数据类型"></a>02 Redis 数据类型</h2><p>Redis 对象中保存了 type 和 encoding 信息，前者表示对象的类型，后者表示使用的编码，通过 void* ptr 指向对应的真实数据类型，对象类型有：</p>
<ul>
<li>String 类型：<ul>
<li>编码：int，raw，embstr<ul>
<li>embstr 表示 redisObject 和 SDS 使用连续的内存空间，适用于字符串较短情况</li>
<li>raw 则将 SDS 和 redisObject 分离存储，使用内部 ptr 指向 SDS 对象</li>
</ul>
</li>
<li>常用指令：SET&#x2F;MSET，GET&#x2F;MGET，EXISTS，DEL，INCR&#x2F;INCRBY，EXPIRE&#x2F;TTL，SETNX</li>
<li>应用场景：<ul>
<li>缓存对象：缓存对象的 JSON 格式，或将 key 进行组合进行存储，如 <code>user:&lt;id&gt;:name</code> </li>
<li>常规计数：通过 INCR&#x2F;INCRBY</li>
<li>分布式锁：<code>SET lock_key unique_value NX PX 10000</code> ，unique_value 表示某个客户端独占，设置过期时间方式客户端崩溃而不能及时释放资源，解锁可以通过 DEL 命令实现，但是由于需要先判断该锁是否是自己的锁，为了保证原子性，需要使用 LUA 脚本</li>
</ul>
</li>
</ul>
</li>
<li>List 类型：<ul>
<li>编码：ziplist，linkedlist，quicklist（3.2 版本）</li>
<li>常用指令：LPUSH&#x2F;RPUSH，LPOP&#x2F;RPOP，LRANGE，BLPUSH&#x2F;BRPOP</li>
<li>应用场景：<ul>
<li>消息队列：消息队列三要素：<ul>
<li>消息保序：LPUSH + RPOP，LPUSH + BRPOP</li>
<li>重复消息处理：生产者自己实现全局唯一 ID</li>
<li>消息可靠性：使用 BRPOPLPUSH</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Hash 类型：<ul>
<li>编码：ziplist，hash，listpack（7.0 版本）</li>
<li>常用命令：HSET&#x2F;HGET，HDEL，HLEN，HGETALL，HINCRBY</li>
<li>应用场景：<ul>
<li>缓存对象：field + value 表示对应属性和值，key 则表示对象 id，不过通常使用 String + JSON 方式存储对象，如果对象某些属性变化频繁，可以使用 Hash 类型</li>
<li>购物车：以用户 id 为 key，商品 id 为 field，商品数量为 value，构成购物车的 3 个要素</li>
</ul>
</li>
</ul>
</li>
<li>Set 类型：<ul>
<li>编码：intset，hash</li>
<li>常用命令：SADD，SREM，SMEMBERS，SCARD，SISMEMBER，SINTER，SUNION，SDIFF</li>
<li>应用场景：<ul>
<li>点赞：按照文章 id 为 key，用户 id 为 value</li>
<li>共同关注：主要使用交集运算 SINTER，注意集合运算复杂度较高</li>
<li>抽奖活动：SRANDMEMBER，SPOP key count</li>
</ul>
</li>
</ul>
</li>
<li>Zset 类型：<ul>
<li>编码：ziplist，skiplist 和 hash，listpack（7.0 版本）</li>
<li>常用操作：ZADD，ZREM，ZSCORE，ZCARD，ZINCREBY，ZRANGE，ZRANGEBYSCORE，ZRANGEBYLEX，ZUNIONSTORE，ZINTERSTORE</li>
<li>应用场景：</li>
<li>排行榜，电话姓名排序</li>
</ul>
</li>
<li>BitMap 类型：<ul>
<li>实现：使用 String 类型实现，保存为二进制的字节数组</li>
<li>常用命令：SETBIT，GETBIT，BITCOUNT，BITOP，BITPOS</li>
<li>应用场景：签到统计，判断用户登陆状态，连续签到用户总数</li>
</ul>
</li>
<li>HyperLogLog 类型：<ul>
<li>目的：提供<strong>不精确</strong>的去重计数，误差率大约是 0.81%</li>
<li>常用命令：PFADD，PFCOUNT，PFMERGE</li>
<li>应用场景：百万级网页 UV 计数</li>
</ul>
</li>
<li>GEO 类型：<ul>
<li>目的：存储地理信息，并且对存储的信息操作，用于位置信息服务</li>
<li>实现：通过 GeoHash 编码将经纬度转换为 Zset 中元素的权重分数，关键机制在于对二维地图做区间划分和对区间进行编码</li>
<li>常用命令：GEOADD，GEOPOS，GEODIST，GEORADIUS</li>
<li>应用场景：嘀嘀打车</li>
</ul>
</li>
<li>Stream 类型：<ul>
<li>目的：专门为消息队列设计的数据类型，支持自动生成全局唯一 ID，并且以消费组消费数据</li>
<li>常用命令：XADD，XREAD，XREADGROUP，XPENDING&#x2F;XACK</li>
<li>消息队列：<ul>
<li>使用 XADD 会生成全局唯一 ID，如 <code>1654254953808-0</code>，通过 XREAD 实现消息读取，XREADGROUP 可以实现负载平衡</li>
<li>Stream 会使用 PENDING list 留存消费组里每个消费者读取的消息，直到收到对应的 XACK；消费者可以在重启后，使用 XPENDING 命令查看已经读取，但尚未确认的消息</li>
<li>问题：<ul>
<li>Redis 队列中间件（Stream）存在数据丢失的问题，主要原因在于 AOF 先执行命令，再写文件，其次主从复制再进行主从切换时，也存在数据丢失的问题</li>
<li>面对消息积压，内存资源紧张</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="03-AOF-日志"><a href="#03-AOF-日志" class="headerlink" title="03 AOF 日志"></a>03 AOF 日志</h2><p>AOF 日志：会保存写操作的命令到日志中，需要手动开启，里面保存的就是一条条用户的写命令</p>
<p>Redis 先执行写操作，完成写操作后才将该命令记录到 AOF 日志中，好处有：</p>
<ul>
<li>避免恢复时额外的检查开销</li>
<li>不会阻塞当前写操作命令的执行</li>
</ul>
<p>但是这样的话存在数据丢失的风险，这和 AOF 日志写回硬盘的时机有关（appendfsync）：</p>
<p><img src="/2022/03/08/%E3%80%8AREDIS%E3%80%8B%E5%A4%87%E5%BF%98%E5%BD%95/640-16467169176718.png" alt="图片"></p>
<blockquote>
<p>当调用 IO write 操作时，操作系统实际上会将数据放在内核缓冲区中，其会等待到一定的时机将数据写到硬盘上，或者通过用户的 fsync 的显式调用将其数据落盘</p>
</blockquote>
<p>AOF 重写机制：为了避免日志文件越来越大，对于设置相同的键，其会先创建一个新文件，然后扫描数据库中所有数据，逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志</p>
<p>AOF 后台重写：AOF 重写过程是通过后台子进程 bgrewriteaof 来完成的，好处有：</p>
<ul>
<li>子进程在 AOF 重写期间，主进程依旧可以响应用户命令</li>
<li>子进程带有主进程的数据副本，采用写时复制策略，减少内存开销</li>
<li>子进程修改共享内存数据时，直接复制，如果采用线程方式实现，则需要加锁</li>
</ul>
<p>为了记录重写过程中新到来的指令，存在一个 AOF 重写缓冲区，用于保存重写过程中的用户指令，该 AOF 缓冲区最终将会追加到新的 AOF 文件中，最终原子替换原来的 AOF 日志文件</p>
<blockquote>
<p>AOF 缓冲区用于保证即使是在子进程发生故障时仍然能够原来的 AOF 时正确的（按照 appendfsync 策略），AOF 重写缓冲区则保证了子进程在替换原来的 AOF 文件后，上面的文件内容能反映数据库当前的状态</p>
</blockquote>
<p><img src="/2022/03/08/%E3%80%8AREDIS%E3%80%8B%E5%A4%87%E5%BF%98%E5%BD%95/6400201.png" alt="6400201"></p>
<h2 id="04-RDB-快照"><a href="#04-RDB-快照" class="headerlink" title="04 RDB 快照"></a>04 RDB 快照</h2><p>RDB 快照记录的是某个时间点的内存数据，采用的是全量备份，提供了两个命令用来生成 RDB 文件，分别是 save 和 bgsave，前者会阻塞主线程，后者则创建了一个子进程专门生成 RDB 文件。</p>
<p>在执行 bgsave 的过程中，由于采用的是子进程处理，并且采用写时复制技术，当有新的命令到来时，此时原来的主进程会复制一块内存用于修改，而子进程读到的还是原来的数据。当系统宕机时，可能会丢失上次快照到现在时刻的数据。</p>
<p>混合持久化：RDB 数据恢复的速度快，但是存在大量数据丢失的问题，AOF 虽然解决了大量数据丢失的问题，但是在文件很大的时候，恢复过程缓慢，在 4.0 以后，可以通过配置 aof-use-rdb-preamble 使用混合持久化功能，其在 AOF 重写过程时，先将 RDB 数据写入 AOF 文件中，然后追加持久化过程中的 AOF 重写缓冲区里面的内容。</p>
<h2 id="05-主从复制"><a href="#05-主从复制" class="headerlink" title="05 主从复制"></a>05 主从复制</h2><p>主从复制可以避免单点故障，主服务可以进行读写操作，并且将写操作同步给从服务器，从服务器一般只读，并且执行主服务器传过来的写操作。</p>
<p>第一次同步过程：使用 replicaof（slaveof） 可以形成主从关系，采用的是全量复制，并且缓存生成 RDB 文件过程中的写操作到 replication buffer 中，之后将其发送给从服务器。</p>
<p><img src="/2022/03/08/%E3%80%8AREDIS%E3%80%8B%E5%A4%87%E5%BF%98%E5%BD%95/640-16468337303744.png" alt="图片"></p>
<p>分摊主服务器的压力：在第一次同步过程中，耗时过程主要在生成 RDB 文件和传输 RDB 文件，如果一个主服务器有很多从服务器，可能就会占用大量网络带宽。可以让其中一个服务器成为经理角色，其会同步写操作到其负责的从服务器上。</p>
<p>命令传播：主从服务器完成同步后，双方维护了一个 TCP 连接，该连接是长连接的，这是为了避免 TCP 连接和断开的性能开销。</p>
<p>增量复制：如果主从服务器网络发生断开，之后又重新连接，此时就会根据 <code>psync &#123;runid&#125; &#123;offset&#125;</code> 来进行增量复制。该实现过程通过环形缓冲区 repl_backlog_buffer 实现，主从服务器分别记录自己的 offset，从而实现增量同步，如果从服务器 offset 对应的数据已经被覆盖，则通过全量复制实现，可以通过 repl_backlog_size 设置该环形缓冲区大小。</p>
<blockquote>
<p>repl_backlog_buffer：为了从库断开之后，如何找到主从差异数据而设计的环形缓冲区，避免全量复制带来的性能开销</p>
<p>replication_buffer：从库相当于一个 client，和 client 通信所需的缓冲区，在主从复制中特称为 replication_buffer</p>
</blockquote>
<img src="640-16468351848676.png" alt="图片" style="zoom:50%;" />

<p>相关问题：</p>
<ul>
<li>主服务器不进行持久化时复制的安全性：若主服务器没有开启持久化，应该将其配置为避免自动重启，否则自动重启后主节点上只有一个空数据集，并且会复制到其它从节点上</li>
<li>为什么全量复制使用 RDB 而不是 AOF：RDB 文件内容相对较小，可以降低网络贷款的消耗，并且其还原数据速度快；另外如果使用 AOF 做全量复制，对文件刷盘策略需要仔细选择，选择不当比较影响性能</li>
<li>无磁盘复制模式：Redis 默认使用磁盘复制，但是其性能收到磁盘速度的限制，无磁盘复制模式即创建一个新进程直接 dump RDB 到 slave 的 socket，不经过硬盘，适用于网络较快的情况</li>
<li>从库的从库：对于主库来说，如果所有的从库直接连接到主库上，会给主库带来网络和磁盘上的消耗</li>
<li>数据过期问题：在主从复制中，从节点不会主动删除数据，而是通过主节点控制从节点来删除过期数据，在 Redis 3.2 后，从节点在读取数据的时候，增加了对数据是否过期的判断（惰性删除）</li>
</ul>
<h2 id="06-哨兵机制"><a href="#06-哨兵机制" class="headerlink" title="06 哨兵机制"></a>06 哨兵机制</h2><p>目的：提供主从节点自动进行故障转移的功能</p>
<p>哨兵节点：运行在特殊模式下的 Redis 服务器，组成哨兵集群，功能是监控，选主，通知</p>
<ul>
<li><p>监控：通过 ping 命令判断主从节点是否主观下线，一旦检测到主观下线，就会和其他的哨兵节点协商，达到 quorum 值便可确定其为客观下线</p>
<blockquote>
<p>不参与 leader 竞选的节点只有一次投票权，防止出现两个哨兵节点同时观测到主观下线，同时竞选成为 leader 的情况</p>
</blockquote>
</li>
<li><p>选主：</p>
<ul>
<li><p>在已下线主节点的所有从节点中选取一个从节点，将其当作新的主节点</p>
<ul>
<li><p>首先过滤掉网络状态不好的从节点，通过 down-after-millseconds 参数</p>
</li>
<li><p>按照优先级，复制进度，ID 号挑选从节点作为新的主节点</p>
</li>
<li><p>哨兵节点给新的主节点发送 SLAVEOF no one 命令，提高 INFO 命令发送频率</p>
<blockquote>
<p>INFO 命令用于获取该节点的角色信息，如其对应的从节点列表等</p>
</blockquote>
</li>
</ul>
</li>
<li><p>让已下线主节点的所有其他从节点修改复制目标，修改其为新的主节点</p>
<ul>
<li>哨兵节点给其他从节点发送 SLAVEOF 命令</li>
</ul>
</li>
<li><p>将新主节点的 IP 地址和信息，通过发布订阅机制通知给客户端</p>
<ul>
<li>客户端和哨兵建立连接后，就会订阅哨兵提供的频道，主从切换完成后，哨兵会向 <code>+switch-master</code> 频道发布新的主节点的 IP 和端口，用以通知客户端</li>
</ul>
</li>
<li><p>继续监视原来的旧主节点，但这个旧主节点重新上线时，修改其为从节点</p>
</li>
</ul>
</li>
</ul>
<p>哨兵集群：</p>
<ul>
<li>哨兵发现：通过命令 <code>sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt; </code> 进行哨兵配置，主节点中存在 <code>__sentinel__:hello</code> 频道，其他烧饼可以通过订阅该频道，用以发现其他哨兵并进行连接</li>
<li>从节点发现：通过 INFO 命令，主节点会返回所有的从节点信息</li>
</ul>
<p>主从集群脑裂现象：</p>
<ul>
<li>产生原因：由于网络问题，导致集群节点之间失去联系，主从节点间数据不同步，哨兵重新选举，产生两个主节点，等待网络恢复，旧主节点会降级为从节点，由于其与新节点进行同步复制的时候，会清空自己的缓冲区，导致之前客户端写入的数据被丢失</li>
<li>解决方案：当主节点发现从节点下线或者通信延迟过大时，那么禁止主节点进行写数据，直接把错误返回给客户端，以减少数据丢失，可以通过以下两个参数控制<ul>
<li>min-slaves-to-write x，主节点必须要有至少 x 个从节点连接，如果小于这个数，主节点会禁止写数据</li>
<li>min-slaves-max-lag x，主从数据复制和同步的延迟不能超过 x 秒，如果超过，主节点会禁止写数据</li>
</ul>
</li>
</ul>
<h2 id="07-切片集群模式"><a href="#07-切片集群模式" class="headerlink" title="07 切片集群模式"></a>07 切片集群模式</h2><p>目的：当 Redis 缓存数据量大到一台服务器无法缓存时，就需要使用切片集群模式，其将数据分布在不同的服务器上，以此降低系统对单节点的依赖，提高读写性能，实际上就是服务器 Sharding 技术</p>
<p>实现：采用哈希槽来处理数据和节点之间的映射关系，一个切片集群共有 16384 个哈希槽，通过 CRC16 和取模实现 key 到哈希槽的映射。哈希槽映射到具体的 Redis 节点：</p>
<ul>
<li>平均分配：Redis 集群平均分配哈希槽</li>
<li>手动分配：使用 cluster meet 手动建立节点之间的链接，组成集群，然后通过 cluster addslots 命令进行分配</li>
</ul>
<p>哈希槽和一致性哈希：</p>
<ul>
<li>哈希槽指的是先将用户数据划分到槽里面，然后将槽划分到不同服务器节点上，可以为不同硬件服务器自定义槽数目大小</li>
<li>一致性哈希则是将服务器节点划分在一个哈希环上，主要目的是减少新增节点导致的重新哈希的问题，容易产生数据倾斜问题，可以引入虚拟节点映射减少该问题</li>
</ul>
<h2 id="08-缓存雪崩、击穿、穿透"><a href="#08-缓存雪崩、击穿、穿透" class="headerlink" title="08 缓存雪崩、击穿、穿透"></a>08 缓存雪崩、击穿、穿透</h2><p>Redis 通常用做数据库的缓存中间件，用户先访问 Redis，如果命中直接返回，否则就查询数据库获得数据，并且更新缓存。</p>
<p>缓存雪崩：大量缓存数据在同一时间过期，或者 Redis 故障宕机时，此时大量的请求访问数据库，从而导致数据库压力骤增，严重的会造成数据库宕机，而造成系统崩溃。</p>
<ul>
<li><p>对于大量数据在同一时期过期的方案：</p>
<ul>
<li><p>均匀设置过期时间</p>
</li>
<li><p>双 key 策略：主 key 会设置过期时间，备 key 不会过期，如果主 key 失效，则返回备 key 数据，存在一定的数据延迟</p>
</li>
<li><p>后台更新缓存：后台线程定期更新缓存</p>
</li>
</ul>
</li>
<li><p>对于 Redis 宕机的情况：</p>
<ul>
<li><p>服务熔断或请求限流机制</p>
</li>
<li><p>构建 Redis 缓存高可用集群</p>
</li>
</ul>
</li>
</ul>
<p>缓存击穿：如果缓存中的某个热点数据过期，此时大量的请求访问该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮。</p>
<ul>
<li>互斥锁：保证同一时间内只有一个请求来构建缓存，同时设置超时时间防止死锁</li>
<li>永远不过期：后台线程会定时更新某个 key，存在脏数据的问题</li>
<li>缓存预热：业务上线前，提前加载数据到缓存中</li>
</ul>
<p>缓存穿透：当用户访问的数据，既不在缓存中，也不在数据库中，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，没办法构建缓存数据，来服务后续的请求，就到导致服务器的压力骤增。一般是业务误操作或者黑客恶意攻击，常见应对方案： </p>
<ul>
<li>非法请求的限制</li>
<li>缓存空值或者默认值</li>
<li>使用布隆过滤器快速判断数据是否存在</li>
</ul>
<p>布隆过滤器：使用位图和多个哈希函数快速判断数据是否存在数据库中，查询布隆过滤器说数据存在，并不一定证明数据库中存在这个数据，但是查询到数据不存在，则数据库中一定就不存在这个数据。</p>
<p><img src="/2022/03/08/%E3%80%8AREDIS%E3%80%8B%E5%A4%87%E5%BF%98%E5%BD%95/640-16468364802018.png" alt="图片"></p>
<h2 id="09-缓存的读写策略"><a href="#09-缓存的读写策略" class="headerlink" title="09 缓存的读写策略"></a>09 缓存的读写策略</h2><p>Write Update 策略局限：更新数据时，不论是先更新数据库，再更新缓存，还是先更新缓存，再更新数据库，都会产生不一致现象。</p>
<p><strong>Cache Aside 策略</strong>：在更新数据时先更新数据库，再删除缓存中的数据，在读取数据时，发现缓存中没了数据之后，从数据库中读取数据，并更新到缓存中。注意写操作时不能先删除缓存中的数据，再更新数据库，这在写读并发可能带来不一致现象。而在读写并发时，存在极小概率会产生不一致，原因是缓存的写入通常远远快于数据库的写入。</p>
<p>由于 Cache Aside 采用 Write Invalidate 策略，可能会对数据命中率产生影响，可以：</p>
<ul>
<li>更新数据时同样更新缓存，不过需要加分布式锁</li>
<li>更新数据时同样更新缓存，不过需要加过期时间，保证最终一致性</li>
</ul>
<p>Cache Aside 策略中如何保证先更新数据库，再删除缓存的操作都能成功：</p>
<ul>
<li><p>重试机制：引入消息队列，如果删除缓存的操作未成功，那就重试</p>
</li>
<li><p>订阅 MySQL binlog，再操作缓存：阿里巴巴开源 Canal 中间件的实现方式</p>
<p><img src="/2022/03/08/%E3%80%8AREDIS%E3%80%8B%E5%A4%87%E5%BF%98%E5%BD%95/640-164687727081511.png" alt="图片"></p>
</li>
</ul>
<p>Write&#x2F;Read Through 策略：核心原则是用户只与缓存打交道，由缓存和数据库通信，写入或者读取数据。当写操作未命中时，此时可以采用 Write Allocate 或者 No Write Allocate，一般采用 No Write Allocate，因为其具有更高的写入性能。</p>
<p><img src="/2022/03/08/%E3%80%8AREDIS%E3%80%8B%E5%A4%87%E5%BF%98%E5%BD%95/v2-48364465682303e2cdbffd8ade3c39d7_720w.jpg" alt="img"></p>
<p>Write Back 策略：Write Through 在未命中时，需要同步更新数据库，Write Back 写策略则只需标记缓存数据为脏数据之后，直接返回即可，在写未命中时，采用 Write Allocate 方式。读策略在未命中的情况下如果发现被置换的缓存块是脏块，则需要将其写入数据库。该策略不能被应用到我们常用的数据库和缓存的场景中，因为缓存一般是非持久化的，如果缓存机器掉电，脏块数据就会丢失。</p>
<h2 id="10-Redis-分布式锁"><a href="#10-Redis-分布式锁" class="headerlink" title="10 Redis 分布式锁"></a>10 Redis 分布式锁</h2><p>分布式锁特性：互斥性，安全性，对称性，可靠性</p>
<p>Redis 实现分布式锁：</p>
<ul>
<li>最简化版本：使用 <code>setnx key value</code> 和 <code>delete key</code> 实现加锁和释放锁</li>
<li>支持过期时间：防止获取了锁的服务挂掉而没有释放锁资源，使用 <code>set key value nx ex seconds</code></li>
<li>加上 owner：防止其他服务删除该服务已获取到的锁，可以设置不同的 value 表示不同的 owner</li>
<li>整合原子操作：加上 owner 后需要先检查，如果是自己的锁再释放，该过程不是原子性的，使用 Lua</li>
</ul>
<p>可靠性保证：</p>
<ul>
<li>容灾考虑：<ul>
<li>主从容灾：Redis 的哨兵模式可以灵活切换，但是存在同步时延的问题</li>
<li>多机部署：使用 Redis 中的 RedLock，只有超过半数同意才能算请求成功</li>
</ul>
</li>
<li>可靠性深究：由于分布式系统的三大困境（NPC），没有完全可靠的分布式锁，三大困境：<ul>
<li>网络延迟：获取到锁后，可能很快过期</li>
<li>进程暂停：发生 GC 导致锁超时，其他进程能够获取该锁，导致多个进程同时获取锁</li>
<li>时钟漂移：机器物理本身的误差</li>
</ul>
</li>
</ul>
<h2 id="11-Redis-为什么这么快"><a href="#11-Redis-为什么这么快" class="headerlink" title="11 Redis 为什么这么快"></a>11 Redis 为什么这么快</h2><p>Redis 处理快速的原因：</p>
<ul>
<li>基于内存实现，没有 IO 开销</li>
<li>高效的数据结构：如 SDS，快表，跳跃表</li>
<li>合理的数据编码：如 String 对象存储数字的时候，采用 int 类型编码，非数字采用 SDS 编码</li>
<li>合适的线程模型：采用 Reactor 单线程模型，省去了上下文切换的开销</li>
</ul>
<p><img src="/2022/03/08/%E3%80%8AREDIS%E3%80%8B%E5%A4%87%E5%BF%98%E5%BD%95/640-164689071388213.png" alt="图片"></p>
<h2 id="12-过期删除策略与内存淘汰策略"><a href="#12-过期删除策略与内存淘汰策略" class="headerlink" title="12 过期删除策略与内存淘汰策略"></a>12 过期删除策略与内存淘汰策略</h2><p>过期删除策略：对数据库中已经过期的键值对进行删除，存在过期字典用于快速判断</p>
<ul>
<li>过期时间设置：EXPIRE&#x2F;SETEX，TTL，PERSIST</li>
<li>过期策略：<ul>
<li>定时删除：每次设置了 key 的过期时间时，同时创建一个定时事件用于删除</li>
<li>惰性删除：不主动删除过期键，每次访问 key 的时候，才检查 key 是否过期</li>
<li>定期删除策略：每隔一段时间随机从数据库中取出一定数量的 key 进行检查</li>
</ul>
</li>
<li>Redis 过期删除策略：<ul>
<li>惰性删除：通过函数 expireIfNeeded 实现</li>
<li>定期删除：每隔一段时间从过期字典中挑选一定的数据检查其是否过期，如果过期率大于 25% 并且此次运行时间小于 25ms，则继续上述操作</li>
</ul>
</li>
</ul>
<p>内存淘汰策略：当运行内存达到最大值时，需要淘汰某些 key 用于缓存新的键值对</p>
<ul>
<li>不进行数据淘汰：noeviction，返回错误通知客户端</li>
<li>进行数据淘汰：<ul>
<li>在设置了过期时间的数据中进行淘汰：<ul>
<li>volatile-random</li>
<li>volatile-ttl</li>
<li>volatile-lru</li>
<li>volatile-lfu</li>
</ul>
</li>
<li>在所有数据范围内淘汰：<ul>
<li>allkeys-random</li>
<li>allkeys-lru</li>
<li>allkeys-lfu</li>
</ul>
</li>
</ul>
</li>
<li>LRU 算法：每个键维护了上一次的访问时间，每次通过随机采样的方式来进行淘汰</li>
<li>LFU 算法：每个键维护了一个该数据的访问次数和上一次衰减时间，其会随着时间衰减</li>
</ul>
<h2 id="12-Redis-不同版本特性"><a href="#12-Redis-不同版本特性" class="headerlink" title="12 Redis 不同版本特性"></a>12 Redis 不同版本特性</h2><p>Redis 4.0 新增特性：</p>
<ul>
<li>PSYNC 2.0：可以在更多种的情况下使用增量复制，减少全量复制的开销，如星形复制和链式复制场景</li>
<li>缓存逐出策略优化：新增了 LFU 逐出策略，同时优化其他策略</li>
<li>Lazy Free：添加了 UNLINK 命令，用于异步执行删除操作，防止阻塞主线程，另外可以配置 <code>lazyfree-lazy-server-del yes</code> 改变 DEL 默认行为</li>
<li>交换数据库：新增 SWAPDB 命令</li>
<li>混合持久化：通过 <code>aof-use-rdb-preamble</code> 开启</li>
<li>内存命令：新增 MEMORY 命令，查看 Redis 的内存使用情况</li>
<li>兼容 NAT 和 Docker：新增了配置项用于支持不工作在 host 模式下的 docker 环境中</li>
</ul>
<p>Redis 5.0 新增特性：</p>
<ul>
<li>Stream 类型：用于消息队列，支持自动生成消息 ID 和消费组消费</li>
<li>集群管理器更改：集群管理功能移植到 redis-cli 里面</li>
<li>Lua 改进：将 Lua 脚本更好地传播到 replicas&#x2F;AOF</li>
<li>RDB 格式改进：增加存储 key 的逐出策略，向下兼容</li>
<li>动态 Hz：平衡 CPU 利用率和响应能力</li>
<li>ZPOPMIN 和 ZPOPMAX 命令</li>
<li>CLIENT UNBLOCK 命令，用于终端其他客户端的阻塞命令，如 BRPOP</li>
</ul>
<p>Redis 6.0：</p>
<ul>
<li>多线程 IO：多线程用于处理网络 IO，用户命令的执行还是在单个线程之中，通过 <code>io-threads-do-reads yes</code> 和 <code>io-threads</code> 控制</li>
<li>SSL 支持</li>
<li>ACL 支持：防止任何用户都能执行 FLUSHDB 这样的危险操作，之前的版本通过 RENAME 方式改变危险操作的名称，现在支持权限控制表了</li>
<li>RESP 3：服务端和客户端通信的协议</li>
<li>客户端缓存：将经常使用的数据 cache 到客户端本地</li>
<li>集群代理：Redis 集群本身是去中心化的，修改某个节点的地址需要同步通知客户端，较为复杂，引入 Proxy，通过代理和集群本身通信，支持自动化路由以及多线程等多种特性</li>
</ul>
<h2 id="13-Redis-运维监控"><a href="#13-Redis-运维监控" class="headerlink" title="13 Redis 运维监控"></a>13 Redis 运维监控</h2><p>Redis 自身状态及命令：</p>
<ul>
<li>INFO 命令：查看所有状态信息</li>
<li>MONITOR 命令：监视服务端收到的命令</li>
<li>LATENCY 命令：监控延迟</li>
</ul>
<p>Redis 可视化监测工具：</p>
<ul>
<li>可视化工具：redis-stat，RedisLive，redmon</li>
<li>可视化监测工具：基于 redis_exporter，prometheus，grafana</li>
</ul>
<h2 id="14-Redis-性能调优"><a href="#14-Redis-性能调优" class="headerlink" title="14 Redis 性能调优"></a>14 Redis 性能调优</h2><p>Redis 变慢的原因以及解决方案：</p>
<ul>
<li>使用复杂度过高的命令：减少服务端合并操作或者减少值的元素个数大小</li>
<li>操作 bigkey：使用 UNLINK 命令或者开启 lazy-free</li>
<li>集中过期：过期时间增加随机性</li>
<li>内存达到上限：减少存储 bigkey，更换淘汰策略</li>
<li>fork 耗时严重：优化 RDB 备份策略，调大 repl-backlog-size，降低全量同步的概率</li>
<li>开启内存大页：会造成写放大的情况，关闭内存大页</li>
<li>开启 AOF：合理配置 AOF 刷盘时机，配置 no-appendfsync-on-rewrite</li>
<li>使用 SWAP：增加内存</li>
<li>碎片整理：关闭碎片自动整理，合理配置碎片整理参数</li>
<li>网络带宽过载：排查流量大的实例，选用更好的网络设备</li>
<li>频繁短链接：使用长连接连接服务器</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://blog.zsstrike.tech">zsStrike</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://blog.zsstrike.tech/2022/03/08/%E3%80%8AREDIS%E3%80%8B%E5%A4%87%E5%BF%98%E5%BD%95/">http://blog.zsstrike.tech/2022/03/08/《REDIS》备忘录/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://blog.zsstrike.tech" target="_blank">zsStrike</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Redis/">Redis</a></div><div class="post_share"><div class="social-share" data-image="/assets/default_cover.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/assets/avatar.jpg" onerror="this.onerror=null;this.src='/assets/default_cover.png'" alt="avatar"/></div><div class="author-info__name">zsStrike</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">50</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zsStrike"><i class="fab fa-github"></i><span>Github</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#01-Redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">01 Redis 数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02-Redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">02 Redis 数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#03-AOF-%E6%97%A5%E5%BF%97"><span class="toc-number">3.</span> <span class="toc-text">03 AOF 日志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#04-RDB-%E5%BF%AB%E7%85%A7"><span class="toc-number">4.</span> <span class="toc-text">04 RDB 快照</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#05-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">5.</span> <span class="toc-text">05 主从复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#06-%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6"><span class="toc-number">6.</span> <span class="toc-text">06 哨兵机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#07-%E5%88%87%E7%89%87%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.</span> <span class="toc-text">07 切片集群模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#08-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E7%A9%BF%E9%80%8F"><span class="toc-number">8.</span> <span class="toc-text">08 缓存雪崩、击穿、穿透</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#09-%E7%BC%93%E5%AD%98%E7%9A%84%E8%AF%BB%E5%86%99%E7%AD%96%E7%95%A5"><span class="toc-number">9.</span> <span class="toc-text">09 缓存的读写策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-Redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">10.</span> <span class="toc-text">10 Redis 分布式锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-Redis-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB"><span class="toc-number">11.</span> <span class="toc-text">11 Redis 为什么这么快</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E4%B8%8E%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-number">12.</span> <span class="toc-text">12 过期删除策略与内存淘汰策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-Redis-%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7"><span class="toc-number">13.</span> <span class="toc-text">12 Redis 不同版本特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-Redis-%E8%BF%90%E7%BB%B4%E7%9B%91%E6%8E%A7"><span class="toc-number">14.</span> <span class="toc-text">13 Redis 运维监控</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-Redis-%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98"><span class="toc-number">15.</span> <span class="toc-text">14 Redis 性能调优</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2017 - 2023 By zsStrike</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>