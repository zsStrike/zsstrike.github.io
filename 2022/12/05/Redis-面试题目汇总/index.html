<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;zh-HK&quot;,&quot;zh-TW&quot;,&quot;default&quot;]" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Redis 面试题目汇总 | zsStrike</title><meta name="keywords" content="Redis"><meta name="author" content="zsStrike"><meta name="copyright" content="zsStrike"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本文整理了 Redis 的相关问题，以便更深入掌握 Redis。">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis 面试题目汇总">
<meta property="og:url" content="http://blog.zsstrike.tech/2022/12/05/Redis-%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/index.html">
<meta property="og:site_name" content="zsStrike">
<meta property="og:description" content="本文整理了 Redis 的相关问题，以便更深入掌握 Redis。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://blog.zsstrike.tech/assets/default_cover.png">
<meta property="article:published_time" content="2022-12-05T08:09:03.000Z">
<meta property="article:modified_time" content="2023-02-24T09:33:59.804Z">
<meta property="article:author" content="zsStrike">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://blog.zsstrike.tech/assets/default_cover.png"><link rel="shortcut icon" href="/assets/avatar.jpg"><link rel="canonical" href="http://blog.zsstrike.tech/2022/12/05/Redis-%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":5000,"languages":{"author":"作者: zsStrike","link":"链接: ","source":"来源: zsStrike","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis 面试题目汇总',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2023-02-24 17:33:59'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/assets/avatar.jpg" onerror="onerror=null;src='/assets/default_cover.png'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">52</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/index"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">zsStrike</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/index"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Redis 面试题目汇总</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-12-05T08:09:03.000Z" title="发表于 2022-12-05 16:09:03">2022-12-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-02-24T09:33:59.804Z" title="更新于 2023-02-24 17:33:59">2023-02-24</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>37分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Redis 面试题目汇总"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><p>本文整理了 Redis 的相关问题，以便更深入掌握 Redis。</p>
<span id="more"></span>



<ol>
<li><p>Redis 有哪些数据结构？</p>
<p>简单动态字符串，双向链表，压缩链表，哈希表，整数集合，跳表，在 3.2 版本后新增 quicklist，用于降低双向链表空间浪费的现象，在 5.0 版本后新增 listpack，用于解决级联更新问题。</p>
</li>
<li><p>Redis 数据结构中的哈希表内部实际存在几张哈希表，为什么？</p>
<p>实际存在两张哈希表，用于实现渐进式 rehash 策略。</p>
</li>
<li><p>Redis 数据结构中的整数集合何时会升级，是否能够降级？</p>
<p>在存储元素的字节长度大于编码长度时，就会执行升级操作，升级后不能降级。</p>
</li>
<li><p>Redis 数据结构中的跳表实现原理？</p>
<p>跳表实际上是多层的有序链表，通常越高层的跨度越大，在每个节点维护一个 32 层的指针，通过 0.25 的概率来决定上层是否存在指针，使得得到的跳表更加扁平。</p>
</li>
<li><p>为什么需要 quicklist 和 listpack？</p>
<p>前者为了解决双向链表空间浪费问题，后者则主要为了解决压缩链表级联更新的问题。</p>
</li>
<li><p>Redis 是如何存储某个数据库中的数据的？</p>
<p>本身使用了哈希表来保存所有的数据，哈希桶存放的是键值对的指针，指针的类型都通过对象结构来解码，但是键的指针只能是 String 对象。</p>
</li>
<li><p>Redis 是如何解析 RedisObject 的？</p>
<p>其中包含了 type 和 encoding 两个属性，前者表示对象的类型，后者表示使用的编码，通过 void* ptr 指向对应的真实数据类型。</p>
</li>
<li><p>Redis 存在哪些数据类型？</p>
<p>主要存在五种数据类型：String，List，Hash，Set，Zset。还存在四种复合类型：BitMap，Hyperloglog，GEO，Stream 类型。</p>
</li>
<li><p>Hyperloglog 类型的主要目的是？</p>
<p>提供不精确的去重计数，误差率大约是 0.81%，可以节省大量的内存。</p>
</li>
<li><p>Redis 如何实现分布式锁？</p>
<p><code>SET lock_key unique_value NX PX 10000</code>，设置过期时间是为了防止 Redis 崩溃而不能及时释放资源，解锁可以通过 DEL 命令实现，但是需要先检查是否是自己的锁，可以配合 LUA 脚本。</p>
</li>
<li><p>如何使用 List 实现消息队列，为什么还推出 Stream？List 实现消息队列：LPUSH&#x2F;RBPOP，但是存在的问题是需要生产者实现消息唯一 ID，不是很方便；Stream 则是专门为消息队列设计的数据类型，支持自动生成全局唯一 ID，并且以消费组消费数据</p>
</li>
<li><p>Stream 如何保证消息确实被消费了？</p>
<p>Stream 会使用 PENDING LIST 留存消费组每个消费者读取的消息，直到收到对应的 ACK，消费者在重启后，可以通过 XPENDING 来查看已读取，但尚未确认的消息，从而保证消息确实被消费了。</p>
</li>
<li><p>Stream 存在哪些问题？</p>
<p>存在数据丢失问题，主要原因在 AOF 先执行命令，后写日志；主从复制在进行主从切换时，也会发生数据丢失问题；面对消息挤压，内存资源紧张。</p>
</li>
<li><p>RDB 快照存储格式以及生成方式？</p>
<p>RDB 快照采用二进制文件保存，因此其恢复速度很快；生成方式主要有两种，save 和 bgsave，前者会阻塞主线程，一般使用 bgsave。由于采用的是子进程处理，并且采用写时复制技术，当有新的命令到来时，此时原来的主进程会复制一块内存用于修改，而子进程读到的还是原来的数据。</p>
</li>
<li><p>AOF 日志存储格式？</p>
<p>里面保存的是一条条用户的指令，在恢复时，只需要按顺序执行即可。</p>
</li>
<li><p>为什么 Redis 选择先执行写操作，再将其写入 AOF 日志？</p>
<p>避免恢复时的检查开销，不会阻塞当前写操作命令的执行。</p>
</li>
<li><p>AOF 日志落盘策略（appendfsync）有哪些？</p>
<p>Always，Everysec 和 No。Always 能够最大程度保证数据完成性，但是存在性能上的问题。</p>
</li>
<li><p>AOF 日志时，当 appendfsync 为 always，是否可能会丢失数据？</p>
<p>仍然可能会，在 Redis 的事件循环中，是先将对应的 AOF 数据写入 aof_buf 中，在结束本次循环前，会执行 flushAppendOnlyFile 函数，因此，若出现故障停机，可能会丢失一个事件循环中所产生的命令数据。</p>
</li>
<li><p>如何解决 AOF 文件随时间流逝越来越大的问题？</p>
<p>AOF 重写机制，对于相同键的写命令，可以将它们合并为一个命令，达到节省内存的作用。一般通过 bgrewriteaof 后台子进程完成。</p>
</li>
<li><p>AOF 重写机制（bgrewriteaof）是怎样的？</p>
<p>为了记录重写过程中新到来的指令，存在一个 AOF 重写缓冲区，用于保存重写过程中的用户指令，该 AOF 缓冲区最终将会追加到新的 AOF 文件中，最终原子替换原来的 AOF 日志文件。</p>
</li>
<li><p>AOF 缓冲区和 AOF 重写缓冲区的异同点？</p>
<p>都是暂时保存日志的缓冲区；前者目的在于保证 AOF 日志的完整性，通过 appendfsync 策略控制，后者则是为了保证重写 AOF 日志替换现有 AOF 日志后没有数据丢失。</p>
</li>
<li><p>混合持久化存在的意义？</p>
<p>RDB 快照恢复速度快，但是发生崩溃时会丢失上次 RDB 快照至今的命令数据；AOF 方式虽然解决了大量数据丢失的问题，但是在文件很大时，恢复过程缓慢。因此，可以考虑使用混合持久化，只需要配置 <code>aof-use-rdb-preamble</code> 参数即可。</p>
</li>
<li><p>主从复制的意义是什么？</p>
<p>避免单点故障，为 Redis 服务提供高可用所必须的操作。</p>
</li>
<li><p>主从复制的具体过程？</p>
<p>主要分为三个阶段：</p>
<ul>
<li>从服务器执行 replicaof 命令，其会向主服务器建立连接，协商得到 runID 和 offset 等信息</li>
<li>主服务器在后台执行 bgsave 命令，在此过程中执行的写命令会被记录到 replication buffer 中，生成完成 RDB 后，通过网络传送到从服务器从服务器接收到 RDB 文件后载入即可</li>
<li>主服务器将 replication buffer 中的新到来的写操作发送给从服务器，从服务器执行其即可</li>
</ul>
</li>
<li><p>增量复制发生的时机，以及对应的原理？</p>
<p>增量复制发生在主从服务器网络发生断开，之后又重新连接的场景下。此时服务器根据 <code>psync &#123;runid&#125; &#123;offset&#125;</code> 来进行增量复制。该实现过程通过环形缓冲区 repl_backlog_buffer 实现，主从服务器分别记录自己的 offset，从而实现增量同步，如果从服务器 offset 对应的数据已经被覆盖，则通过全量复制实现，可以通过 repl_backlog_size 设置该环形缓冲区大小。</p>
</li>
<li><p>replication buffer 和 repl_backlog_buffer 的区别？</p>
<p>前者指写操作数据传送到从服务器时通信所需的缓冲区，若存在多个从服务器，则其中的数据不一定相同；后者指的是增量复制发生时，从何处开始进行增量复制操作，主要用于找到主从差异数据而设计的环形缓冲区。</p>
</li>
<li><p>主从同步时，主服务器不进行持久化时存在那些安全隐患？</p>
<p>若主服务器没有开启持久化，应该将其配置为避免自动重启，否则自动重启后主节点上只有一个空数据集，并且会复制到其它从节点上。</p>
</li>
<li><p>为什么还存在从库的从库，这种架构模式？</p>
<p>若所有的从库连接到相同主库上，会给主库带来网络和磁盘上的消耗，容易造成单点故障。</p>
</li>
<li><p>Redis 中的无磁盘复制模式？</p>
<p>Redis 默认使用磁盘复制，但是其性能收到磁盘速度的限制，无磁盘复制模式即创建一个新进程直接 dump RDB 到 slave 的 socket，不经过硬盘，适用于网络较快的情况。</p>
</li>
<li><p>从库是否会检查数据是否过期？</p>
<p>在主从复制中，从节点不会主动删除数据，而是通过主节点控制从节点来删除过期数据；在 Redis 3.2 后，从节点在读取数据的时候，增加了对数据是否过期的判断（惰性删除）。</p>
</li>
<li><p>哨兵机制的意义？</p>
<p>通过部署一系列的哨兵节点，让其时刻监视主从服务节点，在主从节点发生故障时，能够自动进行故障转移的功能。</p>
</li>
<li><p>哨兵节点的作用是什么？</p>
<p>主要作用有三点：监控，选主，通知。</p>
<ul>
<li>监控：通过 ping 命令判断主从节点是否发生故障，一旦检测到主观下线，就会和其他哨兵节点协商，达到 quorum 值便可确定其为客观下线</li>
<li>选主：<ul>
<li>在已下线主节点的所有从节点中选取一个从节点，将其当作新的主节点：<code>SLAVEOF no one</code></li>
<li>让已下线主节点的所有其他从节点修改复制目标，修改其为新的主节点：<code>SLAVEOF</code></li>
<li>将新主节点的 IP 地址和信息，通过发布订阅机制通知给客户端：<code>+switch-master</code></li>
<li>继续监视原来的旧主节点，但这个旧主节点重新上线时，修改其为从节点</li>
</ul>
</li>
</ul>
</li>
<li><p>哨兵节点发现客观下线后，选主的依据是什么？</p>
<p>首先过滤网络状态不好的节点，其次按照优先级，复制进度和 ID 号挑选新从节点作为新的主节点。</p>
</li>
<li><p>哨兵节点发送的 INFO 命令的作用？</p>
<p>用于获取该节点的角色信息，如其对应的从节点列表等。</p>
</li>
<li><p>通常哨兵机制中使用了哨兵集群，如何让哨兵之间互相发现彼此（哨兵发现）？</p>
<p>通过命令 <code>sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</code> 进行哨兵配置，主节点中存在 <code>__sentinel__:hello</code> 频道，其他哨兵可以通过订阅该频道，用以发现其他哨兵并进行连接。</p>
</li>
<li><p>哨兵集群中的哨兵节点如何发现主节点下的从节点？</p>
<p>通过 INFO 命令，主节点会返回所有的从节点信息。</p>
</li>
<li><p>什么是主从集群脑裂现象，产生原因和解决方案？</p>
<p>产生原因：由于网络问题，导致集群节点之间失去联系，主从节点间数据不同步，哨兵重新选举，产生两个主节点，等待网络恢复，旧主节点会降级为从节点，由于其与新节点进行同步复制的时候，会清空自己的缓冲区，导致之前客户端写入的数据被丢失。</p>
<p>解决方案：当主节点发现从节点下线或者通信延迟过大时，那么禁止主节点进行写数据，直接把错误返回给客户端，以减少数据丢失，可以通过以下两个参数控制</p>
<ul>
<li>min-slaves-to-write x，主节点必须要有至少 x 个从节点连接，如果小于这个数，主节点会禁止写数据</li>
<li>min-slaves-max-lag x，主从数据复制和同步的延迟不能超过 x 秒，如果超过，主节点会禁止写数据</li>
</ul>
</li>
<li><p>为什么需要切片集群模式？</p>
<p>当 Redis 缓存数据量大到一台服务器无法缓存时，就需要使用切片集群模式，其将数据分布在不同的服务器上，以此降低系统对单节点的依赖，提高读写性能，实际上就是服务器 Sharding 技术。</p>
</li>
<li><p>Redis 中，切片集群模式的实现？</p>
<p>采用哈希槽来处理数据和节点之间的映射关系，一个切片集群共有 16384 个哈希槽，通过 CRC16 和取模实现 key 到哈希槽的映射。可以平均分配哈希槽到服务节点，也可以手动进行分配。</p>
</li>
<li><p>哈希槽和一致性哈希？</p>
<ul>
<li>哈希槽指的是先将用户数据划分到槽里面，然后将槽划分到不同服务器节点上，可以为不同硬件服务器自定义槽数目大小</li>
<li>一致性哈希则是将服务器节点划分在一个哈希环上，主要目的是减少新增节点导致的重新哈希的问题，容易产生数据倾斜问题，可以引入虚拟节点映射减轻该问题</li>
</ul>
</li>
<li><p>什么是缓存雪崩，如何应对？</p>
<p>大量缓存数据在同一时间过期，或者 Redis 故障宕机时，此时大量的请求访问数据库，从而导致数据库压力骤增，严重的会造成数据库宕机，而造成系统崩溃。对于大量数据在同一时间过期，可以均匀设置过期时间，后台更新缓存；对于 Redis 宕机，可以采用服务熔断，请求限流或者构建 Redis 高可用集群。</p>
</li>
<li><p>什么是缓存击穿，如何应对？</p>
<p>如果缓存中的某个热点数据过期，此时大量的请求访问该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮。可以采用互斥锁来保证同一时间内只有一个请求来构建缓存，同时设置超时时间防止死锁，或者采取永远不过期策略，让后台线程定时更新，抑或是进行缓存预热。</p>
</li>
<li><p>什么是缓存穿透，如何应对？</p>
<p>当用户访问的数据，既不在缓存中，也不在数据库中，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，没办法构建缓存数据，来服务后续的请求，就到导致服务器的压力骤增。可以采取限制非法请求，缓存默认值，或者使用布隆过滤器快速判断数据是否存在。</p>
</li>
<li><p>布隆过滤器工作原理？</p>
<p>使用使用位图和多个哈希函数快速判断数据是否存在数据库中，查询布隆过滤器说数据存在，并不一定证明数据库中存在这个数据，但是查询到数据不存在，则数据库中一定就不存在这个数据。</p>
</li>
<li><p>使用 Redis 作为缓存时，如果采用 Write Update 方式，可能存在哪些问题？</p>
<p>更新数据时，不论是先更新数据库，再更新缓存，还是先更新缓存，再更新数据库，都可能会产生不一致现象。</p>
</li>
<li><p>使用 Redis 作为缓存时，一般使用的缓存策略是什么？</p>
<p>Cache Aside：在更新数据时先更新数据库，再删除缓存中的数据；而在读取数据时，发现缓存中没了数据之后，直接从数据库中读取数据，并更新到缓存中。注意写操作时不能先删除缓存中的数据，再更新数据库，这在写读并发可能带来不一致现象。而在读写并发时，存在极小概率会产生不一致，原因是缓存的写入通常远远快于数据库的写入。</p>
</li>
<li><p>Cache Aside 策略会对命中率产生影响，如何缓解？</p>
<ul>
<li>更新数据时同样更新缓存，不过需要加分布式锁；</li>
<li>更新数据时同样更新缓存，不过需要加过期时间，保证最终一致性</li>
</ul>
</li>
<li><p>如何保证 Cache Aside 策略中先更新数据库，再更新缓存的操作都能成功？</p>
<ul>
<li>重试机制：引入消息队列，如果删除缓存的操作未成功，那就重试</li>
<li>订阅 MySQL binlog，再操作缓存：阿里巴巴开源 Canal 中间件的实现方式</li>
</ul>
</li>
<li><p>Redis 作为数据库缓存时，能否采用 Write Back 策略？</p>
<p>Write Back 写策略则只需标记缓存数据为脏数据之后，直接返回即可，在写未命中时，采用 Write Allocate 方式。读策略在未命中的情况下如果发现被置换的缓存块是脏块，则需要将其写入数据库。该策略不能被应用到我们常用的数据库和缓存的场景中，因为缓存一般是非持久化的，如果缓存机器掉电，脏块数据就会丢失。</p>
</li>
<li><p>Redis 如何实现分布式锁？</p>
<ul>
<li>最简化版本：使用 setnx key value 和 delete key 实现加锁和释放锁</li>
<li>支持过期时间：防止获取了锁的服务挂掉而没有释放锁资源，使用 set key value nx ex seconds</li>
<li>加上 owner：防止其他服务删除该服务已获取到的锁，可以设置不同的 value 表示不同的 owner</li>
<li>整合原子操作：加上 owner 后需要先检查，如果是自己的锁再释放，该过程不是原子性的，使用 Lua</li>
</ul>
</li>
<li><p>Redis 如何保证分布式锁的可靠性？</p>
<ul>
<li>容灾考虑：<ul>
<li>主从容灾：Redis 的哨兵模式可以灵活切换，但是存在同步时延的问题</li>
<li>多机部署：使用 Redis 中的 RedLock，只有超过半数同意才能算请求成功</li>
</ul>
</li>
<li>没有完全可靠的分布式锁，存在三大困境：网络延迟，进程暂停，时钟漂移</li>
</ul>
</li>
<li><p>Redis 为什么这么快？</p>
<ul>
<li>基于内存实现，没有 IO 开销</li>
<li>高效的数据结构：如 SDS，快表，跳跃表</li>
<li>合理的数据编码：如 String 对象存储数字的时候，采用 int 类型编码，非数字采用 SDS 编码</li>
<li>合适的线程模型：采用 Reactor 单线程模型，省去了上下文切换的开销（执行命令是单线程）</li>
</ul>
</li>
<li><p>Redis 的过期删除策略？</p>
<p>对数据库中已经过期的键值对进行删除，存在过期字典用于快速判断，主要采用以下两种策略：</p>
<ul>
<li>惰性删除：不主动删除过期键，每次访问 key 的时候，才检查 key 是否过期，通过函数 expireIfNeeded 实现</li>
<li>定期删除：每隔一段时间从过期字典中挑选一定的数据检查其是否过期，如果过期率大于 25% 并且此次运行时间小于 25ms，则继续上述操作</li>
</ul>
</li>
<li><p>Redis 的内存淘汰策略？</p>
<p>当运行内存达到最大值时，需要淘汰某些 key 用于缓存新的键值对：</p>
<ul>
<li>不进行数据淘汰：noeviction，返回错误通知客户端</li>
<li>进行数据淘汰：<ul>
<li>在设置了过期时间的数据中进行淘汰：volatile-random，volatile-ttl，volatile-lru，volatile-lfu</li>
<li>在所有数据范围内淘汰：allkeys-random，allkeys-lru，allkeys-lfu</li>
</ul>
</li>
</ul>
</li>
<li><p>Redis 4 新增特性有哪些？</p>
<p>新增 LFU 逐出策略，添加了 UNLINK 操作，添加了混合持久化功能，新增 MEMORY 命令。</p>
</li>
<li><p>Redis 5 新增特性有哪些？</p>
<p>Stream 类型，动态 Hz，ZPOPMIN，以及 CLIENT UNBLOCK 命令等。</p>
</li>
<li><p>Redis 6 新增特性有哪些？</p>
<p>多线程处理网络 IO，ACL 支持（之前通过 RENAME），客户端缓存，集群代理等。</p>
</li>
<li><p>Redis 查看自身状态的命令？</p>
<p>INFO，MONITOR，LATENCY。</p>
</li>
<li><p>Redis 可视化工具？</p>
<p>redis-stat，redmon；基于 redis_exporter，prometheus，grafana。</p>
</li>
<li><p>Redis 介绍？</p>
<p>Redis 是一个内存数据库，不过和传统的 RDBM 不同，Redis 属于 NoSQL，其存储类型为 KV。Redis 被广泛用于缓存方向，同时也可用于分布式锁，高速消息队列和事件发布与订阅等方面。Redis 提供了多种数据类型来支持不同的业务场景，还支持持久化、Lua 脚本、多种集群（主从复制模式，分布式切片集群）方案。</p>
</li>
<li><p>Redis 使用场景？</p>
<ul>
<li>热点数据的缓存</li>
<li>限时业务应用，通过 expire 设置 key 的过期时间</li>
<li>计数器相关问题</li>
<li>分布式锁，通过 setnx 实现，通过 lua 脚本实现原子性</li>
<li>延时操作，下单 10 分钟后无操作自动取消订单，通过 Zset 实现</li>
<li>排行榜相关问题，使用 Zset 实现</li>
<li>点赞，好友等相互关系存储，使用 Set 的集合命令实现</li>
<li>队列，通过 list 可以实现简单队列，可以使用 Stream 提供消息队列支持，存在局限性</li>
</ul>
</li>
<li><p>那 NoSQL 的 BASE 理论是什么？</p>
<p>BASE 理论是 CAP 理论中对一致性的妥协，和传统事务的 ACID 截然不同，BASE 不追求强一致性，而是允许数据在一段时间内是不一致的，但最终达到一致状态，从而获得更高的可用性和性能。</p>
</li>
<li><p>分布式缓存常见的技术选型方案有哪些？</p>
<p>使用比较多的是 Memcached 和 Redis，Memcached 是分布式缓存最开始兴起的那会，比较常用的，现在基本使用 Redis。</p>
</li>
<li><p>Redis 和 Memcached 的区别和共同点？</p>
<p>共同点：内存数据库，过期策略，性能高。</p>
<p>区别：</p>
<ul>
<li>Redis 支持更丰富的数据类型，Memcached 只支持最简单的 k&#x2F;v 数据类型</li>
<li>Redis 支持数据的持久化，灾难恢复机制，原生集群模式，Lua 脚本</li>
<li>Redis 采用的是 IO 多路复用模型，Memcached 使用多线程，非阻塞 IO 复用的网络模型</li>
<li>Redis 支持惰性删除和定期删除，但是 Memcached 只支持惰性删除</li>
</ul>
</li>
<li><p>为什么使用 Redis 作为 MySQL 缓存？</p>
<p>高性能：将热点数据放在缓存中，就不用访问数据库了，提升用户体验</p>
<p>高并发：数据在缓存中，支持更高级别的并发</p>
</li>
<li><p>Redis 对象机制解析？</p>
<p>通过 void* ptr 指向实际的数据结构，使用 type 可以检查命令是否能够执行，检查 encoding 来选择合适的函数执行命令，实现了命令的多态；通过 lru 统计上一次访问时间，或者是 lfu 的相关信息，用于内存淘汰策略实现；通过 refcount 实现对象计数，便于进行对象共享（默认共享 10000 以内的整数）和内存回收。</p>
</li>
<li><p>Redis 是单线程吗？</p>
<p>Redis 单线程指的是其处理用户指令，解析请求，进行数据读写，发送数据给客户端任务都是一个线程内执行的，但是 Redis 程序并不是单线程的：</p>
<ul>
<li>Redis 2.6 版本之前，启动 2 个后台线程，用于关闭文件和 AOF 刷盘</li>
<li>Redis 4.0 版本之后，新增了一个后台线程（lazyfree），用来异步释放 Redis 内存。使用 del 会同步释放内存，处理大 key 的时候，可能造成卡顿，可以使用 unlink 命令</li>
</ul>
</li>
<li><p>Redis 单线程模型详解？</p>
<p>Redis 基于 Reactor 单线程实现，通过 IO 多路复用程序来监听来自客户端的大量连接，减少了资源的消耗，Redis 服务器本身是一个事件驱动程序，主要分为时间事件和文件事件。当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时，与操作相对应的文件事件就会产生，对应的文件事件处理器就会被调用。</p>
</li>
<li><p>Redis 没有使用多线程？为什么不使用多线程？</p>
<p>Redis 其实在 4.0 之后就加入了对多线程的支持，在 6.0 后才算是使用了多线程，之前未使用的原因有：单线程编程容易维护，Redis 的性能瓶颈在内存和网络，多线程会带来上下文切换的开销等。</p>
</li>
<li><p>Redis 6.0 之后为何引入了多线程？</p>
<p>主要是为了提高网络 IO 读写性能，因为这是其一个性能瓶颈，但是执行命令仍然是单线程顺序执行。因此，该版本之后，在 Redis 启动的时候，会创建以下线程：</p>
<ul>
<li>Redis-server：主线程，主要负责执行命令</li>
<li>bio_close_file，bio_aof_fsync，bio_lazy_free：后台线程，处理耗时任务</li>
<li>io_thd_1，io_thd_2，io_thd_3：三个 IO 多线程，分担 Redis 的网络 IO 的压力</li>
</ul>
</li>
<li><p>Redis 大 key 如何处理？</p>
<p>大 key：指 key 对应的 value 很大，如 String 类型值大于 10KB，或者元素个数大于 5000 个</p>
<p>大 key 影响：</p>
<ul>
<li>客户端超时阻塞</li>
<li>引发网络阻塞</li>
<li>阻塞工作线程</li>
<li>内存分布不均（Slot 平均分配）</li>
<li>AOF 写回策略为 Always 时，每次写大 key 都会阻塞较长时间</li>
<li>AOF 重写和 RDB 快照时，都会进行 fork，fork 中需要复制父进程的页表，此过程耗时并且阻塞主进程，另外，如果开启了内存大页会产生写放大的问题</li>
</ul>
<p>通过以下方法找到大 key：</p>
<ul>
<li>redis-cli –bigkeys：最好在从节点上执行，只能返回每种类型的最大一个 bigkey</li>
<li>使用 SCAN 命令查找：使用 SCAN 扫描，使用 TYPE 查看类型，最后统计值大小</li>
<li>使用 RdbTools 工具查找大 key</li>
</ul>
<p>删除大 key 的方式：</p>
<ul>
<li>分批次删除：hscan，pop，sranmember，zremrangebyrank</li>
<li>异步删除：使用 unlink 代替 del 进行删除，不会造成阻塞</li>
</ul>
</li>
<li><p>Redis 管道技术作用？</p>
<p>是客户端提供的批处理技术，用于一次处理多个 Redis 命令，从而提升交互性能，可以解决多个命令执行时的网络等待。</p>
</li>
<li><p>Redis 给缓存数据设置过期时间有啥用？</p>
<p>内存是有限的，节省内存资源；像 token 这类的数据存在时效性，如果利用传统数据库处理的话，这样更麻烦并且性能更差；在实现分布式锁的时候，可以防止获取了锁资源的进程意外宕机而造成锁资源一直没有释放的问题。</p>
</li>
<li><p>Redis 是如何判断数据是否过期的呢？</p>
<p>Redis 通过过期字典来保存数据过期的事件，对应键值保存着其过期时间戳。</p>
</li>
<li><p>过期的数据的删除策略了解么？</p>
<p>惰性删除：只会在取出 key 的时候检查，对 CPU 友好，但是可能有太多过期 key 存在于缓存中</p>
<p>定期删除：每隔一段时间抽取一批 key 执行删除过期 key 操作</p>
<p>定时删除：设置过期时间的同时，创建一个定时器，定时器超时时执行删除操作</p>
<p>Redis 采用的是定期删除 + 惰性删除，但是仍然存在定期删除和惰性删除漏掉了很多过期 key 的情况，可能导致 OOM，为了解决该问题，使用 Redis 内存淘汰机制。</p>
</li>
<li><p>Redis 如何做内存优化？</p>
<p>缩减键和值的长度，共享对象池，字符串优化，编码优化，控制 key 的数量。</p>
</li>
<li><p>Redis 内存淘汰机制了解么？</p>
<p>一共有 8 种：volatile-lru，volatile-lfu，volatile-ttl，volatile-random，allkeys-lru，allkeys-lfu，allkeys-random，no-eviction。通过 maxmemory_policy 配置。</p>
</li>
<li><p>Redis 持久化机制(怎么保证 Redis 挂掉之后再重启数据可以进行恢复)？</p>
<p>支持 RDB 和 AOF 两种持久化机制，最好使用<strong>混合持久化</strong>（aof-use-rdb-preamble）。RDB 优点是文件紧凑，占用空间小，恢复速度快，AOF 优点是发生故障时，丢失的数据比 RDB 更少。</p>
</li>
<li><p>AOF 文件会越来越大，最后磁盘都装不下？</p>
<p>当文件体积过大时，会自动创建子进程，专门对 AOF 进行重写。重写过程中，还需要将命令记录在 AOF 重写缓冲区，重写完成后，AOF 重写缓冲区的内容会被追加进去。</p>
<blockquote>
<p>AOF 重写是通过读取数据库中的键值对来实现的</p>
</blockquote>
</li>
<li><p>Redis 持久化时，对过期键如何处理？</p>
<p>RDB 格式：</p>
<ul>
<li>生成阶段：会提前检查 key，过期的将将不会保存在新的 RDB 文件中</li>
<li>加载阶段：<ul>
<li>如果是主服务器，会对其中的键检查，过期键不会被载入</li>
<li>如果是从服务器，不会进行检查</li>
</ul>
</li>
</ul>
<p>AOF 格式：</p>
<ul>
<li>写入阶段：会保存对应的过期键，在删除后会追加 DEL 命令</li>
<li>重写阶段：会检查过期时间，已过期的键不会保存到重写后的 AOF 文件中</li>
</ul>
</li>
<li><p>Redis 事务？</p>
<p>并不支持原子性和持久性，实际上可以理解为将多个命令的请求打包，然后再顺序执行其中所有命令，该过程不会被打断。即使命令产生错误，也不会进行回滚，其原因：</p>
<ul>
<li>Redis 事务执行时，错误通常是编程错误造成的，这种错误基本不会出现在生产环境中</li>
<li>不支持事务回滚是因为这种复杂功能和 Redis 追求的简单高效设计主旨不符</li>
</ul>
</li>
<li><p>那Redis字符串有什么特点？</p>
<p>Redis 的字符串如果保存的对象是整数类型，那么就用 int 存储。如果不能用整数表示，就用 SDS 来表示，SDS 通过记录长度，和预分配空间，可以高效计算长度，进行 append 操作。</p>
</li>
<li><p>Hash 扩容过程是怎样的？</p>
<p>当装载因子超过阈值时，就会进行 rehash 过程，将 0 号表上的每个桶慢慢移动到 1 号表，所以叫渐进式 rehash。</p>
</li>
<li><p>能详细说下Rehash过程吗？</p>
<p>首先，生成新哈希表 ht[1]，为 ht[1] 分配空间。</p>
<p>然后，迁移 ht[0] 数据到 ht[1]。在 Rehash进行期间，每次对字典执行增删查改操作，程序会顺带迁移一个 ht[0] 上的数据，并更新偏移索引。</p>
<p>最后，ht[1] 和 ht[0] 指针对象交换。</p>
</li>
<li><p>如果字典正在 Rehash，此时有请求过来，Redis 会怎么处理？</p>
<p>针对新增 Key，是往 ht[1] 里面插入。针对读请求，先从 ht[0] 读，没找到再去 ht[1] 找。删除和更新操作和读操作类似。</p>
</li>
<li><p>跳表的实现？</p>
<p>本质上是对链表的一种优化，通过逐层跳步采样的方式构建索引，以加快查找速度。</p>
</li>
<li><p>跳表的每个节点有多少层？</p>
<p>使用概率均衡的思路，确定新插入节点的层数。Redis 使用随机函数决定层数。直观上来说，默认1层，和丢硬币一样，如果是正面就继续往上，这样持续迭代，最大层数 32 层。</p>
</li>
<li><p>Redis 的 Zset 为什么同时需要字典和跳表来实现？</p>
<p>Zset 是一个有序列表，字典和跳表分别对应两种查询场景，字典用来支持按成员查询数据，跳表则用以实现高效的范围查询，这样两个场景，性能都做到了极致。</p>
</li>
<li><p>为什么使用跳表而不是平衡树？</p>
<ul>
<li>内存占用上，平衡树每个节点 2 个指针，跳表每个节点 1&#x2F;(1 - p) 个指针，Redis 中 p 为 0.25</li>
<li>做范围查找的时候，跳表比平衡树操作更加简单</li>
<li>算法实现上，跳表比平衡树简单</li>
</ul>
</li>
<li><p>Redis 如何实现延迟队列？</p>
<p>延迟队列指的是把当前要执行的任务，往后推迟一段时间再执行，如淘宝下单后超过一定时间未付款则自动取消订单任务。可以通过 Zset 实现，使用 score 当作执行时间戳，消费者通过 zrangebyscore 进行轮询处理。</p>
</li>
<li><p>Redis 机器挂掉怎么办？</p>
<p>可以用主从模式部署，即有一个或多个备用机器，备用机会作为 Slave 同步 Master 的数据，在 Redis 出现问题的时候，把 Slave 升级为 Master。</p>
</li>
<li><p>主从可以自动切换吗？</p>
<p>本身是不能，但是 Redis 已经有了解决方案，即哨兵模式。哨兵来监测Redis服务是否正常，异常情况下，由哨兵代理切换。为避免哨兵成为单点，哨兵也需要多机部署。</p>
</li>
<li><p>如果 Master 挂掉，会选择哪个 Slave 呢？</p>
<p>当哨兵集群选举出哨兵 Leader 后，由哨兵 Leader 从 Redis 从节点中依次选择一个作为主节点</p>
<ul>
<li>优先级最高的节点</li>
<li>复制偏移量最大的节点</li>
<li>runid 最小的节点</li>
</ul>
</li>
<li><p>前面你提到了哨兵 Leader，那它是怎么来的呢？</p>
<p>当一个哨兵节点确认Redis集群的主节点主观下线后，会请求其他哨兵节点要求将自己选举为 Leader。如果一个哨兵节点获得的选举票数超过节点数的一半，且大于 quorum 配置的值，则该哨兵节点选举为Leader；否则重新进行选举。</p>
</li>
<li><p>为什么 Redis 集群的哈希槽是 16384（2 的 14 次方）？</p>
<p>Redis 在发送心跳包的时候需要将哈希槽的指派信息一起进行发送，如果使用 CRC16 原始范围，会造成心跳包过大，另一方面，Redis 集群一般不超过 1000 个节点，所以 16k 的槽位是个不错的选择。</p>
</li>
<li><p>为什么 Redis 集群中不建议使用发布订阅？</p>
<p>在集群模式下，所有的 publish 命令都会向所有节点（包括从节点）进行广播，造成网络带宽的严重消耗。</p>
</li>
<li><p>Redis 集群会有写操作丢失吗？</p>
<p>会，Redis 并不保证数据的强一致性，在 failover 过程中可能存在数据丢失。</p>
</li>
<li><p>Redis 性能这么高，那它是协程模型，还是多线程模型？</p>
<p>Redis 是单线程 Reactor 模型，通过高效的 IO 复用以及内存处理实现高性能。6.0 之后虽然加入了多线程来进行 IO 解包，但是处理逻辑依旧是单线程。</p>
<p>另外，如果考虑到 RDB 的 Fork，一些定时任务的处理，那么 Redis 也可以说多进程，这没有问题。但是 Redis 对数据的处理，至始至终，都是单线程。</p>
</li>
<li><p>可以详细说下6.0版本发布的多线程功能吗？</p>
<p>多线程功能，主要用于提高解包的效率。和传统的 Multi Reactor 多线程模型不同，Redis 的多线程只负责处理网络 IO 的解包和协议转换，一方面是因为 Redis 的单线程处理足够快，另一方面也是为了兼容性做考虑。</p>
</li>
<li><p>如果数据太大，Redis 存不下了怎么办？</p>
<p>使用集群模式，也就是将数据分片，不同的 Key 根据 Hash 路由到不同的节点。集群索引是通过一致性Hash 算法来完成，这种算法可以解决服务器数量发生改变时，所有的服务器缓存在同一时间失效的问题。</p>
</li>
<li><p>一致性Hash能详细讲一下吗？</p>
<p>传统的 Hash 分片，在节点扩容或者缩容的时候，需要重新哈希。一致性Hash是说将数据和服务器，以相同的 Hash 函数，映射到同一个 Hash 环上，针对一个对象，在哈希环上顺时针查找距其最近的机器，这个机器就负责处理该对象的相关请求。这样在节点数量增加时，只有少量的数据需要重新哈希。</p>
</li>
<li><p>如何设计一个缓存策略，可以动态缓存热点数据呢？</p>
<p>通过数据最新访问时间来做排名，并过滤掉不常访问的数据，只留下经常访问的数据</p>
<ul>
<li>通过缓存系统做一个排序队列（存放 1000 个商品），系统根据访问时间进行排序</li>
<li>系统定期删除排名最后的 200 个商品，并且从数据库中随机读取 200 个商品加入队列中</li>
</ul>
</li>
<li><p>Redis 经常用作缓存，那数据一致性怎么保证？</p>
<p>从设计思路来说，有 Cache Aside 和 Read&#x2F;Write Through 两种模式，前者是把缓存责任交给应用层，后者是将缓存的责任，放置到服务提供方。</p>
</li>
<li><p>如果数据发生变化，你会怎样去更新缓存？</p>
<p>一般有四种方式：</p>
<ul>
<li>数据存到数据库中，成功后，再让缓存失效，等到读缓存不命中的时候，再加载进去；</li>
<li>通过消息队列更新缓存；</li>
<li>先更新缓存，再更新服务，这种情况相当于把 Cache 也做 Buffer 用；</li>
<li>启动一个同步服务，作为 MySQL 一个从节点，通过解析 binlog 同步重要缓存</li>
</ul>
</li>
<li><p>说一下布隆过滤器的实现吧？</p>
<p>底层是一个 64 位的整型，将字符串用多个 Hash 函数映射不同的二进制位置，将整型中对应位置设置为1。布隆过滤器优缺点都很明显，优点是空间、时间消耗都很小，缺点是结果不是完全准确，其能提供的信息是某样东西一定不存在或者可能存在。</p>
</li>
<li><p>那 Redis 可以做消息队列吗？</p>
<p>可以，但是并不合适，Redis 本身没有支持 AMQP 规范，消息队列该有的能力缺胳膊少腿，消息可靠性不强。甚至 Redis 作者都看不下去了，开源了 Disque 来专事专做。</p>
</li>
<li><p>那你能谈谈 Redis 在秒杀场景的应用吗？</p>
<p>Redis 主要是起到选拔流量的作用，记录商品总数，还有就是已下单数，等达到总数之后拦截所有请求。可以多放些请求进来，然后塞入消息队列。</p>
</li>
<li><p>你能继续说说 Redis 在分布式锁中的应用吗？</p>
<p>分布式锁也依赖存储组件，针对请求量的不同，可以选择 Etcd、MySQL、Redis  等。前两者可靠性更强，Redis 性能更高。</p>
</li>
<li><p>基于 Redis 实现分布式锁有什么优缺点？</p>
<p>优点：性能高效，实现方便，避免单点故障</p>
<p>缺点：</p>
<ul>
<li>超时时间不好设置</li>
<li>主从复制模式中的数据是异步复制的，这样导致分布式锁的不可靠性，可以使用 RedLock，其基本思路是让客户端和多个独立的 Redis 节点依次请求申请加锁，如果客户端能够和半数以上的节点成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁，否则加锁失败</li>
</ul>
</li>
<li><p>那我们再聊聊 Redis 在限流场景的应用吧？</p>
<p>在微服务架构下，限频器也需要分布式化。在分布式令牌桶中，Redis 负责管理令牌，微服务需要进行函数操作，就向 Redis 申请令牌，如果 Redis 当前还有令牌，就发放给它。拿到令牌，才能进行下一步操作。另一方面，令牌不光要消耗，还需要补充，出于性能考虑，可以使用懒生成的方式：使用令牌时，顺便生成令牌。这样子还有个好处：令牌的获取，和令牌的生成，都可以在一个 Lua 脚本中，保证了原子性。</p>
</li>
<li><p>Redis 中的 SDS（简单动态字符串）实现，有何优点？</p>
<p>采用 <code>(len, free, buf[])</code> 实现，可以带来的优点有：常数时间内获得字符串长度，减少字符串修改时内存分配的次数，杜绝缓冲区溢出问题，二进制兼容，兼容部分 C 语言字符串函数。</p>
</li>
<li><p>Redis 中的双向链表（LinkedList）实现？</p>
<p>可以归纳为带表头结构的双向无环链表，链表节点通过 void* 来保存不同值。</p>
</li>
<li><p>Redis 中的字典实现？</p>
<p>字典在 Redis 中用 dict 表示，每个 dict 内部保存有一个 ht[2]，其中一个用于存储实际数据，另外一个则用于 rehash 过程，通过少量批次实现 rehash，以减少 rehash 带来的性能影响。另外，对于哈希冲突的数据，采用头插链接法解决。</p>
</li>
<li><p>Redis 中字典 rehash 发生时间，以及过程？</p>
<p>当负载因子超过阈值或低于阈值时，便开始进行进行扩容或者缩容。</p>
<p>扩展或收缩哈希表需要将 ht[0] 里面的所有键值对 rehash 到 ht[1] 里面，但是，这个 rehash 动作并不是一次性、集中式地完成的，而是分多次、渐进式地完成。在渐进期间，字典会同时使用两个哈希表，但是插入的时候只会插入到 ht[1]。需要使用到 dict 结构中的 rehashidx 变量，每次移动后会将其加一。</p>
</li>
<li><p>Redis 中的跳表实现？</p>
<p>跳表被实现为带表头的一系列跳表节点组合而成，其支持平均 O(logn)，最坏 O(n) 的复杂度。每次有新的节点插入时，就会根据 score 进行排序，找到对应的位置进行插入，然后每次根据 0.25 概率，来确定层高，最后连接前后具有相同层高的节点。</p>
</li>
<li><p>为什么 Redis 使用跳表而不是红黑树？</p>
<ul>
<li>跳表的复杂度和红黑树相同，而且实现起来简单，额外的内存可以通过修改层高概率 p 权衡</li>
<li>ZSet 中经常使用 ZRANGE 和 ZREVRANGE 命令，此时跳表性能不会比其他的树结构索引性能差</li>
</ul>
</li>
<li><p>Redis 中的整数集合 intset 实现？</p>
<p>通过 <code>(encoding, length, contents[])</code> 实现，每次需要加入新的整数的时候，考虑新的整数所需字节数是否超过了 encoding 对应的大小，如超过则需要执行对应的升级操作，也就是将原来的数字进行符号扩展，再放置在整数集合中，注意，整数集合升级后便不会降级。</p>
</li>
<li><p>Redis 中的压缩列表实现？</p>
<p>通过 <code>(zlbytes, zltail, zllen, entry1, ..., entryN, zlend)</code> 实现，其中 entry 实现如下 <code>(pre_entry_length, encoding, content)</code>。pre_entry_length 既可能是 1 字节，也可能是 5 字节，因此，当一系列 entry 长度是 250-254 时，当某个 entry 发生扩展，便会引起接下来的一系列 entry 发生扩展，也被称为连锁更新。</p>
</li>
<li><p>Redis 中的对象是如何编码的？</p>
<p>redisObject 中包含的字段如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(type, encoding, *ptr, lru, refcount)</span><br></pre></td></tr></table></figure>

<p>type 对应对象的类型：String，List，Hash，Set，Zset</p>
<p>encoding 则对应每种类型实现编码，如 List 实现既可以是 ziplist，也可以是 linkedList</p>
<p>lru 表示对应的空转事件，用于实现 lru 逐出算法，另外也可以作为实现 lfu 算法的参数</p>
<p>refcount 则指定了对象的引用计数，还有对象共享的功能</p>
</li>
<li><p>Redis 是如何实现命令多态的？</p>
<p>相同的命令，根据不同的编码选择执行不同底层数据结构的具体实现，从而实现多态。</p>
</li>
<li><p>Redis 是如何进行内存回收的？</p>
<p>通过引用计数的方式实现，依赖 refcount 值。</p>
</li>
<li><p>Redis 中的对象共享池指什么，为什么没有实现对应的字符串共享池？</p>
<p>Redis 会在初始化服务器时，创建一万个字符串对象，这些对象包含了从 0 到 9999 的所有整数值，当服务器需要用到值为 0 到 9999 的字符串对象时，服务器就会使用这些共享对象，而不是新创建对象。</p>
<p>共享对象池中一个关键操作是判断对象是否相等。整数的比较算法的时间复杂度是 O(1)，相对而言，字符串的比较算法的时间复杂度是 O(n)，特别是长字符串的比较更加消耗性能。</p>
</li>
<li><p>Redis 内部如何存储数据的？</p>
<p>RedisServer 中存在一个 redisDb 数组，默认个数是 16 个。redisDb 中的 dict 字典保存有全部的键值对数据。实际上真正存储数据的是 dict 中的 dictht，存在两个，用于进行 rehash。</p>
</li>
<li><p>如何是指键的过期时间？</p>
<p>expire，pexpire，pexpireat，expireat，内部上都是通过 pexpireat 实现。</p>
</li>
<li><p>Redis 中的过期字典是什么，存在于什么位置？</p>
<p>存在于 RedisDb 结构中，用于记录哪些设置了过期时间的键，并且保存对应的过期时间戳。</p>
</li>
<li><p>Redis 中的过期删除策略有哪些，如何实现的？</p>
<p>惰性删除：expireIfNeeded 函数实现</p>
<p>定期删除：每次函数执行 serverCron 时，里面的 activeExpireCycle 就会被调用。原理是通过分多次遍历服务器中的各个数据库，从过期字典中随机抽查一部分键的过期时间，并且删除其中的过期键，其中 current_db 全部变量保存着当前指向到那个数据库中了，下次遍历的时候就可以接着从上次数据库的下一个接着检查。</p>
</li>
<li><p>RDB 在生成和恢复时，需要考虑过期键值吗？</p>
<p>在执行 SAWE 命令或者 BGSAVE 命令创建一个新的 RDB 文件时，程序会对数据库中的 键进行检查，已过期的键不会被保存到新创建的 RDB 文件中。</p>
<p>载入 RDB 文件的时候，如果服务器以主服务器模式运行，那么在载入 RDB 文件的时候，程序会剔除过期的键，如果是以从服务器模式运行的话，那么就会保存所有的键。</p>
</li>
<li><p>AOF 重写过程中，需要考虑过期键值吗？</p>
<p>AOF 文件重写的时候，会对数据库中的键进行检查，已经过期的键不会保存到 AOF 文件中。</p>
</li>
<li><p>在 Redis 复制时，如何处理过期键？</p>
<p>当服务器运行在复制模式下面的时候，从服务器的过期键的删除动作由主服务控制，从服务器不会主动删除过期的键，除非主服务器发送 DEL 命令来显式删除某个键。</p>
</li>
<li><p>RDB 文件生成方式有哪些，如何生成的？</p>
<p>主动生成：通过 SAVE 或者 BGSAVE 实现，通常使用 BGSAVE 命令实现，通过 fork 和写时复制实现</p>
<p>被动间隔生成：通过配置文件 save inteval modifyCount，若在 interval 中发生了 modifyCount 次修改，那么就会自动后台生成 RDB 文件</p>
<p>通过读取 redisDb 里面的数据字典和过期字典进行生成。</p>
</li>
<li><p>RDB 文件结构是怎样的？</p>
<p>整体上文件结构：(REDIS, version, databases, EOF, checksum)</p>
<p>databases 结构：(SELECTDB, db_num, key_value_pairs)</p>
<p>带有过期时间的键值对：(EXPIRETIME_MS, ms, TYPE, key, value)</p>
</li>
<li><p>AOF 文件如何生成的？</p>
<p>服务器在完成一个命令的之后，会将其保存在 redisServer 的 aof_buf 缓冲区的末尾。具体的刷盘时机则通过 appendfsync 参数决定。</p>
</li>
<li><p>AOF 重写为什么存在，有何作用，如何实现的？</p>
<p>随着时间的流逝，AOF 文件的内容会越来越多，不加以控制的话，会很容易超过体积最大限制造成影响。为了解决这个问题，Redis 提供了 AOF 文件重写的功能。重写功能是通过读取当前数据库的状态来实现的。另外为了提高服务器的可用性，一般执行 AOF 重写的时候采用的是后台重写，以此防止阻塞的问题。</p>
<p>使用子进程进行 AOF 文件的重写的时候，服务器会接受客户端的命令，而新的命令可能会造成数据库状态的修改，从而使得当前数据库状态和重写后的 AOF 文件保存的数据库状态不一致。为了解决这种数据不一致问题，Redis 服务器设置了一个 AOF 重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用，当 Redis 服务器执行完一个写命令之后，它会同时将这个写命令发送给 AOF 缓冲区和 AOF 重写缓冲区。当子进程完成重写操作的时候，会向父进程发送信号，父进程此时会将 AOF 重写缓冲区的内容写入到新的 AOF 文件中，最后执行改名覆盖现有的 AOF 文件，实现新旧两个 AOF 文件的替换。</p>
</li>
<li><p>Redis 中的事件循环机制？</p>
<p>Redis 自己实现了简单的事件循环，通过 IO 多路复用来处理网络套接字事件，实际执行命令的还是单个线程。Redis 中的事件分为文件事件和时间事件，文件事件用于处理用户请求，响应用户，连接应答等，时间事件中，Redis 目前只使用了周期时间，服务器将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，它就遍历整个链表，査找所有已到达的时间事件，并调用相应的事件处理器。 持续运行的 Redis 服务器需要对自身的资源和状态进行检查和调整，从而可以确保服务器可以长期稳定的运行，这些定期操作被封装到 redis.c&#x2F;serverCron 函数中执行。正常模式下 Redis 服务器只使用 serverCron 一个时间事件。</p>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://blog.zsstrike.tech">zsStrike</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://blog.zsstrike.tech/2022/12/05/Redis-%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/">http://blog.zsstrike.tech/2022/12/05/Redis-面试题目汇总/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://blog.zsstrike.tech" target="_blank">zsStrike</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Redis/">Redis</a></div><div class="post_share"><div class="social-share" data-image="/assets/default_cover.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/assets/avatar.jpg" onerror="this.onerror=null;this.src='/assets/default_cover.png'" alt="avatar"/></div><div class="author-info__name">zsStrike</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">52</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zsStrike"><i class="fab fa-github"></i><span>Github</span></a></div><div class="sticky_layout"></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2017 - 2023 By zsStrike</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>